<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com https://cdn.tailwindcss.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com;
    style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://unpkg.com https://cdn.jsdelivr.net;
    font-src 'self' https://fonts.gstatic.com https://unpkg.com https://cdn.jsdelivr.net data:;
    img-src 'self' data: blob:;
    connect-src 'self' https://cdn.jsdelivr.net https://unpkg.com https://cdn.tailwindcss.com https://pypi.org https://files.pythonhosted.org https://cdnjs.cloudflare.com;
    worker-src 'self' blob:;
    object-src 'none';
    base-uri 'self';
    form-action 'self';
    frame-ancestors 'none';
    ">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gbdraw Web App</title>
    <script src="https://unpkg.com/vue@3.5.25/dist/vue.global.js" integrity="sha384-E8hqvY4j8uyv6njj1udAOIuT4tsPt3lJET321mQPDQ29OMiTOYMuG/UDD6o52yW4" crossorigin="anonymous"></script>
    <!--
        SECURITY NOTE: TailwindCSS Play CDN uses JIT compilation, so Subresource Integrity (SRI)
        cannot be applied. This CDN dynamically generates CSS based on the page content.
        For production with stricter security requirements, consider using a static Tailwind build.
        See: https://tailwindcss.com/docs/installation
    -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.js" integrity="sha384-l95tshxQlbjf4kdyWZf10uUL5Dw8/iN9q16SQ+ttOEWA8SN0cLG6BGDGY17GxToh" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@phosphor-icons/web@2.1.2/src/index.js" integrity="sha384-J7cw2fbG1T4C5MirTVUxsZGaMfw2m0XsCgOQEqUvB1OF9VIsHWuZF1GmyVRzs7eu" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/3.0.3/jspdf.umd.min.js" integrity="sha384-GwHhSt8QjC7J+v0zZ0Flfho/T76YHEcCL9w4rvjTIUHauh6gWJeBSIi3vWXxNhtA" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.6.0/dist/svg2pdf.umd.min.js" integrity="sha384-UMdplNeJF/mRqnsNO/vfK5po5eKyTMGCymHkdARQ9NFscA4DX3buGxfhUJcPLbWj" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.2.7/purify.min.js" integrity="sha384-qJNkHwhlYywDHfyoEe1np+1lYvX/8x+3gHCKFhSSBMQyCFlvFnn+zXmaebXl21rV" crossorigin="anonymous"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+JP:wght@300;400;500;700&display=swap');
        body { font-family: 'Inter', 'Noto Sans JP', sans-serif; background-color: #f8fafc; color: #334155; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f5f9; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        .card { @apply bg-white p-4 rounded-xl shadow-sm border border-slate-200 mb-3 transition-all; }
        .card-header { @apply text-lg font-bold mb-3 text-slate-700 flex items-center gap-2 border-b pb-2; }
        .input-group { @apply mb-3; }
        .input-label { @apply block text-base font-bold text-slate-500 uppercase tracking-wider mb-1.5 flex items-center gap-1; }
        .form-input { @apply w-full bg-slate-50 border border-slate-200 text-slate-700 text-lg rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5 transition-all; }
        .form-checkbox { @apply w-5 h-5 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2; }

        .btn { @apply font-bold rounded-lg text-base px-4 py-2 shadow-sm transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2; }
        .btn-primary { @apply text-white bg-blue-600 hover:bg-blue-700; }
        .btn-secondary { @apply text-slate-700 bg-white border border-slate-300 hover:bg-slate-50; }
        .btn-danger { @apply text-red-600 bg-white border border-red-200 hover:bg-red-50; }
        .btn-sm { @apply px-2 py-1 text-xs; }

        /* Highlighted Generate Button Style */
        .btn-generate {
            @apply text-white bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 border-b-4 border-indigo-800 shadow-lg shadow-indigo-200;
        }
        .btn-generate:active { @apply border-b-0 translate-y-1; }

        .upload-zone {
            background-color: #fefce8;
            @apply border-2 border-dashed border-slate-300 rounded-lg p-3 text-center cursor-pointer select-none hover:border-blue-500 hover:bg-blue-50 relative transition-colors flex flex-col items-center justify-center min-h-[60px]; 
        }
        .upload-zone.ready { @apply bg-green-50 border-green-500; }
        
        details > summary { @apply list-none cursor-pointer font-bold text-slate-600 hover:text-blue-600 transition-colors flex items-center gap-2 select-none; }
        details > summary::-webkit-details-marker { display: none; }
        details[open] > summary { @apply mb-4 text-blue-600; }
        details > summary::before { content: ''; @apply w-4 h-4 bg-contain bg-no-repeat transition-transform duration-200; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%2364748b' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='9 18 15 12 9 6'%3E%3C/polyline%3E%3C/svg%3E"); }
        details[open] > summary::before { transform: rotate(90deg); }
    </style>
</head>
<body class="antialiased pb-0 overflow-hidden">

<div id="app" class="h-screen flex flex-col relative">
    
    <div v-if="!pyodideReady" class="fixed inset-0 bg-white z-[100] flex flex-col items-center justify-center p-4 text-center">
        <div class="animate-spin text-5xl mb-6">ðŸ§¬</div>
        <h3 class="text-2xl font-bold text-slate-800">Initializing gbdraw Serverless...</h3>
        <p class="text-slate-500 mt-2">Loading Python engine (Pyodide) and dependencies.</p>
        <p class="text-xs text-slate-400 mt-4 font-mono">{{ loadingStatus }}</p>
    </div>

    <div v-if="processing" class="fixed inset-0 bg-white/90 backdrop-blur-sm z-50 flex flex-col items-center justify-center">
        <div class="animate-spin w-16 h-16 border-4 border-blue-600 border-t-transparent rounded-full mb-6"></div>
        <h3 class="text-xl font-bold text-slate-800 animate-pulse">Generating Diagram...</h3>
    </div>

    <header class="bg-white border-b border-slate-200 sticky top-0 z-40 shadow-sm/50 backdrop-blur-md bg-white/90 h-14 shrink-0">
        <div class="px-4 h-full flex items-center justify-between">
            <div class="flex items-center gap-3">
                <div class="bg-blue-600 text-white w-8 h-8 rounded-lg flex items-center justify-center font-bold text-lg shadow-md">ðŸ§¬</div>
                <h1 class="text-lg font-bold text-slate-800 tracking-tight flex items-baseline">
                    gbdraw
                    <span class="text-slate-400 text-sm font-normal ml-3">A genome diagram generator for microbes and organelles</span>
                </h1>
            </div>
            
            <div class="flex items-center gap-3">
                <div class="flex gap-1 mr-4">
                    <button @click="exportConfig" class="text-xs font-bold text-slate-500 hover:text-blue-600 px-2 py-1 rounded border border-slate-200 bg-white flex items-center gap-1">
                        <i class="ph ph-export"></i> Save Config
                    </button>
                    <button @click="$refs.configInput.click()" class="text-xs font-bold text-slate-500 hover:text-blue-600 px-2 py-1 rounded border border-slate-200 bg-white flex items-center gap-1">
                        <i class="ph ph-arrow-square-in"></i> Load Config
                    </button>
                    <input type="file" ref="configInput" accept=".json" class="hidden" @change="importConfig">
                </div>

                <div class="flex bg-slate-100 p-1 rounded-lg">
                    <button @click="mode = 'circular'" :class="mode === 'circular' ? 'bg-white text-blue-600 shadow ring-1 ring-black/5' : 'text-slate-500 hover:text-slate-700'" class="px-4 py-1.5 rounded-md text-sm font-bold transition-all flex items-center gap-2"><i class="ph ph-circle"></i> Circular</button>
                    <button @click="mode = 'linear'" :class="mode === 'linear' ? 'bg-white text-blue-600 shadow ring-1 ring-black/5' : 'text-slate-500 hover:text-slate-700'" class="px-4 py-1.5 rounded-md text-sm font-bold transition-all flex items-center gap-2"><i class="ph ph-ruler"></i> Linear</button>
                </div>
            </div>
        </div>
    </header>

    <main class="flex-grow px-4 py-3 flex overflow-hidden h-[calc(100vh-88px)]">

        <div class="flex flex-col h-full overflow-hidden relative shrink-0"
             :style="{ width: sidebarWidth + 'px' }">
            
            <div class="flex-grow overflow-y-auto custom-scrollbar pr-2 pb-4 space-y-4">
                
                <div class="card border-l-4 border-l-blue-500">
                    <div class="card-header"><i class="ph ph-folder-open text-xl"></i> Input Genomes</div>
                    
                    <div v-if="mode === 'circular'" class="space-y-4">
                        <div class="flex gap-4 text-sm font-bold bg-slate-50 p-2 rounded-lg inline-flex">
                            <label class="flex items-center gap-2 cursor-pointer hover:text-blue-600"><input type="radio" v-model="cInputType" value="gb" class="text-blue-600 focus:ring-blue-500"> GenBank</label>
                            <label class="flex items-center gap-2 cursor-pointer hover:text-blue-600"><input type="radio" v-model="cInputType" value="gff" class="text-blue-600 focus:ring-blue-500"> GFF3 + FASTA</label>
                        </div>
                        <div v-if="cInputType === 'gb'">
                            <file-uploader label="GenBank File (.gb)" v-model="files.c_gb"></file-uploader>
                        </div>
                        <div v-else class="grid grid-cols-1 gap-3">
                            <file-uploader label="GFF3 File" accept=".gff,.gff3" v-model="files.c_gff"></file-uploader>
                            <file-uploader label="FASTA File" accept=".fasta,.fa,.fna" v-model="files.c_fasta"></file-uploader>
                        </div>
                    </div>

                    <div v-if="mode === 'linear'" class="space-y-4">
                        <div class="flex gap-4 text-sm font-bold bg-slate-50 p-2 rounded-lg inline-flex mb-2">
                            <label class="flex items-center gap-2 cursor-pointer hover:text-blue-600"><input type="radio" v-model="lInputType" value="gb" class="text-blue-600"> GenBank</label>
                            <label class="flex items-center gap-2 cursor-pointer hover:text-blue-600"><input type="radio" v-model="lInputType" value="gff" class="text-blue-600"> GFF3 + FASTA</label>
                        </div>
                        <div v-for="(seq, idx) in linearSeqs" :key="idx" class="p-3 bg-slate-50 rounded-lg border border-slate-200 relative group text-sm transition-all hover:border-blue-300">
                            <div class="absolute top-2 right-2 text-[10px] font-bold text-white bg-slate-400 px-1.5 py-0.5 rounded-full">#{{ idx + 1 }}</div>
                            <div v-if="lInputType === 'gb'" class="space-y-2">
                                <file-uploader label="GenBank File" v-model="seq.gb"></file-uploader>
                            </div>
                            <div v-else class="space-y-2 mb-2">
                                <file-uploader label="GFF3" accept=".gff" v-model="seq.gff"></file-uploader>
                                <file-uploader label="FASTA" accept=".fasta" v-model="seq.fasta"></file-uploader>
                            </div>
                            <div v-if="idx < linearSeqs.length - 1" class="mt-2 pt-2 border-t border-slate-200 border-dashed">
                                <div class="text-[10px] text-slate-500 font-bold mb-1 flex items-center gap-1"><i class="ph ph-arrows-down-up"></i> Compare to next (BLAST)</div>
                                <file-uploader label="BLAST TSV" accept=".txt,.tsv,.csv" v-model="seq.blast"></file-uploader>
                            </div>
                        </div>
                        <div class="flex gap-2">
                            <button @click="linearSeqs.push({gb:null, gff:null, fasta:null, blast:null})" class="btn btn-secondary text-xs w-full"><i class="ph ph-plus"></i> Add Seq</button>
                            <button v-if="linearSeqs.length > 1" @click="linearSeqs.pop()" class="btn btn-danger text-xs w-full"><i class="ph ph-minus"></i> Remove</button>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header"><i class="ph ph-sliders"></i> Basic Settings</div>
                    <div class="space-y-4">
                        <div class="grid grid-cols-2 gap-4">
                             <div>
                                <label class="input-label">Output Prefix <help-tip text="Prefix for output files. Leave empty to use the record name (e.g., NC_000xxx)."></help-tip></label>
                                <input type="text" v-model="form.prefix" class="form-input" placeholder="Optional (Default: Record ID)">
                            </div>
                             <div>
                                <label class="input-label">Legend <help-tip text="Position of the legend. 'None' hides the legend."></help-tip></label>
                                <select v-model="form.legend" class="form-input">
                                    <option value="right">Right</option><option value="left">Left</option>
                                    <option value="top" v-if="mode==='linear'">Top</option><option value="bottom" v-if="mode==='linear'">Bottom</option>
                                    <option value="upper_left" v-if="mode==='circular'">Upper Left</option><option value="upper_right" v-if="mode==='circular'">Upper Right</option>
                                    <option value="none">None</option>
                                </select>
                            </div>
                        </div>
                       
                        <div v-if="mode === 'circular'">
                            <label class="input-label">Track Layout <help-tip text="Choose how features are displayed. 'Tuckin' is default and compact. 'Middle' aligns to center, 'Spreadout' separates them."></help-tip></label>
                            <select v-model="form.track_type" class="form-input"><option value="tuckin">Tuckin (Compact)</option><option value="middle">Middle</option><option value="spreadout">Spreadout</option></select>
                        </div>

                        <div v-if="mode === 'linear'">
                             <label class="input-label">Scale Style <help-tip text="'Bar' draws a simple line, 'Ruler' draws a ruler with ticks and labels."></help-tip></label>
                             <select v-model="form.scale_style" class="form-input"><option value="bar">Bar (Simple)</option><option value="ruler">Ruler (Ticks)</option></select>
                        </div>

                        <div class="grid grid-cols-2 gap-y-2 gap-x-1 p-2 bg-slate-50 rounded-lg">
                            <div v-if="mode === 'linear'" class="col-span-2 mb-1">
                                <label class="input-label text-[10px] mb-1">Show Labels <help-tip text="Display feature labels on the map. 'First' shows labels only for the top track."></help-tip></label>
                                <select v-model="form.show_labels_linear" class="form-input text-xs py-1">
                                    <option value="none">None</option>
                                    <option value="all">All Records</option>
                                    <option value="first">First Record Only</option>
                                </select>
                            </div>
                            <label v-else class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                <input type="checkbox" v-model="form.show_labels" class="form-checkbox"> Show Labels <help-tip text="Display feature labels on the map."></help-tip>
                            </label>

                            <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                <input type="checkbox" v-model="form.separate_strands" class="form-checkbox"> Separate Strands <help-tip text="Display features on separate strands for better distinction."></help-tip>
                            </label>
                            
                            <template v-if="mode === 'circular'">
                                <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                    <input type="checkbox" v-model="form.allow_inner_labels" class="form-checkbox"> Inner Labels <help-tip text="Enable labels inside the circle. Automatically suppresses GC content/skew to avoid overlap."></help-tip>
                                </label>
                                <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                    <input type="checkbox" v-model="form.suppress_gc" class="form-checkbox"> Hide GC <help-tip text="Suppress the GC content track."></help-tip>
                                </label>
                                <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                    <input type="checkbox" v-model="form.suppress_skew" class="form-checkbox"> Hide Skew <help-tip text="Suppress the GC skew track."></help-tip>
                                </label>
                            </template>
                            
                            <template v-if="mode === 'linear'">
                                <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                    <input type="checkbox" v-model="adv.resolve_overlaps" class="form-checkbox"> Resolve Overlaps <help-tip text="Shift features vertically to avoid overlap. (Experimental)"></help-tip>
                                </label>
                                <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                    <input type="checkbox" v-model="form.align_center" class="form-checkbox"> Align Center <help-tip text="Align the linear map to the center of the page."></help-tip>
                                </label>
                                <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                    <input type="checkbox" v-model="form.normalize_length" class="form-checkbox"> Normalize Len <help-tip text="Normalize sequence lengths to be equal. Suppresses length bar."></help-tip>
                                </label>
                                <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                    <input type="checkbox" v-model="form.show_gc" class="form-checkbox"> Show GC <help-tip text="Display GC content track."></help-tip>
                                </label>
                                <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                    <input type="checkbox" v-model="form.show_skew" class="form-checkbox"> Show Skew <help-tip text="Display GC skew track."></help-tip>
                                </label>
                            </template>
                        </div>
                    </div>
                </div>

                <div class="card bg-slate-50/50">
                    <details>
                        <summary><i class="ph ph-palette"></i> Colors & Filters <help-tip text="Customize colors and filter labels by keyword."></help-tip></summary>
                        <div class="mt-4 space-y-6 pt-4 border-t border-slate-200">
                            
                            <div>
                                <div class="flex justify-between items-center mb-2">
                                    <h4 class="text-xs font-bold text-slate-500">DEFAULT COLORS (-d) <help-tip text="Base colors for features. Acts as the -d override table."></help-tip></h4>
                                    <button @click="resetColors" class="text-[10px] text-blue-600 hover:underline">Reset</button>
                                </div>
                                <select v-model="selectedPalette" @change="updatePalette" class="form-input mb-3">
                                    <option v-for="p in paletteNames" :value="p">{{ p }}</option>
                                </select>
                                <div class="grid grid-cols-5 gap-1.5 bg-white p-2 rounded border border-slate-200">
                                    <div v-for="(color, feat) in currentColors" :key="feat" class="flex flex-col items-center group relative cursor-pointer">
                                        <input type="color" v-model="currentColors[feat]" class="w-8 h-8 p-0 border-0 rounded cursor-pointer transition-transform hover:scale-110">
                                        <span class="text-[9px] text-slate-500 mt-0.5 truncate w-full text-center" :title="feat">{{ feat }}</span>
                                    </div>
                                </div>

                                <div class="mt-2 p-2 bg-slate-50 rounded border border-slate-200 flex gap-2 items-end">
                                    <div class="flex-grow">
                                        <label class="text-[9px] font-bold text-slate-500 block mb-1">ADD FEATURE</label>
                                        <select v-model="newColorFeat" class="form-input text-xs py-1 px-2 h-8">
                                            <option v-for="k in featureKeys" :value="k">{{ k }}</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label class="text-[9px] font-bold text-slate-500 block mb-1">COLOR</label>
                                        <input type="color" v-model="newColorVal" class="h-8 w-10 p-0 border border-slate-300 rounded cursor-pointer">
                                    </div>
                                    <button @click.prevent="addCustomColor" class="btn btn-secondary text-xs h-8">
                                        <i class="ph ph-plus"></i> Add
                                    </button>
                                </div>
                                <div class="mt-2">
                                    <div class="text-[10px] text-center text-slate-400 mb-1">- OR UPLOAD FILE -</div>
                                    <file-uploader label="Override File (-d)" v-model="files.d_color" :small="true"></file-uploader>
                                    <div class="text-[9px] text-slate-400 mt-1">
                                        <help-tip text="Tab-separated value (TSV) file that overrides the color palette. Feature types not specified will use the selected palette colors."></help-tip> 
                                        Override default feature colors.
                                    </div>
                                </div>
                            </div>

                            <div>
                                <div class="flex items-center justify-between mb-2">
                                    <h4 class="text-xs font-bold text-slate-500">SPECIFIC RULES (-t) <help-tip text="Color features matching specific qualifier values (Regex supported)."></help-tip></h4>
                                    <button v-if="manualSpecificRules.length > 0" @click="manualSpecificRules.splice(0)" class="text-[10px] text-red-500 hover:text-red-700 hover:underline"><i class="ph ph-trash"></i> Clear All</button>
                                </div>

                                <div class="space-y-1 mb-3">
                                    <div v-for="(rule, i) in manualSpecificRules" :key="i" class="flex items-center gap-1 bg-white p-1 rounded border border-slate-200 text-[10px]">
                                        <span class="w-12 font-bold truncate" :title="rule.feat">{{rule.feat}}</span>
                                        <span class="w-12 text-slate-500 truncate" :title="rule.qual">{{rule.qual}}</span>
                                        <span class="flex-grow text-blue-600 truncate font-mono" :title="rule.val">/{{rule.val}}/</span>
                                        <div class="w-4 h-4 rounded border" :style="{backgroundColor: rule.color}"></div>
                                        <button @click="manualSpecificRules.splice(i,1)" class="text-red-500 hover:text-red-700 px-1"><i class="ph ph-trash"></i></button>
                                    </div>
                                    <div v-if="manualSpecificRules.length === 0" class="text-[10px] text-slate-400 italic text-center py-2">No rules added</div>
                                </div>

                                <div class="bg-slate-50 p-2 rounded border border-slate-200">
                                    <div class="grid grid-cols-2 gap-1 mb-1">
                                        <select v-model="newSpecRule.feat" class="form-input text-xs p-1 h-7">
                                            <option v-for="k in featureKeys" :value="k">{{ k }}</option>
                                        </select>
                                        <input v-model="newSpecRule.qual" placeholder="Qualifier" class="form-input text-xs p-1 h-7">
                                    </div>
                                    <div class="flex gap-1 mb-1">
                                        <input v-model="newSpecRule.val" placeholder="Regex (e.g. hypothetical)" class="form-input text-xs p-1 h-7 flex-grow">
                                        <input type="color" v-model="newSpecRule.color" class="h-7 w-8 p-0 border rounded cursor-pointer shrink-0">
                                    </div>
                                    <div class="flex gap-1">
                                        <input v-model="newSpecRule.cap" placeholder="Legend Caption (Optional)" class="form-input text-xs p-1 h-7 flex-grow">
                                        <button @click="addSpecificRule" class="btn btn-secondary text-xs h-7 px-3"><i class="ph ph-plus"></i></button>
                                    </div>
                                </div>

                                <div class="mt-2">
                                    <div class="text-[10px] text-center text-slate-400 mb-1">- OR UPLOAD FILE -</div>
                                    <file-uploader label="Specific Table (-t)" v-model="files.t_color" :small="true"></file-uploader>
                                    <div class="text-[9px] text-slate-400 mt-1">
                                        <help-tip text="TSV file that overrides the color palette for specific features based on qualifiers."></help-tip>
                                        Override colors for specific features.
                                    </div>
                                </div>
                            </div>

                            <div>
                                <h4 class="text-xs font-bold text-slate-500 mb-2">LABEL FILTERING <help-tip text="Control which feature labels are displayed using Blacklist or Whitelist."></help-tip></h4>
                                <div class="flex gap-2 mb-2">
                                    <button v-for="m in ['None', 'Blacklist', 'Whitelist']" @click="filterMode = m" :class="filterMode===m ? 'bg-blue-600 text-white' : 'bg-white text-slate-600 border'" class="flex-1 py-1 rounded text-xs font-bold transition-colors">{{m}}</button>
                                </div>
                                
                                <div v-if="filterMode === 'Blacklist'" class="space-y-2 bg-white p-2 rounded border">
                                    <p class="text-[10px] text-slate-500">Exclude labels containing these keywords.</p>
                                    <textarea v-model="manualBlacklist" class="form-input h-20" placeholder="hypothetical, unknown"></textarea>
                                    <div class="text-[10px] text-center text-slate-400">- OR -</div>
                                    <file-uploader label="Blacklist File" v-model="files.blacklist" :small="true"></file-uploader>
                                </div>

                                <div v-if="filterMode === 'Whitelist'" class="space-y-2 bg-white p-2 rounded border">
                                    <p class="text-[10px] text-slate-500">Only show labels matching rules.</p>
                                    <div v-for="(row, i) in manualWhitelist" :key="i" class="flex gap-1 mb-1">
                                        <input v-model="row.feat" placeholder="Feat" class="form-input px-1 py-1 text-xs w-1/4">
                                        <input v-model="row.qual" placeholder="Qual" class="form-input px-1 py-1 text-xs w-1/4">
                                        <input v-model="row.key" placeholder="Keyword" class="form-input px-1 py-1 text-xs w-1/3">
                                        <button @click="manualWhitelist.splice(i,1)" class="text-red-500 hover:text-red-700 px-1">Ã—</button>
                                    </div>
                                    <button @click="manualWhitelist.push({feat:'CDS', qual:'product', key:''})" class="text-xs text-blue-600 font-bold">+ Add Rule</button>
                                    <div class="text-[10px] text-center text-slate-400 mt-2">- OR -</div>
                                    <file-uploader label="Whitelist File" v-model="files.whitelist" :small="true"></file-uploader>
                                </div>
                                
                                <div class="mt-4 pt-4 border-t border-slate-100">
                                    <h5 class="text-[10px] font-bold text-slate-500 mb-2">QUALIFIER PRIORITY <help-tip text="Define label priority order (e.g. CDS -> product,gene,locus_tag)."></help-tip></h5>
                                    
                                    <div class="space-y-1 mb-3">
                                        <div v-for="(rule, i) in manualPriorityRules" :key="i" class="flex items-center gap-1 bg-white p-1 rounded border border-slate-200 text-[10px]">
                                            <span class="w-16 font-bold truncate shrink-0" :title="rule.feat">{{rule.feat}}</span>
                                            <span class="flex-grow text-slate-600 truncate font-mono" :title="rule.order">{{rule.order}}</span>
                                            <button @click="manualPriorityRules.splice(i,1)" class="text-red-500 hover:text-red-700 px-1"><i class="ph ph-trash"></i></button>
                                        </div>
                                        <div v-if="manualPriorityRules.length === 0" class="text-[10px] text-slate-400 italic text-center py-2">No priority rules defined</div>
                                    </div>

                                    <div class="bg-slate-50 p-2 rounded border border-slate-200 mb-2">
                                        <div class="flex gap-1 mb-1">
                                            <select v-model="newPriorityRule.feat" class="form-input text-xs p-1 h-7 w-24 shrink-0">
                                                <option v-for="k in featureKeys" :value="k">{{ k }}</option>
                                            </select>
                                            <input v-model="newPriorityRule.order" placeholder="product,gene,locus_tag" class="form-input text-xs p-1 h-7 flex-grow">
                                            <button @click="addPriorityRule" class="btn btn-secondary text-xs h-7 px-3"><i class="ph ph-plus"></i></button>
                                        </div>
                                    </div>

                                    <div class="text-[10px] text-center text-slate-400 mb-1">- OR UPLOAD FILE -</div>
                                    <file-uploader label="Priority File (TSV)" v-model="files.qualifier_priority" :small="true"></file-uploader>
                                </div>
                            </div>
                        </div>
                    </details>
                    
                    <div class="border-t border-slate-200 my-2"></div>
                    
                    <details>
                        <summary><i class="ph ph-faders"></i> Advanced Options</summary>
                        <div class="mt-4 space-y-4 pt-4 border-t border-slate-200">
                            
                            <div class="grid grid-cols-3 gap-2">
                                <div><label class="input-label text-[10px]">Window <help-tip text="Window size for GC content/skew. Default: 1kb (<1Mb), 10kb (<10Mb), 100kb (>=10Mb)."></help-tip></label><input type="number" v-model.number="adv.window_size" class="form-input" placeholder="Auto"></div>
                                <div><label class="input-label text-[10px]">Step <help-tip text="Step size for GC content/skew. Default: 100bp (<1Mb), 1kb (<10Mb), 10kb (>=10Mb)."></help-tip></label><input type="number" v-model.number="adv.step_size" class="form-input" placeholder="Auto"></div>
                                <div><label class="input-label text-[10px]">Dinucleotide <help-tip text="Dinucleotide to use (e.g., 'GC'). Default is 'GC'."></help-tip></label><input type="text" v-model="adv.nt" class="form-input" placeholder="GC"></div>
                            </div>

                            <div>
                                <template v-if="mode === 'circular'">
                                    <label class="input-label">Definition & Text</label>
                                    <div class="grid grid-cols-2 gap-2 mb-2">
                                        <input type="text" v-model="form.species" class="form-input" placeholder="Species (e.g. <i>Escherichia coli</i>)">
                                        <input type="text" v-model="form.strain" class="form-input" placeholder="Strain (e.g. K-12)">
                                    </div>
                                </template>

                                <label v-if="mode === 'linear'" class="input-label">Label Settings</label>

                                <div class="grid grid-cols-2 gap-2">
                                    <div v-if="mode === 'circular'">
                                        <label class="text-[9px] text-slate-400">Def Font Size <help-tip text="Font size for the species/strain definition text."></help-tip></label>
                                        <input type="number" v-model.number="adv.def_font_size" class="form-input" placeholder="18">
                                    </div>
                                    
                                    <div :class="mode === 'linear' ? 'col-span-2' : ''">
                                        <label class="text-[9px] text-slate-400">Label Font Size <help-tip text="Font size for feature labels."></help-tip></label>
                                        <input type="number" v-model.number="adv.label_font_size" class="form-input" placeholder="Auto">
                                    </div>
                                </div>
                            </div>

                            <div class="grid grid-cols-2 gap-2">
                                <div><label class="input-label text-[10px]">Legend Box Size <help-tip text="Size of the color boxes in the legend."></help-tip></label><input type="number" v-model.number="adv.legend_box_size" class="form-input" placeholder="Auto"></div>
                                <div><label class="input-label text-[10px]">Legend Font Size <help-tip text="Font size for the legend text."></help-tip></label><input type="number" v-model.number="adv.legend_font_size" class="form-input" placeholder="Auto"></div>
                            </div>

                            <div>
                                <label class="input-label">Styles (Colors & Widths)</label>
                                <div class="bg-slate-50 p-2 rounded border border-slate-200 space-y-2">
                                    <div class="grid grid-cols-2 gap-2">
                                        <div><label class="text-[9px] block">Block Stroke Color <help-tip text="Color of the outline for feature blocks."></help-tip></label><input type="color" v-model="adv.block_stroke_color" class="h-6 w-full p-0 border rounded"></div>
                                        <div><label class="text-[9px] block">Block Stroke Width <help-tip text="Width of the outline for feature blocks."></help-tip></label><input type="number" v-model.number="adv.block_stroke_width" class="form-input py-0.5" placeholder="Auto"></div>
                                    </div>
                                    <div class="grid grid-cols-2 gap-2">
                                        <div><label class="text-[9px] block">Line Stroke Color <help-tip text="Color of the lines representing introns."></help-tip></label><input type="color" v-model="adv.line_stroke_color" class="h-6 w-full p-0 border rounded"></div>
                                        <div><label class="text-[9px] block">Line Stroke Width <help-tip text="Width of the lines representing introns."></help-tip></label><input type="number" v-model.number="adv.line_stroke_width" class="form-input py-0.5" placeholder="Auto"></div>
                                    </div>
                                    <div class="grid grid-cols-2 gap-2">
                                        <div><label class="text-[9px] block">Axis Stroke Color <help-tip text="Color of the main axis line."></help-tip></label><input type="color" v-model="adv.axis_stroke_color" class="h-6 w-full p-0 border rounded"></div>
                                        <div><label class="text-[9px] block">Axis Stroke Width <help-tip text="Width of the main axis line."></help-tip></label><input type="number" v-model.number="adv.axis_stroke_width" class="form-input py-0.5" placeholder="Auto"></div>
                                    </div>
                                </div>
                            </div>

                            <div v-if="mode === 'linear'">
                                <label class="input-label">Linear Specific Settings</label>
                                <div class="bg-slate-50 p-2 rounded border border-slate-200 space-y-2">
                                    <div class="grid grid-cols-3 gap-1 text-xs">
                                        <div><label class="text-[9px] block">Feature H <help-tip text="Height of the feature blocks."></help-tip></label><input type="number" v-model.number="adv.feature_height" class="form-input px-1 py-0.5"></div>
                                        <div><label class="text-[9px] block">GC H <help-tip text="Height of the GC content track."></help-tip></label><input type="number" v-model.number="adv.gc_height" class="form-input px-1 py-0.5"></div>
                                        <div><label class="text-[9px] block">Comp H <help-tip text="Height of the comparison blocks."></help-tip></label><input type="number" v-model.number="adv.comparison_height" class="form-input px-1 py-0.5"></div>
                                    </div>
                                    
                                    <div class="pt-1 border-t border-slate-200">
                                        <label class="text-[9px] font-bold block mb-1">SCALE BAR</label>
                                        <div class="grid grid-cols-3 gap-1">
                                            <input type="number" v-model.number="adv.scale_interval" placeholder="Interval" class="form-input px-1 py-0.5 text-xs" title="Manual tick interval">
                                            <input type="number" v-model.number="adv.scale_font_size" placeholder="Font" class="form-input px-1 py-0.5 text-xs" title="Scale font size">
                                            <input type="number" v-model.number="adv.scale_stroke_width" placeholder="Width" class="form-input px-1 py-0.5 text-xs" title="Scale bar width">
                                        </div>
                                        <div class="mt-1 flex items-center gap-2">
                                            <label class="text-[9px]">Color:</label>
                                            <input type="color" v-model="adv.scale_stroke_color" class="h-5 w-8 p-0 border rounded" title="Scale bar color">
                                        </div>
                                    </div>

                                    <div class="pt-1 border-t border-slate-200">
                                        <label class="text-[9px] font-bold block mb-1">BLAST FILTERS</label>
                                        <div class="grid grid-cols-3 gap-1">
                                            <input type="number" v-model.number="adv.min_bitscore" placeholder="Bitscore" class="form-input px-1 text-xs" title="Min bitscore">
                                            <input type="text" v-model="adv.evalue" placeholder="E-value" class="form-input px-1 text-xs" title="Max E-value">
                                            <input type="number" v-model.number="adv.identity" placeholder="Ident%" class="form-input px-1 text-xs" title="Min identity %">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div v-if="mode === 'circular'">
                                <label class="input-label">Circular Label Offsets <help-tip text="Adjust radius offset factors for labels."></help-tip></label>
                                <div class="bg-slate-50 p-2 rounded border border-slate-200 grid grid-cols-2 gap-2 text-xs">
                                    <div><label class="text-[9px] block">Outer X Offset</label><input type="number" step="0.1" v-model.number="adv.outer_label_x_offset" class="form-input py-0.5"></div>
                                    <div><label class="text-[9px] block">Outer Y Offset</label><input type="number" step="0.1" v-model.number="adv.outer_label_y_offset" class="form-input py-0.5"></div>
                                    <div><label class="text-[9px] block">Inner X Offset</label><input type="number" step="0.1" v-model.number="adv.inner_label_x_offset" class="form-input py-0.5"></div>
                                    <div><label class="text-[9px] block">Inner Y Offset</label><input type="number" step="0.1" v-model.number="adv.inner_label_y_offset" class="form-input py-0.5"></div>
                                    <div><label class="text-[9px] block">Scale Interval</label><input type="number" v-model.number="adv.scale_interval" class="form-input py-0.5"></div>
                                </div>
                            </div>

                            <div>
                                <label class="input-label">Include Features <help-tip text="Select which feature types to draw."></help-tip></label>
                                <div class="flex flex-wrap gap-2 mb-2 p-2 bg-slate-50 rounded border border-slate-200 min-h-[38px]">
                                    <span v-for="(f, i) in adv.features" :key="f" class="inline-flex items-center gap-1 text-[10px] bg-white text-blue-700 px-2 py-1 rounded border border-blue-200 shadow-sm">
                                        {{ f }}
                                        <button @click="adv.features.splice(i, 1)" class="text-slate-400 hover:text-red-500 flex items-center justify-center w-4 h-4 rounded-full hover:bg-red-50 transition-colors">
                                            <i class="ph ph-x"></i>
                                        </button>
                                    </span>
                                    <span v-if="adv.features.length === 0" class="text-[10px] text-slate-400 italic py-1">No features selected</span>
                                </div>
                                <div class="flex gap-2">
                                    <select v-model="newFeatureToAdd" class="form-input text-xs py-1 px-2 h-8">
                                        <option v-for="k in featureKeys" :value="k">{{ k }}</option>
                                    </select>
                                    <button @click.prevent="addFeature" class="btn btn-secondary text-xs h-8 shrink-0">
                                        <i class="ph ph-plus"></i> Add
                                    </button>
                                </div>
                            </div>
                        </div>
                    </details>
                </div>

                <div class="card bg-slate-50/50">
                    <details>
                        <summary><i class="ph ph-info"></i> About & Citation</summary>
                        <div class="mt-4 space-y-4 pt-4 border-t border-slate-200 text-xs text-slate-600">
                            
                            <div class="bg-blue-50 text-blue-800 p-2.5 rounded-lg border border-blue-100 leading-relaxed">
                                <strong class="flex items-center gap-1 mb-1"><i class="ph ph-lock-key"></i> Privacy & Security</strong>
                                This tool runs <strong>entirely in your browser</strong> using WebAssembly (Pyodide). Your genomic data is processed locally and never leaves your device.
                            </div>

                            <div>
                                <strong class="block mb-1 text-slate-700 flex items-center gap-1"><i class="ph ph-quotes"></i> Citation</strong>
                                <p class="mb-1.5 text-[11px]">If you use gbdraw in your research, please cite the GitHub repository:</p>
                                <div class="bg-white p-2 rounded border border-slate-200 font-mono text-[10px] select-all text-slate-500 break-all">
                                    https://github.com/satoshikawato/gbdraw
                                </div>
                            </div>

                            <div class="flex gap-2">
                                <a href="https://github.com/satoshikawato/gbdraw" target="_blank" rel="noopener noreferrer" class="btn btn-secondary btn-sm justify-center flex-1">
                                    <i class="ph ph-github-logo text-lg"></i> GitHub
                                </a>
                                <a href="https://github.com/satoshikawato/gbdraw/issues" target="_blank" rel="noopener noreferrer" class="btn btn-secondary btn-sm justify-center flex-1">
                                    <i class="ph ph-bug text-lg"></i> Issues
                                </a>
                            </div>
                        </div>
                    </details>
                </div>

            </div>
            
            <div class="shrink-0 py-4 bg-white/50 backdrop-blur-sm border-t border-slate-100 z-10 relative mt-auto">
            <button @click="runAnalysis" :disabled="processing || !pyodideReady" 
                class="btn w-full py-4 text-lg relative overflow-hidden group text-white bg-blue-600 hover:bg-blue-700 shadow-lg shadow-blue-200 border-b-4 border-blue-800 active:border-b-0 active:translate-y-1 active:shadow-none transition-all">
                <span v-if="!processing" class="flex items-center justify-center gap-2"><i class="ph ph-rocket-launch text-2xl"></i> Generate Diagram</span>
                <span v-else class="flex items-center justify-center gap-2"><i class="ph ph-spinner animate-spin text-xl"></i> Processing...</span>
            </button>
            </div>

        </div>

        <!-- Resize Handle -->
        <div class="w-1 bg-slate-200 hover:bg-blue-400 cursor-col-resize transition-colors shrink-0 mx-2"
             @mousedown="startResizing"
             title="Drag to resize"></div>

        <div class="flex-1 space-y-4 flex flex-col h-full overflow-hidden min-w-0">
            
            <div v-if="errorLog" class="card border-l-4 border-l-red-500 bg-red-50 mb-0 shrink-0">
                <div class="text-red-700 font-bold mb-2 flex items-center gap-2"><i class="ph ph-warning-circle"></i> Error Occurred</div>
                <pre class="text-xs font-mono text-red-800 whitespace-pre-wrap overflow-auto max-h-40 bg-white/50 p-3 rounded custom-scrollbar">{{ errorLog }}</pre>
            </div>

            <div v-if="results.length > 0" class="card border-2 border-green-100 ring-4 ring-green-50/50 flex flex-col flex-grow overflow-hidden relative">
                <div class="card-header bg-green-50/50 -m-4 mb-0 p-3 pl-5 pr-6 border-green-100 flex justify-between items-center shrink-0 flex-wrap gap-2">
                    <span class="text-green-600 flex items-center gap-2 text-base font-bold">
                        <i class="ph ph-check-circle text-xl"></i>
                        <span v-if="results.length === 1">Result Preview</span>
                        <span v-else>
                            <select v-model="selectedResultIndex" class="bg-white border border-green-300 text-green-700 text-sm font-bold rounded py-1 px-2 cursor-pointer focus:ring-2 focus:ring-green-500">
                                <option v-for="(res, idx) in results" :key="idx" :value="idx">Preview: {{ res.name }}</option>
                            </select>
                        </span>
                    </span>
                    <div class="flex gap-2 items-center flex-wrap mr-2">
                        <div class="flex items-center gap-2 bg-white px-3 py-1.5 rounded border border-green-200">
                            <span class="text-sm font-bold text-green-700">DPI</span>
                            <select v-model="downloadDpi" class="text-sm bg-transparent border-none focus:ring-0 p-0 text-slate-600 font-mono outline-none cursor-pointer">
                                <option value="72">72 (Web)</option>
                                <option value="96">96 (Screen)</option>
                                <option value="150">150 (Draft)</option>
                                <option value="300">300 (Print)</option>
                                <option value="600">600 (High)</option>
                            </select>
                        </div>
                        <button @click="downloadSVG" class="btn btn-secondary text-sm"><i class="ph ph-download-simple"></i> SVG</button>
                        <button @click="downloadPNG" class="btn btn-primary text-sm"><i class="ph ph-download-simple"></i> PNG</button>
                        <button @click="downloadPDF" class="btn btn-secondary text-sm"><i class="ph ph-file-pdf"></i> PDF</button>
                    </div>
                </div>

                <div class="relative flex-grow overflow-hidden bg-slate-50/30">

                    <!-- Zoom and Canvas controls -->
                    <div class="absolute bottom-4 right-4 flex flex-col gap-2 z-20">
                        <!-- Reset all positions button -->
                        <button v-if="svgContent" @click="resetAllPositions"
                                class="w-8 h-8 flex items-center justify-center bg-white shadow rounded-lg border border-slate-200 hover:bg-slate-100 text-slate-600"
                                title="Reset all element positions"
                                aria-label="Reset all element positions">
                            <i class="ph ph-arrow-counter-clockwise"></i>
                        </button>
                        <!-- Canvas size toggle -->
                        <button v-if="svgContent" @click="showCanvasControls = !showCanvasControls"
                                class="w-8 h-8 flex items-center justify-center bg-white shadow rounded-lg border border-slate-200 hover:bg-slate-100 text-slate-600"
                                :class="{ 'bg-blue-50 text-blue-600 border-blue-300': showCanvasControls }"
                                title="Canvas padding controls"
                                aria-label="Toggle canvas padding controls">
                            <i class="ph ph-frame-corners"></i>
                        </button>
                        <!-- Zoom controls -->
                        <div class="flex gap-1 bg-white shadow rounded-lg p-1 border border-slate-200">
                            <button @click="zoom+=0.1" class="w-8 h-8 flex items-center justify-center hover:bg-slate-100 text-slate-600 rounded" aria-label="Zoom in"><i class="ph ph-plus"></i></button>
                            <button @click="zoom = 1.0" class="w-12 h-8 flex items-center justify-center hover:bg-slate-100 text-slate-600 text-xs font-mono rounded" aria-label="Reset zoom">{{Math.round(zoom*100)}}%</button>
                            <button @click="zoom = Math.max(0.1, zoom-0.1)" class="w-8 h-8 flex items-center justify-center hover:bg-slate-100 text-slate-600 rounded" aria-label="Zoom out"><i class="ph ph-minus"></i></button>
                        </div>
                    </div>

                    <!-- Drag hint -->
                    <div v-if="svgContent" class="absolute top-4 left-4 bg-white/90 shadow rounded-lg px-4 py-2 z-20 border border-slate-200">
                        <p class="text-sm text-slate-500 flex items-center gap-2">
                            <i class="ph ph-hand-grabbing text-base"></i> Drag diagram or legend to reposition
                        </p>
                    </div>

                    <!-- Canvas padding controls panel -->
                    <div v-if="showCanvasControls && svgContent"
                         class="absolute bottom-4 right-36 bg-white shadow-lg rounded-lg p-3 z-20 border border-slate-200 w-48">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-xs font-bold text-slate-700">Canvas Padding</span>
                            <button @click="resetCanvasPadding" class="text-[10px] text-blue-600 hover:text-blue-800">Reset</button>
                        </div>
                        <div class="grid grid-cols-3 gap-1 text-center">
                            <div></div>
                            <div>
                                <label class="text-[9px] text-slate-400 block">Top</label>
                                <input type="number" v-model.number="canvasPadding.top" step="10" class="w-full text-xs border rounded px-1 py-0.5 text-center">
                            </div>
                            <div></div>
                            <div>
                                <label class="text-[9px] text-slate-400 block">Left</label>
                                <input type="number" v-model.number="canvasPadding.left" step="10" class="w-full text-xs border rounded px-1 py-0.5 text-center">
                            </div>
                            <div class="flex items-center justify-center">
                                <i class="ph ph-selection-background text-slate-300 text-lg"></i>
                            </div>
                            <div>
                                <label class="text-[9px] text-slate-400 block">Right</label>
                                <input type="number" v-model.number="canvasPadding.right" step="10" class="w-full text-xs border rounded px-1 py-0.5 text-center">
                            </div>
                            <div></div>
                            <div>
                                <label class="text-[9px] text-slate-400 block">Bottom</label>
                                <input type="number" v-model.number="canvasPadding.bottom" step="10" class="w-full text-xs border rounded px-1 py-0.5 text-center">
                            </div>
                            <div></div>
                        </div>
                        <p class="text-[9px] text-slate-400 mt-2 text-center">Add space around the diagram</p>
                    </div>

                    <div class="absolute inset-0 overflow-auto flex p-2 custom-scrollbar"
                         ref="canvasContainerRef"
                         style="cursor: grab;"
                         @wheel.prevent="handleWheel"
                         @mousedown="startPan"
                         @mousemove="doPan"
                         @mouseup="endPan"
                         @mouseleave="endPan">
                        <div v-if="svgContent" v-html="svgContent" ref="svgContainer"
                            :key="`svg-${mode}-${selectedResultIndex}-${results.length}`"
                            :style="{transform: `scale(${zoom})`, transformOrigin: 'top center', transition: 'transform 0.2s'}"
                            class="shadow-xl bg-white m-auto origin-top">
                        </div>
                    </div>

                    <!-- Feature Color Picker Popup -->
                    <div v-if="clickedFeature"
                         class="fixed z-50 bg-white rounded-xl shadow-2xl border border-slate-200 p-6 min-w-[420px]"
                         :style="{ top: clickedFeaturePos.y + 'px', left: clickedFeaturePos.x + 'px' }">
                        <div class="flex items-center gap-3 mb-5 pb-4 border-b border-slate-100">
                            <div class="w-5 h-5 rounded" :style="{ backgroundColor: clickedFeature.color }"></div>
                            <span class="text-lg font-bold text-slate-700 truncate max-w-[320px]">{{ clickedFeature.label }}</span>
                            <button @click="clickedFeature = null" class="text-slate-400 hover:text-slate-600 ml-auto text-2xl">
                                <i class="ph ph-x"></i>
                            </button>
                        </div>
                        <div class="mb-5">
                            <label class="text-sm font-medium text-slate-500 block mb-2">Legend name (optional)</label>
                            <input type="text"
                                   v-model="clickedFeature.legendName"
                                   :placeholder="clickedFeature.label"
                                   class="w-full text-base border border-slate-200 rounded-lg px-4 py-3 focus:outline-none focus:border-blue-400 focus:ring-2 focus:ring-blue-100">
                        </div>
                        <div class="mb-5">
                            <label class="text-sm font-medium text-slate-500 block mb-2">Fill Color</label>
                            <div class="flex items-center gap-4">
                                <input type="color"
                                       :value="clickedFeature.color"
                                       @input="clickedFeature.color = $event.target.value"
                                       @change="updateClickedFeatureColor($event.target.value)"
                                       class="w-16 h-12 cursor-pointer border-2 border-slate-200 rounded-lg">
                                <span class="text-base font-mono text-slate-600 bg-slate-50 px-4 py-3 rounded-lg">{{ clickedFeature.color }}</span>
                                <button @click="resetClickedFeatureFillColor"
                                        class="text-slate-400 hover:text-slate-600 p-2 rounded-lg hover:bg-slate-100"
                                        title="Reset fill color to default">
                                    <i class="ph ph-arrow-counter-clockwise text-lg"></i>
                                </button>
                            </div>
                        </div>
                        <div>
                            <label class="text-sm font-medium text-slate-500 block mb-2">Stroke</label>
                            <div class="flex items-center gap-4">
                                <input type="color"
                                       :value="clickedFeature.strokeColor || '#000000'"
                                       @input="clickedFeature.strokeColor = $event.target.value"
                                       @change="updateClickedFeatureStroke($event.target.value, null)"
                                       class="w-12 h-10 cursor-pointer border-2 border-slate-200 rounded-lg"
                                       title="Stroke color">
                                <input type="number"
                                       :value="clickedFeature.strokeWidth"
                                       @input="clickedFeature.strokeWidth = $event.target.value"
                                       @change="updateClickedFeatureStroke(null, $event.target.value)"
                                       class="w-20 text-base border border-slate-200 rounded-lg px-3 py-2"
                                       placeholder="Width"
                                       step="0.1"
                                       min="0"
                                       title="Stroke width">
                                <button @click="resetClickedFeatureStroke"
                                        class="text-slate-400 hover:text-slate-600 p-2 rounded-lg hover:bg-slate-100"
                                        title="Reset stroke to default">
                                    <i class="ph ph-arrow-counter-clockwise text-lg"></i>
                                </button>
                                <button @click="applyStrokeToAllSiblings"
                                        class="text-slate-400 hover:text-blue-600 p-2 rounded-lg hover:bg-blue-50"
                                        title="Apply this stroke to all features with the same legend">
                                    <i class="ph ph-users-three text-lg"></i>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Color Change Scope Dialog -->
                    <div v-if="colorScopeDialog.show"
                         class="fixed inset-0 bg-black/50 z-[60] flex items-center justify-center">
                        <div class="bg-white rounded-xl shadow-2xl p-6 max-w-md mx-4">
                            <h3 class="text-lg font-bold text-slate-800 mb-2">Color Change Scope</h3>
                            <p class="text-sm text-slate-600 mb-4">
                                <template v-if="colorScopeDialog.matchingRule">
                                    This feature matches the rule "<span class="font-bold text-blue-600">{{ colorScopeDialog.matchingRule?.cap || colorScopeDialog.matchingRule?.val }}</span>" ({{ colorScopeDialog.ruleMatchCount }} features).
                                    <template v-if="colorScopeDialog.siblingCount > 0">
                                        <br>Caption "<span class="font-bold text-green-600">{{ colorScopeDialog.legendName }}</span>" is shared by {{ colorScopeDialog.siblingCount + 1 }} features.
                                    </template>
                                </template>
                                <template v-else-if="colorScopeDialog.siblingCount > 0">
                                    There are <span class="font-bold text-blue-600">{{ colorScopeDialog.siblingCount }}</span> other features with the caption "<span class="font-bold text-blue-600">{{ colorScopeDialog.legendName }}</span>".
                                </template>
                                <template v-else>
                                    How do you want to apply the color change?
                                </template>
                            </p>

                            <div class="flex flex-col gap-2">
                                <!-- Apply to all features matching the rule (when rule exists) -->
                                <button v-if="colorScopeDialog.matchingRule"
                                        @click="handleColorScopeChoice('rule')"
                                        class="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg transition-colors text-left flex items-center gap-2">
                                    <i class="ph ph-users text-lg"></i>
                                    <span>Apply to all "{{ colorScopeDialog.matchingRule?.cap || colorScopeDialog.matchingRule?.val }}" ({{ colorScopeDialog.ruleMatchCount }})</span>
                                </button>

                                <!-- Apply to all features with same caption (when siblings exist) -->
                                <button v-if="colorScopeDialog.siblingCount > 0"
                                        @click="handleColorScopeChoice('caption')"
                                        class="w-full px-4 py-2 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg transition-colors text-left flex items-center gap-2">
                                    <i class="ph ph-users-three text-lg"></i>
                                    <span>Apply to all "{{ colorScopeDialog.legendName }}" ({{ colorScopeDialog.siblingCount + 1 }})</span>
                                </button>

                                <!-- Apply to this feature only -->
                                <button @click="handleColorScopeChoice('single')"
                                        class="w-full px-4 py-2 bg-slate-100 hover:bg-slate-200 text-slate-700 font-bold rounded-lg transition-colors text-left flex items-center gap-2">
                                    <i class="ph ph-user text-lg"></i>
                                    <span>This feature only</span>
                                </button>

                                <!-- Use existing caption color (if available) -->
                                <button v-if="colorScopeDialog.existingCaptionColor"
                                        @click="handleColorScopeChoice('useExisting')"
                                        class="w-full px-4 py-2 bg-purple-100 hover:bg-purple-200 text-purple-800 font-bold rounded-lg transition-colors text-left flex items-center gap-2">
                                    <span class="w-5 h-5 rounded border border-purple-300 shrink-0"
                                          :style="{ backgroundColor: colorScopeDialog.existingCaptionColor }"></span>
                                    <span>Use existing "{{ colorScopeDialog.legendName }}" color</span>
                                </button>
                            </div>

                            <button @click="handleColorScopeChoice('cancel')"
                                    class="w-full mt-3 px-4 py-2 text-slate-500 hover:text-slate-700 text-sm font-medium">
                                Cancel
                            </button>
                        </div>
                    </div>

                    <!-- Reset Color Dialog -->
                    <div v-if="resetColorDialog.show"
                         class="fixed inset-0 bg-black/50 z-[60] flex items-center justify-center">
                        <div class="bg-white rounded-xl shadow-2xl p-6 max-w-md mx-4">
                            <h3 class="text-lg font-bold text-slate-800 mb-2">Reset Fill Color</h3>
                            <p class="text-sm text-slate-600 mb-4">
                                There are <span class="font-bold text-blue-600">{{ resetColorDialog.siblingCount }}</span> other features with the caption "<span class="font-bold text-blue-600">{{ resetColorDialog.caption }}</span>".
                                <br>How do you want to reset the color?
                            </p>

                            <div class="flex flex-col gap-2">
                                <!-- Reset all features with same caption -->
                                <button @click="handleResetColorChoice('all')"
                                        class="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg transition-colors text-left flex items-center gap-2">
                                    <i class="ph ph-users text-lg"></i>
                                    <span>Reset all "{{ resetColorDialog.caption }}" ({{ resetColorDialog.siblingCount + 1 }})</span>
                                </button>

                                <!-- Reset this feature only with new legend entry -->
                                <button @click="handleResetColorChoice('this_with_legend')"
                                        class="w-full px-4 py-2 bg-purple-100 hover:bg-purple-200 text-purple-800 font-bold rounded-lg transition-colors text-left flex items-center gap-2">
                                    <i class="ph ph-user-plus text-lg"></i>
                                    <span>This only + add legend entry</span>
                                </button>

                                <!-- Reset this feature only -->
                                <button @click="handleResetColorChoice('this')"
                                        class="w-full px-4 py-2 bg-slate-100 hover:bg-slate-200 text-slate-700 font-bold rounded-lg transition-colors text-left flex items-center gap-2">
                                    <i class="ph ph-user text-lg"></i>
                                    <span>This feature only</span>
                                </button>
                            </div>

                            <button @click="resetColorDialog.show = false"
                                    class="w-full mt-3 px-4 py-2 text-slate-500 hover:text-slate-700 text-sm font-medium">
                                Cancel
                            </button>
                        </div>
                    </div>

                </div>

                <!-- Legend Editor Toggle Button -->
                <button v-if="svgContent"
                        @click="showLegendPanel = !showLegendPanel"
                        class="absolute top-1/3 -translate-y-1/2 bg-purple-600 hover:bg-purple-700 text-white px-2 py-4 rounded-l-lg shadow-lg z-20 transition-all"
                        :style="{ right: (showFeaturePanel ? 320 : 0) + (showLegendPanel ? 288 : 0) + 'px' }"
                        :title="showLegendPanel ? 'Close legend editor' : 'Edit legend'">
                    <i class="ph ph-list-bullets text-lg"></i>
                </button>

                <!-- Legend Editor Panel -->
                <div v-if="svgContent"
                     class="absolute top-0 bottom-0 w-72 bg-white border-l border-slate-200 shadow-xl z-10 transition-all duration-300 flex flex-col"
                     :style="{ right: showLegendPanel ? (showFeaturePanel ? '320px' : '0') : '-288px' }">
                    <div class="px-4 py-3 border-b border-slate-200 flex items-center justify-between shrink-0 bg-purple-50">
                        <div class="flex items-center gap-2">
                            <i class="ph ph-list-bullets text-purple-600"></i>
                            <span class="font-bold text-slate-700">Legend Editor</span>
                        </div>
                        <button @click="showLegendPanel = false" class="text-slate-400 hover:text-slate-600" aria-label="Close legend editor">
                            <i class="ph ph-x text-lg"></i>
                        </button>
                    </div>

                    <!-- Legend position controls -->
                    <div class="px-3 py-2 border-b border-slate-100 bg-slate-50/50">
                        <div class="flex items-center justify-between">
                            <span class="text-[10px] text-slate-500 flex items-center gap-1">
                                <i class="ph ph-hand-grabbing"></i> Drag legend to reposition
                            </span>
                            <div class="flex items-center gap-1">
                                <!-- Sort buttons -->
                                <button @click="sortLegendEntries('asc')"
                                        class="text-[10px] text-slate-500 hover:text-slate-700 p-1 rounded hover:bg-slate-100 transition-colors"
                                        title="Sort A-Z">
                                    <i class="ph ph-sort-ascending"></i>
                                </button>
                                <button @click="sortLegendEntries('desc')"
                                        class="text-[10px] text-slate-500 hover:text-slate-700 p-1 rounded hover:bg-slate-100 transition-colors"
                                        title="Sort Z-A">
                                    <i class="ph ph-sort-descending"></i>
                                </button>
                                <button @click="sortLegendEntriesByDefault"
                                        class="text-[10px] text-slate-500 hover:text-slate-700 p-1 rounded hover:bg-slate-100 transition-colors"
                                        title="Sort by default (generation order)">
                                    <i class="ph ph-list-numbers"></i>
                                </button>
                                <span class="text-slate-300">|</span>
                                <button @click="resetLegendPosition"
                                        class="text-[10px] text-blue-600 hover:text-blue-800 flex items-center gap-1 px-2 py-1 rounded hover:bg-blue-50 transition-colors"
                                        title="Reset legend position and restore deleted entries">
                                    <i class="ph ph-arrow-counter-clockwise"></i> Reset
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="flex-1 overflow-y-auto p-3 space-y-2">
                        <div v-for="(entry, idx) in legendEntries" :key="idx"
                             class="p-2 bg-slate-50 rounded border border-slate-100">
                            <!-- Main row: Up/Down, Color, Caption, Delete -->
                            <div class="flex items-center gap-1">
                                <!-- Up/Down buttons -->
                                <div class="flex flex-col shrink-0">
                                    <button @click="moveLegendEntryUp(idx)"
                                            :disabled="idx === 0"
                                            class="text-slate-400 hover:text-slate-600 disabled:text-slate-200 disabled:cursor-not-allowed p-0 leading-none"
                                            title="Move up">
                                        <i class="ph ph-caret-up text-xs"></i>
                                    </button>
                                    <button @click="moveLegendEntryDown(idx)"
                                            :disabled="idx === legendEntries.length - 1"
                                            class="text-slate-400 hover:text-slate-600 disabled:text-slate-200 disabled:cursor-not-allowed p-0 leading-none"
                                            title="Move down">
                                        <i class="ph ph-caret-down text-xs"></i>
                                    </button>
                                </div>
                                <!-- Color display (read-only) -->
                                <div class="w-6 h-6 rounded border border-slate-300 shrink-0"
                                     :style="{ backgroundColor: entry.color }"
                                     :title="entry.color"></div>
                                <input type="text"
                                       :value="entry.caption"
                                       @change="updateLegendEntryCaption(idx, $event.target.value)"
                                       class="flex-1 text-xs border border-slate-200 rounded px-2 py-1 min-w-0">
                                <!-- Expand/Collapse stroke options -->
                                <button @click="entry.showStroke = !entry.showStroke"
                                        class="text-slate-400 hover:text-slate-600 shrink-0 p-0.5"
                                        :title="entry.showStroke ? 'Hide stroke options' : 'Show stroke options'">
                                    <i class="ph text-xs" :class="entry.showStroke ? 'ph-caret-up' : 'ph-sliders-horizontal'"></i>
                                </button>
                                <button @click="deleteLegendEntry(idx)"
                                        class="text-red-400 hover:text-red-600 shrink-0"
                                        title="Remove entry">
                                    <i class="ph ph-trash text-sm"></i>
                                </button>
                            </div>
                            <!-- Stroke options row (collapsible) -->
                            <div v-if="entry.showStroke" class="mt-2 pt-2 border-t border-slate-200 flex items-center gap-2 text-[10px]">
                                <span class="text-slate-500 shrink-0">Stroke:</span>
                                <input type="color"
                                       :value="getLegendEntryStrokeColor(idx)"
                                       @change="updateLegendEntryStrokeColor(idx, $event.target.value)"
                                       class="w-6 h-5 p-0 border rounded shrink-0 cursor-pointer"
                                       title="Stroke color">
                                <input type="number"
                                       :value="getLegendEntryStrokeWidth(idx)"
                                       @change="updateLegendEntryStrokeWidth(idx, $event.target.value)"
                                       class="w-14 text-[10px] border border-slate-200 rounded px-1 py-0.5"
                                       placeholder="Width"
                                       step="0.5"
                                       min="0"
                                       title="Stroke width (Enter to apply)">
                                <button @click="resetLegendEntryStroke(idx)"
                                        class="text-slate-400 hover:text-slate-600 shrink-0"
                                        title="Reset stroke to default">
                                    <i class="ph ph-arrow-counter-clockwise text-xs"></i>
                                </button>
                            </div>
                        </div>
                        <div v-if="legendEntries.length === 0" class="text-center text-slate-400 text-sm py-4">
                            No legend entries found
                        </div>
                    </div>

                    <!-- Reset All Strokes button -->
                    <div class="px-3 py-2 border-t border-slate-200">
                        <button @click="resetAllStrokes"
                                class="w-full text-xs px-3 py-1.5 bg-slate-100 hover:bg-slate-200 text-slate-600 rounded flex items-center justify-center gap-1 transition-colors"
                                title="Reset all stroke colors and widths to default">
                            <i class="ph ph-arrow-counter-clockwise"></i>
                            Reset All Strokes
                        </button>
                    </div>

                    <!-- Info message -->
                    <div class="p-3 border-t border-slate-200 bg-slate-50 text-xs text-slate-500">
                        <i class="ph ph-info"></i> Colors are managed via Feature Colors panel
                    </div>
                </div>

                <!-- Feature Color Editor Toggle Button (floating) -->
                <button v-if="extractedFeatures.length > 0"
                        @click="showFeaturePanel = !showFeaturePanel"
                        class="absolute right-0 top-1/2 -translate-y-1/2 bg-blue-600 hover:bg-blue-700 text-white px-2 py-4 rounded-l-lg shadow-lg z-20 transition-all"
                        :class="{ 'translate-x-0': !showFeaturePanel, '-translate-x-80': showFeaturePanel }"
                        :title="showFeaturePanel ? 'Close color panel' : 'Open color panel'">
                    <i class="ph ph-paint-brush text-lg"></i>
                </button>

                <!-- Feature Color Editor Drawer (slides from right) -->
                <div v-if="extractedFeatures.length > 0"
                     class="absolute right-0 top-0 bottom-0 w-80 bg-white border-l border-slate-200 shadow-xl z-10 transition-transform duration-300 flex flex-col"
                     :class="showFeaturePanel ? 'translate-x-0' : 'translate-x-full'">
                    <!-- Header -->
                    <div class="px-4 py-3 border-b border-slate-200 flex items-center justify-between shrink-0 bg-slate-50">
                        <div class="flex items-center gap-2">
                            <i class="ph ph-paint-brush text-blue-600"></i>
                            <span class="font-bold text-slate-700">Feature Colors</span>
                            <span class="text-xs text-slate-400">({{ filteredFeatures.length }})</span>
                        </div>
                        <button @click="showFeaturePanel = false" class="text-slate-400 hover:text-slate-600" aria-label="Close feature color editor">
                            <i class="ph ph-x text-lg"></i>
                        </button>
                    </div>

                    <!-- Record Selector (for multi-record files) -->
                    <div v-if="featureRecordIds.length > 1" class="px-4 py-2 border-b border-slate-100 shrink-0">
                        <select v-model="selectedFeatureRecordIdx" class="form-select text-xs w-full">
                            <option v-for="(rid, idx) in featureRecordIds" :key="idx" :value="idx">
                                {{ rid }}
                            </option>
                        </select>
                    </div>

                    <!-- Search -->
                    <div class="px-4 py-2 border-b border-slate-100 shrink-0">
                        <input v-model="featureSearch" placeholder="Search by product, gene, locus_tag..."
                               class="form-input text-xs w-full">
                    </div>

                    <!-- Feature List -->
                    <div class="flex-grow overflow-y-auto">
                        <div v-for="feat in filteredFeatures" :key="feat.id"
                             @click="$event.currentTarget.querySelector('input[type=color]')?.click()"
                             class="flex items-center gap-2 px-3 py-2 border-b border-slate-100 text-xs hover:bg-blue-50 cursor-pointer transition-colors">
                            <span class="w-10 font-mono text-slate-400 shrink-0 text-[10px]">{{ feat.type }}</span>
                            <span class="w-16 font-mono text-slate-500 shrink-0 truncate text-[10px]" :title="`${feat.start}..${feat.end}`">
                                {{ feat.start }}..{{ feat.end }}
                            </span>
                            <span class="flex-grow truncate text-slate-700"
                                  :title="feat.product || feat.gene || feat.locus_tag || feat.note || '(unnamed)'">
                                {{ feat.product || feat.gene || feat.locus_tag || feat.note || '(unnamed)' }}
                            </span>
                            <input type="color"
                                   :value="getFeatureColor(feat)"
                                   @click.stop
                                   @change="setFeatureColor(feat, $event.target.value)"
                                   :disabled="!canEditFeatureColor(feat)"
                                   :title="canEditFeatureColor(feat) ? 'Click to change color' : 'No identifier available (no locus_tag, gene, or product)'"
                                   :class="['w-7 h-5 border rounded shrink-0', canEditFeatureColor(feat) ? 'cursor-pointer' : 'cursor-not-allowed opacity-50']">
                        </div>
                        <div v-if="filteredFeatures.length === 0" class="p-4 text-center text-slate-400 text-xs">
                            No features found
                        </div>
                    </div>

                    <!-- Footer -->
                    <div class="px-4 py-2 border-t border-slate-200 shrink-0 bg-slate-50">
                        <p class="text-[10px] text-slate-400">
                            <i class="ph ph-info"></i> Click a feature or the diagram to change colors.
                        </p>
                    </div>
                </div>
            </div>

            <div v-else class="h-full flex flex-col items-center justify-center text-slate-300 border-4 border-dashed border-slate-200 rounded-3xl p-12 bg-slate-50/30">
                <i class="ph ph-dna text-6xl mb-4 text-slate-200"></i>
                <p class="font-medium text-slate-400">Configure settings and click Generate</p>
            </div>
        </div>
    </main>

    <footer class="bg-slate-50 border-t border-slate-200 px-4 py-2 text-sm text-slate-500 flex items-center justify-center gap-6 shrink-0 h-8">
        <span>
            <strong>Disclaimer:</strong> This tool is provided "as is" without warranty of any kind.
        </span>
        <span>
            License: <a href="https://github.com/satoshikawato/gbdraw/blob/main/LICENSE.txt" target="_blank" rel="noopener noreferrer" class="hover:underline hover:text-slate-700">MIT</a> |
            Author: <a href="https://researchmap.jp/satoshi_kawato?lang=en" target="_blank" rel="noopener noreferrer" class="hover:underline hover:text-slate-700">Satoshi Kawato</a>
        </span>
    </footer>
</div>

<script type="text/x-template" id="help-tip-template">
    <div class="inline-block ml-1 align-text-bottom">
        <i class="ph ph-question text-slate-400 hover:text-blue-500 cursor-help"
           @mouseenter="show" @mouseleave="hide" ref="trigger"></i>
        <Teleport to="body">
            <div v-if="visible" :style="style" class="fixed z-[9999] px-3 py-2 bg-slate-800 text-white text-xs rounded-md shadow-lg max-w-[250px] pointer-events-none transition-opacity text-left leading-relaxed">
                 {{ text }}
            </div>
        </Teleport>
    </div>
</script>

<script type="text/x-template" id="file-uploader-template">
    <div class="w-full">
        <div class="flex justify-between items-end mb-1">
            <label class="input-label mb-0">{{ label }}</label>
            <button v-if="modelValue" @click.stop="clearFile" class="text-[10px] text-red-500 hover:text-red-700 flex items-center gap-1"><i class="ph ph-trash"></i> Remove</button>
        </div>
        <div class="upload-zone cursor-pointer" :class="{'ready': modelValue, 'py-1 min-h-[36px]': small}" @click="$refs.input.click()">
            <input type="file" ref="input" @change="handleFile" :accept="accept" class="hidden">
            <div v-if="!modelValue" class="flex items-center justify-center gap-2 text-slate-400 group-hover:text-blue-600 transition-colors">
                <i class="ph ph-upload-simple" :class="small ? 'text-base' : 'text-xl'"></i>
                <span :class="small ? 'text-[10px]' : 'text-xs font-bold'">Click to Browse</span>
            </div>
            <div v-else class="text-green-700 font-bold truncate w-full px-2 flex items-center justify-center gap-2" :class="small ? 'text-[10px]' : 'text-xs'">
                <i class="ph ph-check-circle text-lg"></i>
                <span>{{ modelValue.name }}</span>
            </div>
        </div>
    </div>
</script>

<script>
    const { createApp, ref, reactive, onMounted, onUnmounted, computed, watch } = Vue;
    const GBDRAW_WHEEL_NAME = "gbdraw-0.8.3-py3-none-any.whl";

    // Debug logging - set to true to enable verbose debug output
    const DEBUG = false;
    const debugLog = (...args) => { if (DEBUG) console.log('[DEBUG]', ...args); };

    // HelpTip & FileUploader Components
    const HelpTip = {
        template: '#help-tip-template',
        props: ['text'],
        setup(props) {
            const visible = ref(false);
            const style = reactive({ top: '0px', left: '0px' });
            const trigger = ref(null);
            const show = () => {
                if (!trigger.value) return;
                const rect = trigger.value.getBoundingClientRect();
                
                // Get viewport width and tooltip max width
                const viewportWidth = window.innerWidth;
                const tooltipMaxWidth = 260; // max-w-250px + extra margin
                const halfWidth = tooltipMaxWidth / 2;
                const gap = 12; // gap between icon and tooltip

                // Centered on the icon
                let left = rect.left + rect.width / 2;
                let top = rect.top - gap;
                let transform = 'translate(-50%, -100%)'; // above the icon

                // Prevent overflow on left/right (keep at least 10px from viewport edges)
                if (left < halfWidth + 10) {
                    left = halfWidth + 10;
                } else if (left > viewportWidth - halfWidth - 10) {
                    left = viewportWidth - halfWidth - 10;
                }

                // Prevent overflow at the top (if too close to top edge, show below)
                // Considering header and browser frame, if y < 60px, show below
                if (rect.top < 60) {
                    top = rect.bottom + gap;
                    transform = 'translate(-50%, 0)'; // transform for below display
                }

                style.top = top + 'px';
                style.left = left + 'px';
                style.transform = transform;
                
                visible.value = true;
            };
            const hide = () => visible.value = false;
            return { visible, style, trigger, show, hide };
        }
    };

    const FileUploader = {
        template: '#file-uploader-template',
        props: ['label', 'accept', 'modelValue', 'small'],
        emits: ['update:modelValue'],
        setup(props, { emit }) {
            const input = ref(null);
            const handleFile = (e) => {
                if(e.target.files[0]) emit('update:modelValue', e.target.files[0]);
                e.target.value = ''; 
            };
            const clearFile = () => emit('update:modelValue', null);
            return { input, handleFile, clearFile };
        }
    };

    // DPI Helper
    const setDpiInPng = async (blob, dpi) => {
        const pixelsPerMeter = Math.round(dpi / 0.0254);
        const buffer = await blob.arrayBuffer();
        const view = new DataView(buffer);
        const uint8 = new Uint8Array(buffer);
        let offset = 8; let physChunk = null; let idatOffset = null;
        while (offset < view.byteLength) {
            const length = view.getUint32(offset);
            const type = String.fromCharCode(uint8[offset+4], uint8[offset+5], uint8[offset+6], uint8[offset+7]);
            if (type === 'pHYs') { physChunk = offset; break; }
            if (type === 'IDAT') { idatOffset = offset; break; }
            offset += 12 + length;
        }
        const ppm = pixelsPerMeter;
        const physData = new Uint8Array(9);
        const dv = new DataView(physData.buffer);
        dv.setUint32(0, ppm); dv.setUint32(4, ppm); physData[8] = 1;
        const crcTable = []; for (let n = 0; n < 256; n++) { let c = n; for (let k = 0; k < 8; k++) c = (c & 1) ? 0xedb88320 ^ (c >>> 1) : c >>> 1; crcTable[n] = c; }
        const crc32 = (buf) => { let crc = 0 ^ (-1); for (let i = 0; i < buf.length; i++) crc = (crc >>> 8) ^ crcTable[(crc ^ buf[i]) & 0xff]; return (crc ^ (-1)) >>> 0; };
        const newChunk = new Uint8Array(21);
        const newDv = new DataView(newChunk.buffer);
        newDv.setUint32(0, 9); newChunk.set([112, 72, 89, 115], 4); newChunk.set(physData, 8);
        const crcInput = new Uint8Array(13); crcInput.set([112, 72, 89, 115], 0); crcInput.set(physData, 4);
        newDv.setUint32(17, crc32(crcInput));
        if (physChunk !== null) {
             const newBuffer = new Uint8Array(buffer.byteLength); newBuffer.set(uint8.slice(0, physChunk), 0); newBuffer.set(newChunk, physChunk); const oldLen = view.getUint32(physChunk); newBuffer.set(uint8.slice(physChunk + 12 + oldLen), physChunk + 21); return new Blob([newBuffer], { type: 'image/png' });
        } else {
            const newBuffer = new Uint8Array(buffer.byteLength + 21); newBuffer.set(uint8.slice(0, idatOffset), 0); newBuffer.set(newChunk, idatOffset); newBuffer.set(uint8.slice(idatOffset), idatOffset + 21); return new Blob([newBuffer], { type: 'image/png' });
        }
    };

    createApp({
        components: { FileUploader, HelpTip },
        setup() {
            // System State
            const pyodideReady = ref(false);
            const processing = ref(false);
            const loadingStatus = ref("Initializing...");
            const errorLog = ref(null);
            
            const results = ref([]);
            const selectedResultIndex = ref(0);
            // Store original pairwise match factors for re-interpolation
            const pairwiseMatchFactors = ref({});  // { pathId: factor }
            const svgContent = computed(() => {
                if (results.value.length > 0) {
                    const rawSvg = results.value[selectedResultIndex.value].content;
                    
                    // Sanitize the SVG output from svgwrite to ensure safety and prevent DOMXSS
                    return DOMPurify.sanitize(rawSvg, {
                        USE_PROFILES: { svg: true },
                        // Only allow main tags used by svgwrite
                        ADD_TAGS: ['use', 'g', 'defs', 'linearGradient', 'radialGradient', 'stop', 'path', 'rect', 'circle', 'line', 'polyline', 'polygon', 'text', 'tspan'],
                        // Allowed attributes list (event handlers are automatically excluded, but can be explicitly forbidden as well)
                        ADD_ATTR: [
                            'xlink:href', 'href', 'id', 'class', 'data-legend-key',
                            'fill', 'fill-opacity', 'stroke', 'stroke-width', 'stroke-opacity', 'stroke-dasharray', 'stroke-linecap', 'stroke-linejoin',
                            'd', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry',
                            'width', 'height', 'transform', 'viewBox', 'preserveAspectRatio',
                            'font-family', 'font-size', 'font-weight', 'text-anchor', 'dominant-baseline', 'writing-mode', 'letter-spacing'
                        ],
                        // Forbid <style> tags (to prevent breaking parent page CSS). Also forbid script-related tags.
                        FORBID_TAGS: ['style', 'script', 'foreignObject', 'iframe', 'embed', 'object', 'animate', 'set', 'animateTransform', 'image'],
                        FORBID_ATTR: ['name', 'onload', 'onclick', 'onmouseover', 'onfocus', 'onerror']
                    });
                }
                return null;
            });

            const zoom = ref(1.0);

            // Scroll wheel zoom handler
            const handleWheel = (event) => {
                const delta = event.deltaY > 0 ? -0.1 : 0.1;
                const newZoom = Math.max(0.1, Math.min(5, zoom.value + delta));
                zoom.value = Math.round(newZoom * 10) / 10; // Round to 1 decimal place
            };

            // Pan (drag) functionality
            const isPanning = ref(false);
            const panStart = reactive({ x: 0, y: 0, scrollLeft: 0, scrollTop: 0 });
            const canvasContainerRef = ref(null);

            const startPan = (event) => {
                // Only pan with left mouse button and not on interactive elements
                if (event.button !== 0) return;
                const container = canvasContainerRef.value;
                if (!container) return;

                // Don't start pan if clicking on SVG elements that have their own drag handlers
                const target = event.target;
                const closestGroup = target.closest?.('g[id]');
                if (closestGroup) {
                    const groupId = closestGroup.id;
                    // Skip pan if clicking on legend, diagram elements, or feature paths
                    if (groupId === 'legend' || groupId === 'feature_legend' || groupId === 'pairwise_legend' ||
                        groupId === 'horizontal_legend' || groupId === 'vertical_legend' ||
                        groupId.startsWith('comparison') || groupId.startsWith('f') ||
                        target.closest('svg')) {
                        // Let the SVG's own drag handlers take care of it
                        return;
                    }
                }
                // Also skip if clicking directly on a path inside SVG (feature or legend element)
                if (target.tagName === 'path' && target.closest('svg')) {
                    return;
                }

                isPanning.value = true;
                panStart.x = event.clientX;
                panStart.y = event.clientY;
                panStart.scrollLeft = container.scrollLeft;
                panStart.scrollTop = container.scrollTop;
                container.style.cursor = 'grabbing';
            };

            const doPan = (event) => {
                if (!isPanning.value) return;
                const container = canvasContainerRef.value;
                if (!container) return;

                const dx = event.clientX - panStart.x;
                const dy = event.clientY - panStart.y;
                container.scrollLeft = panStart.scrollLeft - dx;
                container.scrollTop = panStart.scrollTop - dy;
            };

            const endPan = () => {
                isPanning.value = false;
                const container = canvasContainerRef.value;
                if (container) {
                    container.style.cursor = 'grab';
                }
            };

            let pyodide = null;

            // App State
            const mode = ref('circular');
            const circularLegendPosition = ref('right');  // Separate legend position for circular mode
            const linearLegendPosition = ref('right');    // Separate legend position for linear mode
            const cInputType = ref('gb');
            const lInputType = ref('gb');
            const files = reactive({ 
                c_gb: null, c_gff: null, c_fasta: null, 
                d_color: null, t_color: null, 
                blacklist: null, whitelist: null, qualifier_priority: null 
            });
            const linearSeqs = reactive([{ gb: null, gff: null, fasta: null, blast: null }]);
            
            // Configuration Forms
            const form = reactive({ 
                prefix: '', species: '', strain: '', 
                track_type: 'tuckin', legend: 'right', scale_style: 'bar', 
                show_labels: false, show_labels_linear: "none",
                separate_strands: true, 
                allow_inner_labels: false, suppress_gc: false, suppress_skew: false, 
                align_center: false, show_gc: false, show_skew: false, normalize_length: false 
            });

            // Extended Advanced Config
            const adv = reactive({
                features: ["CDS","rRNA","tRNA","tmRNA","ncRNA","repeat_region"],
                window_size: null, step_size: null, nt: "GC",
                def_font_size: 18, label_font_size: null,
                
                // Styles
                block_stroke_width: null, block_stroke_color: null,
                line_stroke_width: null, line_stroke_color: null,
                axis_stroke_width: null, axis_stroke_color: null,
                
                // Legend
                legend_box_size: null, legend_font_size: null,

                // Linear Specific
                resolve_overlaps: false,
                feature_height: null, gc_height: null, comparison_height: null,
                min_bitscore: 50, evalue: "1e-2", identity: 0,
                scale_interval: null, scale_font_size: null, scale_stroke_width: null, scale_stroke_color: null,

                // Circular Specific
                outer_label_x_offset: null, outer_label_y_offset: null,
                inner_label_x_offset: null, inner_label_y_offset: null
            });

            // Color & Filter State
            const paletteNames = ref(["default"]);
            const selectedPalette = ref("default");
            const currentColors = ref({});
            const filterMode = ref("None");
            const manualBlacklist = ref("hypothetical, uncharacterized, putative, unknown");
            const manualWhitelist = reactive([]); 
            const manualSpecificRules = reactive([]);
            const newSpecRule = reactive({ feat: "CDS", qual: "product", val: "", color: "#ff0000", cap: "" });
            const downloadDpi = ref(300);

            // Feature Color Editor state
            const extractedFeatures = ref([]);  // Features from last generation
            const featureRecordIds = ref([]);  // Record IDs for multi-record files
            const selectedFeatureRecordIdx = ref(0);  // Currently selected record index
            const showFeaturePanel = ref(false);
            const featureSearch = ref('');
            const featureColorOverrides = reactive({});  // {featureKey: color}
            // SVG Feature Click state
            const svgContainer = ref(null);
            const clickedFeature = ref(null);  // {id, svg_id, label, color, feat}
            const clickedFeaturePos = reactive({ x: 0, y: 0 });

            // Color Change Scope Dialog state
            const colorScopeDialog = reactive({
                show: false,
                feat: null,
                color: null,
                matchingRule: null,  // Existing regex rule from -t table
                legendName: null,
                siblingCount: 0,  // Number of other features with same caption
                existingCaptionRule: null,  // Existing hash rule for same caption (already colored)
                existingCaptionColor: null,  // Color of existing caption rule
                resolve: null  // Promise resolver
            });

            // Sidebar resize state
            const sidebarWidth = ref(320);  // Initial width in pixels
            const isResizing = ref(false);
            const startResizing = (event) => {
                isResizing.value = true;
                document.addEventListener('mousemove', doResize);
                document.addEventListener('mouseup', stopResizing);
            };
            const doResize = (event) => {
                if (!isResizing.value) return;
                const newWidth = event.clientX - 16; // 16 = padding
                sidebarWidth.value = Math.max(240, Math.min(500, newWidth));
            };
            const stopResizing = () => {
                isResizing.value = false;
                document.removeEventListener('mousemove', doResize);
                document.removeEventListener('mouseup', stopResizing);
            };

            // Legend Editor state
            const showLegendPanel = ref(false);
            const legendEntries = ref([]);  // [{caption, originalCaption, color, yPos, showStroke, featureIds}]
            const deletedLegendEntries = ref([]);  // Track deleted entries for restoration
            const originalLegendOrder = ref([]);  // Store original order from generation
            const originalLegendColors = ref({});  // Store original colors: { caption: color }
            const newLegendCaption = ref('');
            const newLegendColor = ref('#808080');

            // Legend stroke overrides: { caption: { strokeColor, strokeWidth, originalStrokeColor, originalStrokeWidth } }
            const legendStrokeOverrides = reactive({});

            // Legend color overrides: { caption: color } - tracks custom colors set via Legend Editor
            const legendColorOverrides = reactive({});

            // Original stroke values from SVG generation (gbdraw's auto-determined defaults)
            const originalSvgStroke = ref({ color: null, width: null });

            // Legend Drag state
            const legendDragging = ref(false);
            const legendDragStart = reactive({ x: 0, y: 0 });
            const legendOriginalTransform = ref({ x: 0, y: 0 });
            const legendInitialTransform = ref({ x: 0, y: 0 });  // Store SVG's original legend position
            const legendCurrentOffset = reactive({ x: 0, y: 0 });

            // Main Diagram Drag state (tick, labels, axis, definition, records as one group)
            const diagramDragging = ref(false);
            const diagramDragStart = reactive({ x: 0, y: 0 });
            const diagramOffset = reactive({ x: 0, y: 0 });  // Cumulative drag offset
            const diagramElementIds = ref([]);  // IDs of elements that move together
            const diagramElementOriginalTransforms = ref(new Map());  // Store original transforms for each element

            // Canvas size state
            const canvasPadding = reactive({ top: 0, right: 0, bottom: 0, left: 0 });
            const showCanvasControls = ref(false);

            // Track legend position at generation time (for repositioning without regeneration)
            const generatedLegendPosition = ref('right');

            // Flag to skip captureBaseConfig when editing SVG (repositioning legend, adding legend entries, etc.)
            // This prevents base config from being overwritten during incremental edits
            const skipCaptureBaseConfig = ref(false);

            // Flag to skip position reapply after repositionForLegendChange is called
            // This prevents infinite loop when repositionForLegendChange triggers watch(svgContent)
            const skipPositionReapply = ref(false);

            // Flag to skip extractLegendEntries in watch(svgContent) when setFeatureColor is handling it
            // This prevents race condition where watcher overwrites correct legend state
            const skipExtractOnSvgChange = ref(false);

            // Base configuration for circular mode (stored when SVG is generated)
            // Used to calculate absolute positions without accumulation
            const circularBaseConfig = ref({
                viewBoxWidth: 0,      // Base viewBox width (without legend-based adjustments)
                viewBoxHeight: 0,     // Base viewBox height
                diagramCenterX: 0,    // Original diagram center X coordinate
                diagramCenterY: 0,    // Original diagram center Y coordinate
                legendWidth: 0,       // Legend width
                legendHeight: 0,      // Legend height
                generatedPosition: 'right'  // The position when SVG was generated
            });

            // Base configuration for linear mode (stored when SVG is generated)
            const linearBaseConfig = ref({
                verticalViewBox: { x: 0, y: 0, w: 0, h: 0 },   // ViewBox for vertical legend (left/right)
                horizontalViewBox: { x: 0, y: 0, w: 0, h: 0 }, // ViewBox for horizontal legend (top/bottom)
                diagramBaseTransforms: new Map(),              // Base transforms for diagram elements
                horizontalLegendWidth: 0, horizontalLegendHeight: 0,
                verticalLegendWidth: 0, verticalLegendHeight: 0,
                generatedPosition: 'right'  // The position when SVG was generated
            });

            // Store base transforms for diagram elements (separate from current offsets)
            const diagramElementBaseTransforms = ref(new Map());

            const featureKeys = [
                "assembly_gap", "C_region", "CDS", "centromere", "D-loop", "D_segment",
                "exon", "gap", "gene", "intron", "J_segment", "mat_peptide", "misc_binding",
                "misc_difference", "misc_feature", "misc_RNA", "misc_structure",
                "mobile_element", "modified_base", "mRNA", "ncRNA", "operon", "oriT",
                "precursor_RNA", "primer_bind", "propeptide", "protein_bind", "regulatory",
                "repeat_region", "rep_origin", "rRNA", "sig_peptide", "stem_loop",
                "telomere", "tmRNA", "transit_peptide", "tRNA", "unsure", "V_region",
                "V_segment", "variation", "3'UTR", "5'UTR"
            ];
            
            const newColorFeat = ref("gene");
            const newColorVal = ref("#d3d3d3");
            const addCustomColor = () => { 
                if(!newColorFeat.value) return; 
                currentColors.value = { 
                    ...currentColors.value, 
                    [newColorFeat.value]: newColorVal.value 
                }; 
            };
            const manualPriorityRules = reactive([]);
            const newPriorityRule = reactive({ feat: "CDS", order: "product,gene,locus_tag" });
            
            const addPriorityRule = () => {
                if (!newPriorityRule.order) return;
                // If the same feature exists, overwrite it; otherwise, add it.
                const idx = manualPriorityRules.findIndex(r => r.feat === newPriorityRule.feat);
                if (idx >= 0) {
                    manualPriorityRules[idx].order = newPriorityRule.order;
                } else {
                    manualPriorityRules.push({ feat: newPriorityRule.feat, order: newPriorityRule.order });
                }
            };
        
            const addSpecificRule = async () => {
                if(!newSpecRule.val) return;

                // If the regex is too long (>50 chars), warn the user about potential performance impact.
                if (newSpecRule.val.length > 50) {
                    if (!confirm("Regular expression is quite long (>50 chars). This might impact performance. Continue?")) {
                        return;
                    }
                }

                // Simple check for potentially dangerous patterns (warning)
                if (/\(.+[\+\*]\)[\+\*]/.test(newSpecRule.val) || /\(.*\)\+/.test(newSpecRule.val)) {
                    if (!confirm("This regular expression contains patterns that may freeze the browser (ReDoS risk). Are you sure you want to add it?")) {
                        return;
                    }
                }

                try {
                    new RegExp(newSpecRule.val);
                } catch (e) {
                    alert("Invalid Regular Expression: " + e.message);
                    return;
                }

                const rule = {
                    feat: String(newSpecRule.feat || ''),
                    qual: String(newSpecRule.qual || ''),
                    val: String(newSpecRule.val),
                    color: String(newSpecRule.color || '#000000'),
                    cap: String(newSpecRule.cap || '')
                };
                manualSpecificRules.push(rule);

                // Add legend entry if caption is provided
                if (rule.cap && pyodideReady.value) {
                    await Vue.nextTick();
                    const actualCaption = await addLegendEntry(rule.cap, rule.color);
                    if (actualCaption && typeof actualCaption === 'string') {
                        addedLegendCaptions.value.add(actualCaption);
                    }
                    extractLegendEntries();
                }

                newSpecRule.val = "";
            };
            const newFeatureToAdd = ref("mobile_element");
            const addFeature = () => { if(newFeatureToAdd.value && !adv.features.includes(newFeatureToAdd.value)){ adv.features.push(newFeatureToAdd.value); } };

            // Feature Color Editor functions
            const filteredFeatures = computed(() => {
                // First filter by feature type (only show features that are actually drawn)
                let features = extractedFeatures.value.filter(f =>
                    adv.features.includes(f.type)
                );

                // Filter by selected record (if multiple records exist)
                if (featureRecordIds.value.length > 1) {
                    const selectedIdx = selectedFeatureRecordIdx.value;
                    if (mode.value === 'circular') {
                        // For circular: filter by record_idx within the file
                        features = features.filter(f => f.record_idx === selectedIdx);
                    } else {
                        // For linear: filter by the combined file+record label
                        const selectedLabel = featureRecordIds.value[selectedIdx];
                        features = features.filter(f => f.displayRecordId === selectedLabel);
                    }
                }

                // Then apply search filter
                if (featureSearch.value) {
                    const q = featureSearch.value.toLowerCase();
                    features = features.filter(f =>
                        (f.product || '').toLowerCase().includes(q) ||
                        (f.gene || '').toLowerCase().includes(q) ||
                        (f.locus_tag || '').toLowerCase().includes(q) ||
                        (f.note || '').toLowerCase().includes(q) ||
                        f.type.toLowerCase().includes(q)
                    );
                }
                return features;
            });

            // Helper: parse hex color to RGB
            const hexToRgb = (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 128, g: 128, b: 128 };
            };

            // Helper: RGB to hex
            const rgbToHex = (r, g, b) => {
                return '#' + [r, g, b].map(x => {
                    const hex = Math.round(Math.max(0, Math.min(255, x))).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            };

            // Interpolate between two colors
            const interpolateColor = (color1, color2, factor) => {
                const c1 = hexToRgb(color1);
                const c2 = hexToRgb(color2);
                return rgbToHex(
                    c1.r + (c2.r - c1.r) * factor,
                    c1.g + (c2.g - c1.g) * factor,
                    c1.b + (c2.b - c1.b) * factor
                );
            };

            // Estimate the interpolation factor from a current color given min/max colors
            const estimateColorFactor = (currentColor, minColor, maxColor) => {
                const current = hexToRgb(currentColor);
                const min = hexToRgb(minColor);
                const max = hexToRgb(maxColor);

                // Calculate factor based on color distance
                const totalDist = Math.sqrt(
                    Math.pow(max.r - min.r, 2) + Math.pow(max.g - min.g, 2) + Math.pow(max.b - min.b, 2)
                );
                if (totalDist < 1) return 0.5;

                const currentDist = Math.sqrt(
                    Math.pow(current.r - min.r, 2) + Math.pow(current.g - min.g, 2) + Math.pow(current.b - min.b, 2)
                );
                return Math.max(0, Math.min(1, currentDist / totalDist));
            };

            const getFeatureColor = (feat) => {
                // Use internal ID for tracking (unique per feature)
                const override = featureColorOverrides[feat.id];
                if (override) {
                    return override.color || override;  // Support both {color, caption} and legacy string format
                }
                // Otherwise use the default color for this feature type from the palette
                return currentColors.value[feat.type] || '#cccccc';
            };

            // Helper to check if a feature can be identified for color editing
            // Always true - we can always use location as a unique identifier
            const canEditFeatureColor = (feat) => {
                return true;  // Location is always available
            };

            // Helper to get display caption for a feature (used for legend entries and sibling matching)
            const getFeatureCaption = (f) => f.product || f.gene || f.locus_tag || f.note || `${f.type} at ${f.start}..${f.end}`;

            // Helper to get the best qualifier for a feature
            // Uses hash pseudo-qualifier which is always unique (based on type+position+strand)
            // The svg_id is computed the same way in both Python and JavaScript
            const getFeatureQualifier = (feat) => {
                // Always use hash - it's the most reliable unique identifier
                // svg_id is pre-computed for each feature (e.g., "f1a2b3c4")
                return { qual: 'hash', val: feat.svg_id };
            };

            // Find if a feature matches an existing regex-based rule (non-hash rule)
            // Returns the matching rule or null
            const findMatchingRegexRule = (feat) => {
                for (const rule of manualSpecificRules) {
                    if (rule.feat !== feat.type) continue;
                    if (rule.qual === 'hash') continue; // Skip hash rules

                    let matches = false;
                    if (rule.qual === 'product' && feat.product) {
                        try {
                            const regex = new RegExp(rule.val, 'i');
                            matches = regex.test(feat.product);
                        } catch {
                            matches = feat.product === rule.val;
                        }
                    } else if (rule.qual === 'gene' && feat.gene) {
                        try {
                            const regex = new RegExp(rule.val, 'i');
                            matches = regex.test(feat.gene);
                        } catch {
                            matches = feat.gene === rule.val;
                        }
                    } else if (rule.qual === 'locus_tag' && feat.locus_tag) {
                        try {
                            const regex = new RegExp(rule.val, 'i');
                            matches = regex.test(feat.locus_tag);
                        } catch {
                            matches = feat.locus_tag === rule.val;
                        }
                    }

                    if (matches) {
                        return rule;
                    }
                }
                return null;
            };

            // Count all features that match a specific regex rule
            const countFeaturesMatchingRule = (rule) => {
                if (!rule || rule.qual === 'hash') return 0;

                let count = 0;
                for (const feat of extractedFeatures.value) {
                    if (feat.type !== rule.feat) continue;

                    let matches = false;
                    if (rule.qual === 'product' && feat.product) {
                        try {
                            const regex = new RegExp(rule.val, 'i');
                            matches = regex.test(feat.product);
                        } catch {
                            matches = feat.product === rule.val;
                        }
                    } else if (rule.qual === 'gene' && feat.gene) {
                        try {
                            const regex = new RegExp(rule.val, 'i');
                            matches = regex.test(feat.gene);
                        } catch {
                            matches = feat.gene === rule.val;
                        }
                    } else if (rule.qual === 'locus_tag' && feat.locus_tag) {
                        try {
                            const regex = new RegExp(rule.val, 'i');
                            matches = regex.test(feat.locus_tag);
                        } catch {
                            matches = feat.locus_tag === rule.val;
                        }
                    }

                    if (matches) count++;
                }
                return count;
            };

            // Find features that share the same legend caption (excluding the current feature)
            const findFeaturesWithSameCaption = (currentFeat, caption) => {
                if (!caption) return [];
                return extractedFeatures.value.filter(f => {
                    if (f.svg_id === currentFeat.svg_id) return false; // Exclude self
                    // Determine this feature's caption
                    const featCaption = f.product || f.gene || f.locus_tag || f.type;
                    return featCaption === caption;
                });
            };

            // Find if there's an existing hash-based rule for features with the same caption
            // Returns {rule, color} if found, null otherwise
            const findExistingColorForCaption = (currentFeat, caption) => {
                if (!caption) return null;

                // First, check if there's a rule with this caption
                for (const rule of manualSpecificRules) {
                    if (rule.cap === caption && rule.qual === 'hash') {
                        // Found a hash rule with this caption
                        return { rule, color: rule.color };
                    }
                }

                // Also check for regex rules that match features with this caption
                for (const rule of manualSpecificRules) {
                    if (rule.cap === caption && rule.qual !== 'hash') {
                        return { rule, color: rule.color };
                    }
                }

                return null;
            };

            // Instant preview: update SVG path colors directly without regeneration
            // Uses current DOM to preserve legend position and other modifications
            const applyInstantPreview = (feat, color, legendCaption = null) => {
                // Use pre-computed svg_id that matches Python's hash
                const svgId = feat.svg_id;
                if (!svgId) {
                    console.log('No svg_id for feature', feat);
                    return;
                }

                // Update DOM directly (preserves legend position and other modifications)
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                try {
                    // Find ALL elements with this ID (for multi-exon features)
                    const elements = svg.querySelectorAll(`#${CSS.escape(svgId)}`);
                    let updated = elements.length > 0;

                    if (updated) {
                        elements.forEach(el => el.setAttribute('fill', color));
                    }

                    // Note: Legend entries are added separately via addLegendEntry() in setFeatureColor()

                    if (updated) {
                        // Serialize and save to results.value to persist the change
                        const serializer = new XMLSerializer();
                        const newContent = serializer.serializeToString(svg);
                        skipCaptureBaseConfig.value = true;
                        const idx = selectedResultIndex.value;
                        if (idx >= 0 && results.value.length > idx) {
                            results.value[idx] = { ...results.value[idx], content: newContent };
                        }
                        console.log(`Instant preview: updated ${elements.length} element(s) for ${svgId} to ${color}`);
                    } else {
                        console.log(`Instant preview: element ${svgId} not found in SVG`);
                    }
                } catch (e) {
                    console.error('Instant preview error:', e);
                }
            };

            // Attach click handlers to SVG feature paths
            const attachSvgFeatureHandlers = () => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                // Find all paths with id starting with 'f' (feature hash IDs)
                const featurePaths = svg.querySelectorAll('path[id^="f"], polygon[id^="f"]');

                // Group paths by ID (for multi-exon features)
                const pathsByIdMap = {};
                featurePaths.forEach(path => {
                    const id = path.getAttribute('id');
                    if (!pathsByIdMap[id]) pathsByIdMap[id] = [];
                    pathsByIdMap[id].push(path);
                });

                // Helper to highlight all segments of a feature
                const highlightFeature = (svgId, highlight) => {
                    const paths = pathsByIdMap[svgId] || [];
                    paths.forEach(p => {
                        p.style.opacity = highlight ? '0.7' : '1';
                        p.style.filter = highlight ? 'brightness(1.2)' : 'none';
                    });
                };

                featurePaths.forEach(path => {
                    const svgId = path.getAttribute('id');
                    path.style.cursor = 'pointer';

                    // Hover: highlight ALL segments with same ID
                    path.addEventListener('mouseenter', () => highlightFeature(svgId, true));
                    path.addEventListener('mouseleave', () => highlightFeature(svgId, false));

                    // Click handler
                    path.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // Find matching feature from extractedFeatures
                        const feat = extractedFeatures.value.find(f => f.svg_id === svgId);
                        if (feat) {
                            const currentColor = path.getAttribute('fill') || getFeatureColor(feat);
                            const defaultLabel = feat.product || feat.gene || feat.locus_tag || `${feat.type} at ${feat.start}..${feat.end}`;

                            // Check if there's an existing override with a caption
                            const existingOverride = featureColorOverrides[feat.id];
                            const existingCaption = existingOverride?.caption || '';

                            // Get current stroke values from SVG element
                            const currentStrokeColor = path.getAttribute('stroke') || '#000000';
                            const currentStrokeWidth = parseFloat(path.getAttribute('stroke-width')) || 0.5;

                            clickedFeature.value = {
                                id: feat.id,
                                svg_id: svgId,
                                label: defaultLabel,
                                color: currentColor,
                                feat: feat,
                                // Pre-fill with existing caption if available, otherwise empty
                                legendName: existingCaption,
                                // Stroke properties
                                strokeColor: currentStrokeColor,
                                strokeWidth: currentStrokeWidth,
                                originalStrokeColor: currentStrokeColor,
                                originalStrokeWidth: currentStrokeWidth
                            };
                            // Position popup near click
                            clickedFeaturePos.x = Math.min(e.clientX + 10, window.innerWidth - 280);
                            clickedFeaturePos.y = Math.min(e.clientY + 10, window.innerHeight - 100);
                        } else {
                            console.log(`No feature found for svg_id: ${svgId}`);
                        }
                    });
                });

                console.log(`Attached handlers to ${featurePaths.length} feature paths (${Object.keys(pathsByIdMap).length} unique features)`);
            };

            // Update color from the popup picker
            const updateClickedFeatureColor = async (color) => {
                if (!clickedFeature.value) return;
                const feat = clickedFeature.value.feat;
                // Use custom legendName if provided (check for non-empty trimmed string)
                const customName = clickedFeature.value.legendName?.trim();
                const legendName = customName ? customName : clickedFeature.value.label;

                // Check if this feature matches an existing regex rule (from -t table)
                const matchingRule = findMatchingRegexRule(feat);

                // Count features matching the regex rule (if any)
                const ruleMatchCount = matchingRule ? countFeaturesMatchingRule(matchingRule) : 0;

                // Find sibling features with the same caption (different from regex rule matches)
                const siblings = findFeaturesWithSameCaption(feat, legendName);
                const siblingCount = siblings.length;

                // Find if there's an existing color rule for this caption
                const existingCaption = findExistingColorForCaption(feat, legendName);

                // Determine if we need to show the dialog
                const needsDialog = matchingRule || siblingCount > 0 || existingCaption;

                if (needsDialog) {
                    // Show dialog with appropriate options
                    colorScopeDialog.show = true;
                    colorScopeDialog.feat = feat;
                    colorScopeDialog.color = color;
                    colorScopeDialog.matchingRule = matchingRule;
                    colorScopeDialog.ruleMatchCount = ruleMatchCount;
                    colorScopeDialog.legendName = legendName;
                    colorScopeDialog.siblingCount = siblingCount;
                    colorScopeDialog.existingCaptionRule = existingCaption?.rule || null;
                    colorScopeDialog.existingCaptionColor = existingCaption?.color || null;
                    // Close the color picker popup
                    clickedFeature.value = null;
                } else {
                    // No siblings and no existing rule - just apply to this feature
                    clickedFeature.value.color = color;
                    setFeatureColor(feat, color, legendName);
                }
            };

            // Handle user's choice from the color scope dialog
            const handleColorScopeChoice = async (choice) => {
                const { feat, color, matchingRule, legendName, siblingCount, existingCaptionRule, existingCaptionColor } = colorScopeDialog;

                if (choice === 'rule') {
                    // Apply to all features matching the regex rule (update the rule color)
                    if (matchingRule) {
                        matchingRule.color = color;
                        if (matchingRule.cap) {
                            updateLegendEntryColorByCaption(matchingRule.cap, color);
                            extractLegendEntries();
                        }
                    }
                    applySpecificRulesToSvg();
                } else if (choice === 'caption') {
                    // Apply to all features with the same caption
                    // Create hash-based rules for each feature (takes priority over regex rules)
                    const siblings = findFeaturesWithSameCaption(feat, legendName);
                    const allFeatures = [feat, ...siblings];

                    for (const f of allFeatures) {
                        const existingIdx = manualSpecificRules.findIndex(r =>
                            r.qual === 'hash' && r.val === f.svg_id
                        );
                        if (existingIdx >= 0) {
                            manualSpecificRules[existingIdx].color = color;
                            manualSpecificRules[existingIdx].cap = legendName;
                        } else {
                            manualSpecificRules.push({
                                feat: f.type,
                                qual: 'hash',
                                val: f.svg_id,
                                color: color,
                                cap: legendName
                            });
                        }
                    }
                    addLegendEntry(legendName, color);
                    applySpecificRulesToSvg();
                } else if (choice === 'single') {
                    // Create a new hash-based rule for this specific feature only
                    await setFeatureColor(feat, color, legendName);
                } else if (choice === 'useExisting') {
                    // Apply the existing caption's color to this feature
                    if (existingCaptionColor) {
                        // Create a hash-based rule for this feature with the existing color
                        const existingRule = manualSpecificRules.find(r =>
                            r.qual === 'hash' && r.val === feat.svg_id
                        );
                        if (existingRule) {
                            existingRule.color = existingCaptionColor;
                        } else {
                            manualSpecificRules.push({
                                feat: feat.type,
                                qual: 'hash',
                                val: feat.svg_id,
                                color: existingCaptionColor,
                                cap: legendName
                            });
                        }
                        applyInstantPreview(feat, existingCaptionColor, legendName);
                        applySpecificRulesToSvg();
                    }
                }
                // choice === 'cancel' - do nothing

                // Close dialog and reset all state
                colorScopeDialog.show = false;
                colorScopeDialog.feat = null;
                colorScopeDialog.color = null;
                colorScopeDialog.matchingRule = null;
                colorScopeDialog.ruleMatchCount = 0;
                colorScopeDialog.legendName = null;
                colorScopeDialog.siblingCount = 0;
                colorScopeDialog.existingCaptionRule = null;
                colorScopeDialog.existingCaptionColor = null;
            };

            // Update stroke from the popup picker (for individual feature)
            const updateClickedFeatureStroke = (strokeColor, strokeWidth) => {
                if (!clickedFeature.value) return;
                if (!svgContainer.value) return;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                const svgId = clickedFeature.value.svg_id;
                const elements = svg.querySelectorAll(`#${CSS.escape(svgId)}`);

                elements.forEach(el => {
                    if (strokeColor !== null) {
                        el.setAttribute('stroke', strokeColor);
                        clickedFeature.value.strokeColor = strokeColor;
                    }
                    if (strokeWidth !== null) {
                        const widthVal = parseFloat(strokeWidth);
                        if (!isNaN(widthVal)) {
                            el.setAttribute('stroke-width', widthVal);
                            clickedFeature.value.strokeWidth = widthVal;
                        }
                    }
                });

                // Save to results
                skipCaptureBaseConfig.value = true;
                const resultIdx = selectedResultIndex.value;
                if (resultIdx >= 0 && results.value.length > resultIdx) {
                    const serializer = new XMLSerializer();
                    results.value[resultIdx] = { ...results.value[resultIdx], content: serializer.serializeToString(svg) };
                }
            };

            // Reset stroke to original values for clicked feature (gbdraw's auto-determined defaults)
            const resetClickedFeatureStroke = () => {
                if (!clickedFeature.value) return;
                if (!svgContainer.value) return;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                const svgId = clickedFeature.value.svg_id;
                const elements = svg.querySelectorAll(`#${CSS.escape(svgId)}`);

                // Use captured original values - restore exact state (including no stroke)
                const originalColor = originalSvgStroke.value.color;
                const originalWidth = originalSvgStroke.value.width;

                elements.forEach(el => {
                    if (originalColor === null) {
                        el.removeAttribute('stroke');
                    } else {
                        el.setAttribute('stroke', originalColor);
                    }
                    if (originalWidth === null) {
                        el.removeAttribute('stroke-width');
                    } else {
                        el.setAttribute('stroke-width', originalWidth);
                    }
                });

                // Update UI state
                clickedFeature.value.strokeColor = originalColor || '';
                clickedFeature.value.strokeWidth = originalWidth ?? '';

                // Save to results
                skipCaptureBaseConfig.value = true;
                const resultIdx = selectedResultIndex.value;
                if (resultIdx >= 0 && results.value.length > resultIdx) {
                    const serializer = new XMLSerializer();
                    results.value[resultIdx] = { ...results.value[resultIdx], content: serializer.serializeToString(svg) };
                }
            };

            // Reset fill color dialog state
            const resetColorDialog = reactive({
                show: false,
                caption: '',
                defaultColor: '',
                siblingCount: 0
            });

            // Reset fill color to default palette color for clicked feature
            const resetClickedFeatureFillColor = () => {
                if (!clickedFeature.value) return;
                if (!svgContainer.value) return;

                const feat = clickedFeature.value.feat;
                if (!feat) return;

                // Get the default color from the current palette
                const defaultColor = currentColors.value[feat.type];
                if (!defaultColor) {
                    console.warn('No default color found for feature type:', feat.type);
                    return;
                }

                // Get caption for this feature
                const caption = feat.product || feat.gene || feat.locus_tag || feat.note || `${feat.type} at ${feat.start}..${feat.end}`;

                // Count siblings with the same caption
                const siblings = extractedFeatures.value.filter(f => getFeatureCaption(f) === caption && f.svg_id !== clickedFeature.value.svg_id);

                if (siblings.length > 0) {
                    // Show dialog to let user choose
                    resetColorDialog.show = true;
                    resetColorDialog.caption = caption;
                    resetColorDialog.defaultColor = defaultColor;
                    resetColorDialog.siblingCount = siblings.length;
                } else {
                    // No siblings, just reset this one
                    doResetFillColor('this');
                }
            };

            // Handle reset color dialog choice
            const handleResetColorChoice = async (choice) => {
                resetColorDialog.show = false;
                await doResetFillColor(choice);
            };

            // Actually perform the fill color reset
            const doResetFillColor = async (choice) => {
                if (!clickedFeature.value) return;
                if (!svgContainer.value) return;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                const feat = clickedFeature.value.feat;
                if (!feat) return;

                const defaultColor = resetColorDialog.defaultColor || currentColors.value[feat.type];
                const caption = resetColorDialog.caption || feat.product || feat.gene || feat.locus_tag || feat.note || `${feat.type} at ${feat.start}..${feat.end}`;
                const svgId = clickedFeature.value.svg_id;

                if (choice === 'this' || choice === 'this_with_legend') {
                    // Reset only this feature
                    const elements = svg.querySelectorAll(`#${CSS.escape(svgId)}`);
                    elements.forEach(el => {
                        el.setAttribute('fill', defaultColor);
                    });

                    // Update UI state
                    clickedFeature.value.color = defaultColor;

                    // Remove any specific color rule for this feature
                    const ruleIdx = manualSpecificRules.findIndex(r =>
                        r.qual === 'hash' && r.val === svgId
                    );
                    if (ruleIdx !== -1) {
                        manualSpecificRules.splice(ruleIdx, 1);
                    }

                    // Add legend entry if requested
                    if (choice === 'this_with_legend') {
                        console.log(`Attempting to add legend entry: caption="${caption}", color="${defaultColor}"`);
                        // Always add a legend entry - addLegendEntry will handle duplicate captions
                        // by appending a number if needed
                        const addedCaption = await addLegendEntry(caption, defaultColor);
                        console.log(`addLegendEntry returned: ${addedCaption}`);
                        if (addedCaption) {
                            extractLegendEntries();
                            console.log(`Added legend entry: ${addedCaption} with color: ${defaultColor}`);
                        } else {
                            console.error(`Failed to add legend entry for caption="${caption}"`);
                        }
                    }

                    console.log(`Reset fill color to default (${defaultColor}) for feature: ${svgId}`);
                } else if (choice === 'all') {
                    // Reset all features with the same caption
                    const matchingFeatures = extractedFeatures.value.filter(f => getFeatureCaption(f) === caption);

                    for (const matchFeat of matchingFeatures) {
                        const elements = svg.querySelectorAll(`#${CSS.escape(matchFeat.svg_id)}`);
                        elements.forEach(el => {
                            el.setAttribute('fill', defaultColor);
                        });
                    }

                    // Update UI state for clicked feature
                    clickedFeature.value.color = defaultColor;

                    // Remove all specific color rules for features with this caption
                    for (let i = manualSpecificRules.length - 1; i >= 0; i--) {
                        const rule = manualSpecificRules[i];
                        if (rule.cap === caption) {
                            manualSpecificRules.splice(i, 1);
                        }
                    }

                    // Also remove the legend entry for this caption if it exists
                    const legendIdx = legendEntries.value.findIndex(e => e.caption === caption);
                    if (legendIdx !== -1) {
                        await removeLegendEntry(caption);
                        extractLegendEntries();
                    }

                    console.log(`Reset fill color to default (${defaultColor}) for all ${matchingFeatures.length} features with caption: ${caption}`);
                }

                // Save to results
                skipCaptureBaseConfig.value = true;
                const resultIdx = selectedResultIndex.value;
                if (resultIdx >= 0 && results.value.length > resultIdx) {
                    const serializer = new XMLSerializer();
                    results.value[resultIdx] = { ...results.value[resultIdx], content: serializer.serializeToString(svg) };
                }

                // Close the feature popup
                clickedFeature.value = null;
            };

            // Apply current stroke to all siblings (features with the same caption AND same fill color)
            const applyStrokeToAllSiblings = async () => {
                if (!clickedFeature.value) return;
                if (!svgContainer.value) return;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                const currentStrokeColor = clickedFeature.value.strokeColor;
                const currentStrokeWidth = clickedFeature.value.strokeWidth;
                const currentFillColor = clickedFeature.value.color;
                const clickedSvgId = clickedFeature.value.svg_id;

                // Get the caption for the clicked feature (for fallback and logging)
                const feat = clickedFeature.value.feat;
                if (!feat) {
                    console.warn('No feature data found in clickedFeature');
                    return;
                }
                const caption = feat.product || feat.gene || feat.locus_tag || feat.note || `${feat.type} at ${feat.start}..${feat.end}`;

                // Find the legend entry that contains this feature's svg_id
                let targetLegendEntry = legendEntries.value.find(e => e.featureIds && e.featureIds.includes(clickedSvgId));

                // Fallback: if no legend entry found by svg_id, find by color match
                if (!targetLegendEntry) {
                    targetLegendEntry = legendEntries.value.find(e =>
                        e.color && e.color.toLowerCase() === currentFillColor?.toLowerCase()
                    );
                }

                // Get sibling features from the legend entry's featureIds, or fallback to color matching
                let siblingFeatureIds = [];
                if (targetLegendEntry && targetLegendEntry.featureIds && targetLegendEntry.featureIds.length > 0) {
                    siblingFeatureIds = targetLegendEntry.featureIds;
                    console.log(`Found legend entry "${targetLegendEntry.caption}" with ${siblingFeatureIds.length} features`);
                } else {
                    // Fallback: find features by caption and color
                    const siblingFeatures = extractedFeatures.value.filter(f => {
                        if (getFeatureCaption(f) !== caption) return false;
                        const el = svg.querySelector(`#${CSS.escape(f.svg_id)}`);
                        if (!el) return false;
                        const fillColor = el.getAttribute('fill');
                        return fillColor && fillColor.toLowerCase() === currentFillColor?.toLowerCase();
                    });
                    siblingFeatureIds = siblingFeatures.map(f => f.svg_id);
                    console.log(`Fallback: Found ${siblingFeatureIds.length} features by caption="${caption}" and color="${currentFillColor}"`);
                }

                // Apply stroke to all sibling features
                let updatedCount = 0;
                for (const svgId of siblingFeatureIds) {
                    const elements = svg.querySelectorAll(`#${CSS.escape(svgId)}`);
                    elements.forEach(el => {
                        if (currentStrokeColor) {
                            el.setAttribute('stroke', currentStrokeColor);
                            updatedCount++;
                        }
                        if (currentStrokeWidth !== null && currentStrokeWidth !== '') {
                            el.setAttribute('stroke-width', parseFloat(currentStrokeWidth));
                        }
                    });
                }

                console.log(`Applied stroke to ${siblingFeatureIds.length} features`);

                // Update legend rect stroke using the legend entry's position
                if (targetLegendEntry) {
                    const legendGroups = getAllFeatureLegendGroups(svg);
                    for (const targetGroup of legendGroups) {
                        const texts = targetGroup.querySelectorAll('text');
                        for (const t of texts) {
                            // Match by current caption (which may have been edited)
                            if (t.textContent?.trim() === targetLegendEntry.caption.trim()) {
                                const transform = t.getAttribute('transform');
                                if (transform) {
                                    const match = transform.match(/translate\([^,]+,\s*([\d.-]+)\)/);
                                    if (match) {
                                        const textY = parseFloat(match[1]);
                                        const paths = targetGroup.querySelectorAll('path');
                                        paths.forEach(p => {
                                            const pt = p.getAttribute('transform');
                                            const fill = p.getAttribute('fill');
                                            if (pt && fill && fill.toLowerCase() === targetLegendEntry.color.toLowerCase()) {
                                                const pMatch = pt.match(/translate\([^,]+,\s*([\d.-]+)\)/);
                                                if (pMatch && Math.abs(parseFloat(pMatch[1]) - textY) < 1) {
                                                    if (currentStrokeColor) {
                                                        p.setAttribute('stroke', currentStrokeColor);
                                                    }
                                                    if (currentStrokeWidth !== null && currentStrokeWidth !== '') {
                                                        p.setAttribute('stroke-width', parseFloat(currentStrokeWidth));
                                                    }
                                                    console.log(`Updated legend rect stroke for "${targetLegendEntry.caption}"`);
                                                }
                                            }
                                        });
                                    }
                                }
                            }
                        }
                    }
                }

                // Get the caption to use for stroke overrides (use legend entry caption if available)
                const overrideKey = targetLegendEntry ? targetLegendEntry.caption : caption;

                // Create legend entry if it doesn't exist
                if (!targetLegendEntry) {
                    const fillColor = clickedFeature.value.color || '#cccccc';
                    const addedCaption = await addLegendEntry(caption, fillColor);
                    if (addedCaption) {
                        extractLegendEntries();
                        targetLegendEntry = legendEntries.value.find(e => e.caption === addedCaption);
                        if (targetLegendEntry) {
                            targetLegendEntry.showStroke = true;
                            // Add the feature to this legend entry's featureIds
                            if (!targetLegendEntry.featureIds) targetLegendEntry.featureIds = [];
                            if (!targetLegendEntry.featureIds.includes(clickedSvgId)) {
                                targetLegendEntry.featureIds.push(clickedSvgId);
                            }
                        }
                        console.log(`Created new legend entry for caption: ${addedCaption}`);
                    } else {
                        targetLegendEntry = {
                            caption: caption,
                            originalCaption: caption,
                            color: fillColor,
                            visible: true,
                            showStroke: true,
                            featureIds: [clickedSvgId]
                        };
                        legendEntries.value.push(targetLegendEntry);
                    }
                }

                // Update stroke overrides using the legend entry's caption
                if (!legendStrokeOverrides[overrideKey]) {
                    legendStrokeOverrides[overrideKey] = {};
                }
                if (currentStrokeColor) {
                    legendStrokeOverrides[overrideKey].strokeColor = currentStrokeColor;
                }
                if (currentStrokeWidth !== null && currentStrokeWidth !== '') {
                    legendStrokeOverrides[overrideKey].strokeWidth = parseFloat(currentStrokeWidth);
                }

                // Save to results
                skipCaptureBaseConfig.value = true;
                const resultIdx = selectedResultIndex.value;
                if (resultIdx >= 0 && results.value.length > resultIdx) {
                    const serializer = new XMLSerializer();
                    results.value[resultIdx] = { ...results.value[resultIdx], content: serializer.serializeToString(svg) };
                }

                console.log(`Applied stroke (color: ${currentStrokeColor}, width: ${currentStrokeWidth}) to ${siblingFeatureIds.length} features`);
            };

            // Re-apply stroke overrides to SVG (called after fresh generation to preserve customizations)
            const reapplyStrokeOverrides = () => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                const overrideCount = Object.keys(legendStrokeOverrides).length;
                if (overrideCount === 0) {
                    debugLog('No stroke overrides to reapply');
                    return;
                }

                console.log(`[DEBUG] Reapplying ${overrideCount} stroke overrides to new SVG`);

                let totalUpdated = 0;

                for (const [caption, overrides] of Object.entries(legendStrokeOverrides)) {
                    const { strokeColor, strokeWidth } = overrides;
                    if (!strokeColor && strokeWidth === undefined) continue;

                    // Find all features with this caption
                    const matchingFeatures = extractedFeatures.value.filter(f => getFeatureCaption(f) === caption);

                    for (const feat of matchingFeatures) {
                        const elements = svg.querySelectorAll(`#${CSS.escape(feat.svg_id)}`);
                        elements.forEach(el => {
                            if (strokeColor) {
                                el.setAttribute('stroke', strokeColor);
                            }
                            if (strokeWidth !== undefined && strokeWidth !== null) {
                                el.setAttribute('stroke-width', strokeWidth);
                            }
                            totalUpdated++;
                        });
                    }
                }

                if (totalUpdated > 0) {
                    // Save the updated SVG
                    skipCaptureBaseConfig.value = true;
                    const resultIdx = selectedResultIndex.value;
                    if (resultIdx >= 0 && results.value.length > resultIdx) {
                        const serializer = new XMLSerializer();
                        results.value[resultIdx] = { ...results.value[resultIdx], content: serializer.serializeToString(svg) };
                    }
                    console.log(`[DEBUG] Reapplied stroke overrides to ${totalUpdated} elements`);
                }
            };

            // Watch for SVG content changes to reattach handlers
            watch(() => svgContent.value, () => {
                // Use nextTick to ensure DOM is updated
                Vue.nextTick(() => {
                    attachSvgFeatureHandlers();
                });
            });

            // Ensure pairwise gradient IDs are unique between horizontal and vertical legends
            // This fixes the issue where both legends have gradients with the same ID,
            // causing only one gradient to be used by the browser
            const ensureUniquePairwiseGradientIds = (svg) => {
                if (!svg) return;

                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return;

                const horizontalLegend = legendGroup.querySelector('#legend_horizontal');
                const verticalLegend = legendGroup.querySelector('#legend_vertical');

                // Only need to fix if both legends exist
                if (!horizontalLegend || !verticalLegend) return;

                const fixGradientId = (legend, suffix) => {
                    const pairwiseLegend = legend.querySelector('#pairwise_legend');
                    if (!pairwiseLegend) return;

                    const gradient = pairwiseLegend.querySelector('linearGradient');
                    if (!gradient) return;

                    const currentId = gradient.id;
                    // Skip if already has the suffix
                    if (currentId.endsWith(`_${suffix}`)) return;

                    // Remove any existing suffix and add the correct one
                    const baseId = currentId.replace(/_[hv]$/, '');
                    const newId = `${baseId}_${suffix}`;
                    gradient.setAttribute('id', newId);

                    // Update all paths that reference this gradient
                    const paths = pairwiseLegend.querySelectorAll('path');
                    paths.forEach(path => {
                        const fill = path.getAttribute('fill');
                        if (fill && fill.includes('url(#')) {
                            path.setAttribute('fill', `url(#${newId})`);
                        }
                    });
                };

                fixGradientId(horizontalLegend, 'h');
                fixGradientId(verticalLegend, 'v');
            };

            // Function to apply palette colors to SVG immediately
            const applyPaletteToSvg = () => {
                if (!svgContent.value || !extractedFeatures.value.length) return;
                if (!svgContainer.value) return;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                // Ensure gradient IDs are unique before updating colors
                // This prevents issues where both horizontal and vertical legends
                // have gradients with the same ID
                ensureUniquePairwiseGradientIds(svg);

                const colors = currentColors.value;
                const featurePaths = svg.querySelectorAll('path[id^="f"]');
                let updatedCount = 0;

                featurePaths.forEach(path => {
                    const svgId = path.getAttribute('id');
                    const feat = extractedFeatures.value.find(f => f.svg_id === svgId);
                    if (!feat) return;

                    const paletteColor = colors[feat.type];
                    if (!paletteColor) return;

                    // Don't update if feature has a specific color rule (including hash-based rules)
                    const hasSpecificRule = manualSpecificRules.some(r => {
                        // Check for hash-based rule (individual feature override)
                        if (r.qual === 'hash' && r.val === feat.svg_id) {
                            return true;
                        }
                        // Check for qualifier-based rule (product, gene, locus_tag)
                        const qualInfo = getFeatureQualifier(feat);
                        return qualInfo && r.feat === feat.type && r.qual === qualInfo.qual && r.val === qualInfo.val;
                    });

                    if (!hasSpecificRule && !featureColorOverrides[feat.id]) {
                        const currentFill = path.getAttribute('fill');
                        if (currentFill !== paletteColor) {
                            path.setAttribute('fill', paletteColor);
                            updatedCount++;
                        }
                    }
                });

                // Update GC content track
                const gcContentGroup = svg.getElementById('gc_content');
                if (gcContentGroup && colors.gc_content) {
                    const gcPaths = gcContentGroup.querySelectorAll('path');
                    gcPaths.forEach(path => {
                        path.setAttribute('fill', colors.gc_content);
                        updatedCount++;
                    });
                }

                // Update GC skew track (circular: #skew, linear: #gc_skew)
                const skewGroup = svg.getElementById('skew') || svg.getElementById('gc_skew');
                if (skewGroup) {
                    const skewPaths = skewGroup.querySelectorAll('path');
                    // In circular: first visible path is high (after clipPath), second is low
                    // In linear: similar structure
                    let pathIndex = 0;
                    skewPaths.forEach(path => {
                        const fill = path.getAttribute('fill');
                        // Skip clipPath paths (fill="white") and non-filled paths
                        if (fill && fill !== 'white' && fill !== 'none') {
                            if (pathIndex === 0 && colors.skew_high) {
                                path.setAttribute('fill', colors.skew_high);
                                updatedCount++;
                            } else if (pathIndex === 1 && colors.skew_low) {
                                path.setAttribute('fill', colors.skew_low);
                                updatedCount++;
                            }
                            pathIndex++;
                        }
                    });
                }

                // Update pairwise match tracks (comparison1, comparison2, etc.)
                // These use color interpolation based on identity
                if (colors.pairwise_match_min && colors.pairwise_match_max) {
                    let compIdx = 1;
                    let compGroup = svg.getElementById(`comparison${compIdx}`);
                    while (compGroup) {
                        const matchPaths = compGroup.querySelectorAll('path');
                        matchPaths.forEach((path, pathIdx) => {
                            const pathKey = `comp${compIdx}_path${pathIdx}`;
                            const currentFill = path.getAttribute('fill');
                            if (currentFill) {
                                let factor;
                                // Check if we have a stored factor for this path
                                if (pairwiseMatchFactors.value[pathKey] !== undefined) {
                                    factor = pairwiseMatchFactors.value[pathKey];
                                } else {
                                    // First time - estimate factor from original colors used when diagram was generated
                                    const origMin = window._origPairwiseMin || '#FFE7E7';
                                    const origMax = window._origPairwiseMax || '#FF7272';
                                    factor = estimateColorFactor(currentFill, origMin, origMax);
                                    pairwiseMatchFactors.value[pathKey] = factor;
                                }
                                const newColor = interpolateColor(colors.pairwise_match_min, colors.pairwise_match_max, factor);
                                path.setAttribute('fill', newColor);
                                updatedCount++;
                            }
                        });
                        compIdx++;
                        compGroup = svg.getElementById(`comparison${compIdx}`);
                    }
                }

                // Also update legend colors in ALL feature legend groups (both horizontal and vertical)
                // This ensures both legends stay in sync when palette changes
                const featureLegendGroups = getAllFeatureLegendGroups(svg);
                if (featureLegendGroups.length > 0) {
                    // Map legend key to palette color keys
                    const keyToColorKey = {
                        'CDS': 'CDS',
                        'repeat_region': 'repeat_region',
                        'tmRNA': 'tmRNA',
                        'tRNA': 'tRNA',
                        'rRNA': 'rRNA',
                        'ncRNA': 'ncRNA',
                        'misc_feature': 'misc_feature',
                        'mobile_element': 'mobile_element',
                        'GC content': 'gc_content',
                        'GC skew (+)': 'skew_high',
                        'GC skew (-)': 'skew_low'
                    };

                    featureLegendGroups.forEach(featureLegendGroup => {
                        if (!featureLegendGroup) return;

                        // Find entry groups with data-legend-key attribute (new structure)
                        const entryGroups = featureLegendGroup.querySelectorAll('g[data-legend-key]');

                        if (entryGroups.length > 0) {
                            // New structure: each entry is wrapped in a group with data-legend-key
                            entryGroups.forEach(entryGroup => {
                                const legendKey = entryGroup.getAttribute('data-legend-key');
                                if (!legendKey) return;

                                // Skip if this legend entry has a custom color override
                                if (legendColorOverrides[legendKey]) return;

                                // Get the color for this legend key
                                const colorKey = keyToColorKey[legendKey];
                                const newColor = colorKey ? colors[colorKey] : colors[legendKey];
                                if (!newColor) return;

                                // Find the color rectangle (first path with solid fill) in this entry group
                                const paths = entryGroup.querySelectorAll('path');
                                for (const path of paths) {
                                    const fill = path.getAttribute('fill');
                                    if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                                        path.setAttribute('fill', newColor);
                                        updatedCount++;
                                        break;  // Only update the first matching path (the color rect)
                                    }
                                }
                            });
                        } else {
                            // Fallback: old structure without data-legend-key (position-based matching)
                            const texts = featureLegendGroup.querySelectorAll('text');
                            const allPaths = featureLegendGroup.querySelectorAll('path');

                            const parseTransform = (transform) => {
                                if (!transform) return { x: 0, y: 0 };
                                const match = transform.match(/translate\(\s*([\d.-]+)\s*,\s*([\d.-]+)\s*\)/);
                                return match ? { x: parseFloat(match[1]), y: parseFloat(match[2]) } : { x: 0, y: 0 };
                            };

                            texts.forEach(textEl => {
                                const textContent = textEl.textContent?.trim();
                                if (!textContent) return;
                                if (legendColorOverrides[textContent]) return;

                                const colorKey = keyToColorKey[textContent];
                                const newColor = colorKey ? colors[colorKey] : colors[textContent];
                                if (!newColor) return;

                                const textPos = parseTransform(textEl.getAttribute('transform'));
                                let bestPath = null;
                                let bestX = -Infinity;
                                for (const path of allPaths) {
                                    const pathPos = parseTransform(path.getAttribute('transform'));
                                    const fill = path.getAttribute('fill');
                                    if (Math.abs(pathPos.y - textPos.y) < 2 &&
                                        pathPos.x < textPos.x &&
                                        fill && fill !== 'none' && !fill.startsWith('url(')) {
                                        if (pathPos.x > bestX) {
                                            bestX = pathPos.x;
                                            bestPath = path;
                                        }
                                    }
                                }
                                if (bestPath) {
                                    bestPath.setAttribute('fill', newColor);
                                    updatedCount++;
                                }
                            });
                        }
                    });
                }

                // Update ALL pairwise legend gradients (both horizontal and vertical legends)
                if (colors.pairwise_match_min && colors.pairwise_match_max) {
                    const allPairwiseLegends = svg.querySelectorAll('#pairwise_legend, [id="pairwise_legend"]');
                    allPairwiseLegends.forEach(pairwiseLegend => {
                        // Find the linearGradient element
                        const gradient = pairwiseLegend.querySelector('linearGradient');
                        if (gradient) {
                            const stops = gradient.querySelectorAll('stop');
                            if (stops.length >= 2) {
                                // First stop is min color (0%), second is max color (100%)
                                stops[0].setAttribute('stop-color', colors.pairwise_match_min);
                                stops[1].setAttribute('stop-color', colors.pairwise_match_max);
                                updatedCount++;
                            }
                        }
                    });
                }

                if (updatedCount > 0) {
                    skipCaptureBaseConfig.value = true;
                    const idx = selectedResultIndex.value;
                    if (idx >= 0 && results.value.length > idx) {
                        const serializer = new XMLSerializer();
                        results.value[idx] = { ...results.value[idx], content: serializer.serializeToString(svg) };
                    }
                }
            };

            // Watch for palette color changes
            watch(currentColors, () => {
                applyPaletteToSvg();
                // Re-apply specific rules to ensure custom colors are preserved
                applySpecificRulesToSvg();
            }, { deep: true });

            // Function to apply specific rules to SVG immediately
            const applySpecificRulesToSvg = () => {
                if (!svgContent.value || !extractedFeatures.value.length) return;
                if (!svgContainer.value) return;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                let updatedCount = 0;

                // For each extracted feature, check if it matches any specific rule
                extractedFeatures.value.forEach(feat => {
                    if (!feat.svg_id) return;

                    // Check if there's a matching specific rule
                    // Priority: hash rules (highest) > regex rules (product/gene/locus_tag)
                    let matchingRule = null;

                    // First pass: check hash-based rules (most specific, individual feature overrides)
                    for (const rule of manualSpecificRules) {
                        if (rule.feat !== feat.type) continue;
                        if (rule.qual === 'hash' && feat.svg_id === rule.val) {
                            matchingRule = rule;
                            break;
                        }
                    }

                    // Second pass: if no hash match, check regex-based rules
                    if (!matchingRule) {
                        for (const rule of manualSpecificRules) {
                            if (rule.feat !== feat.type) continue;
                            if (rule.qual === 'hash') continue; // Already checked in first pass

                            let matches = false;
                            if (rule.qual === 'product' && feat.product) {
                                // Support regex matching
                                try {
                                    const regex = new RegExp(rule.val, 'i');
                                    matches = regex.test(feat.product);
                                } catch {
                                    matches = feat.product === rule.val;
                                }
                            } else if (rule.qual === 'gene' && feat.gene) {
                                try {
                                    const regex = new RegExp(rule.val, 'i');
                                    matches = regex.test(feat.gene);
                                } catch {
                                    matches = feat.gene === rule.val;
                                }
                            } else if (rule.qual === 'locus_tag' && feat.locus_tag) {
                                try {
                                    const regex = new RegExp(rule.val, 'i');
                                    matches = regex.test(feat.locus_tag);
                                } catch {
                                    matches = feat.locus_tag === rule.val;
                                }
                            }

                            if (matches) {
                                matchingRule = rule;
                                break;
                            }
                        }
                    }

                    // Apply color based on matching rule or default palette
                    const elements = svg.querySelectorAll(`#${CSS.escape(feat.svg_id)}`);
                    if (elements.length > 0) {
                        const newColor = matchingRule ? matchingRule.color : (currentColors.value[feat.type] || '#cccccc');
                        elements.forEach(el => {
                            if (el.getAttribute('fill') !== newColor) {
                                el.setAttribute('fill', newColor);
                                updatedCount++;
                            }
                        });
                    }
                });

                if (updatedCount > 0) {
                    skipCaptureBaseConfig.value = true;
                    const idx = selectedResultIndex.value;
                    if (idx >= 0 && results.value.length > idx) {
                        const serializer = new XMLSerializer();
                        results.value[idx] = { ...results.value[idx], content: serializer.serializeToString(svg) };
                    }
                    console.log(`Applied specific rules: updated ${updatedCount} elements`);
                }
            };

            // Track legend entries added by specific rules
            const addedLegendCaptions = ref(new Set());
            // Track legend entries added from file-loaded rules (preserved on reset)
            const fileLegendCaptions = ref(new Set());

            // Watch for specific rules changes - only apply styles and handle removals
            // Legend ADDITIONS are handled by setFeatureColor to avoid race conditions
            watch(() => [...manualSpecificRules], async (newRules, oldRules) => {
                applySpecificRulesToSvg();

                // Get captions from current and old rules
                const currentCaptions = new Set(newRules.filter(r => r.cap).map(r => r.cap));
                const oldCaptions = new Set((oldRules || []).filter(r => r.cap).map(r => r.cap));

                // Find removed captions (were in old rules but not in current rules)
                const removedFromRules = [...oldCaptions].filter(cap => !currentCaptions.has(cap));

                // Also check addedLegendCaptions for backwards compatibility
                const removedFromTracked = [...addedLegendCaptions.value].filter(cap => !currentCaptions.has(cap));

                // Combine both sets of removed captions
                const allRemovedCaptions = new Set([...removedFromRules, ...removedFromTracked]);

                // Remove legend entries for removed captions
                for (const cap of allRemovedCaptions) {
                    removeLegendEntry(cap);
                    addedLegendCaptions.value.delete(cap);
                }

                // DO NOT add legend entries here - that's handled by setFeatureColor
                // to avoid race conditions and duplicate entries
            }, { deep: true });

            // Function to apply style changes (stroke colors/widths) to SVG immediately
            const applyStylesToSvg = () => {
                if (!svgContent.value) return;
                if (!svgContainer.value) return;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                let updatedCount = 0;

                // Update block stroke (feature paths)
                if (adv.block_stroke_color || adv.block_stroke_width !== null) {
                    const featurePaths = svg.querySelectorAll('path[id^="f"]');
                    featurePaths.forEach(path => {
                        if (adv.block_stroke_color) {
                            path.setAttribute('stroke', adv.block_stroke_color);
                            updatedCount++;
                        }
                        if (adv.block_stroke_width !== null) {
                            path.setAttribute('stroke-width', adv.block_stroke_width);
                            updatedCount++;
                        }
                    });
                }

                // Update axis stroke
                const axisGroup = svg.getElementById('Axis');
                if (axisGroup) {
                    const axisElements = axisGroup.querySelectorAll('path, line, circle');
                    axisElements.forEach(el => {
                        if (adv.axis_stroke_color) {
                            el.setAttribute('stroke', adv.axis_stroke_color);
                            updatedCount++;
                        }
                        if (adv.axis_stroke_width !== null) {
                            el.setAttribute('stroke-width', adv.axis_stroke_width);
                            updatedCount++;
                        }
                    });
                }

                // Update tick stroke (same as axis typically)
                const tickGroup = svg.getElementById('tick');
                if (tickGroup) {
                    const tickElements = tickGroup.querySelectorAll('path, line');
                    tickElements.forEach(el => {
                        if (adv.axis_stroke_color) {
                            el.setAttribute('stroke', adv.axis_stroke_color);
                            updatedCount++;
                        }
                        if (adv.axis_stroke_width !== null) {
                            el.setAttribute('stroke-width', adv.axis_stroke_width);
                            updatedCount++;
                        }
                    });
                }

                // Update intron/line strokes (paths without fill or with fill="none")
                if (adv.line_stroke_color || adv.line_stroke_width !== null) {
                    // Find paths that are likely intron lines (no fill or fill=none, have stroke)
                    const allPaths = svg.querySelectorAll('path');
                    allPaths.forEach(path => {
                        const fill = path.getAttribute('fill');
                        const stroke = path.getAttribute('stroke');
                        const id = path.getAttribute('id') || '';
                        // Intron lines typically have no fill and are not feature blocks
                        if ((fill === 'none' || !fill) && stroke && !id.startsWith('f')) {
                            if (adv.line_stroke_color) {
                                path.setAttribute('stroke', adv.line_stroke_color);
                                updatedCount++;
                            }
                            if (adv.line_stroke_width !== null) {
                                path.setAttribute('stroke-width', adv.line_stroke_width);
                                updatedCount++;
                            }
                        }
                    });
                }

                // Update scale bar (linear mode)
                const lengthBarGroup = svg.getElementById('length_bar');
                if (lengthBarGroup) {
                    const scaleElements = lengthBarGroup.querySelectorAll('line, path');
                    scaleElements.forEach(el => {
                        if (adv.scale_stroke_color) {
                            el.setAttribute('stroke', adv.scale_stroke_color);
                            updatedCount++;
                        }
                        if (adv.scale_stroke_width !== null) {
                            el.setAttribute('stroke-width', adv.scale_stroke_width);
                            updatedCount++;
                        }
                    });
                }

                // Update legend color rectangles to match block stroke settings
                // Legend uses path elements for color swatches, not rect elements
                if (adv.block_stroke_color || adv.block_stroke_width !== null) {
                    // Find all feature legend groups (both vertical and horizontal)
                    const legendGroups = [];
                    const mainLegend = svg.getElementById('legend');
                    if (mainLegend) {
                        const featureLegend = mainLegend.querySelector('#feature_legend');
                        if (featureLegend) legendGroups.push(featureLegend);
                        else legendGroups.push(mainLegend);
                    }
                    // Also check for horizontal legend
                    const hLegend = svg.getElementById('horizontal_legend');
                    if (hLegend) {
                        const hFeatureLegend = hLegend.querySelector('#feature_legend');
                        if (hFeatureLegend) legendGroups.push(hFeatureLegend);
                    }
                    // Also check for vertical legend
                    const vLegend = svg.getElementById('vertical_legend');
                    if (vLegend) {
                        const vFeatureLegend = vLegend.querySelector('#feature_legend');
                        if (vFeatureLegend) legendGroups.push(vFeatureLegend);
                    }

                    legendGroups.forEach(legendGroup => {
                        // Legend color swatches are path elements with fill color and stroke
                        const paths = legendGroup.querySelectorAll('path');
                        paths.forEach(path => {
                            const fill = path.getAttribute('fill');
                            const stroke = path.getAttribute('stroke');
                            const d = path.getAttribute('d') || '';
                            // Color swatches have fill, stroke, and are small rectangles (d starts with M and has z)
                            // Exclude text paths (complex d attributes) and gradient-filled paths
                            if (fill && fill !== 'none' && fill !== 'white' && fill !== '#ffffff' &&
                                !fill.startsWith('url(') && stroke && d.includes('z') && d.split(' ').length < 20) {
                                if (adv.block_stroke_color) {
                                    path.setAttribute('stroke', adv.block_stroke_color);
                                    updatedCount++;
                                }
                                if (adv.block_stroke_width !== null) {
                                    path.setAttribute('stroke-width', adv.block_stroke_width);
                                    updatedCount++;
                                }
                            }
                        });
                    });
                }

                if (updatedCount > 0) {
                    skipCaptureBaseConfig.value = true;
                    const idx = selectedResultIndex.value;
                    if (idx >= 0 && results.value.length > idx) {
                        const serializer = new XMLSerializer();
                        results.value[idx] = { ...results.value[idx], content: serializer.serializeToString(svg) };
                    }
                    console.log(`Applied styles: updated ${updatedCount} elements`);
                }
            };

            // Watch for style changes
            watch(() => [
                adv.block_stroke_color, adv.block_stroke_width,
                adv.line_stroke_color, adv.line_stroke_width,
                adv.axis_stroke_color, adv.axis_stroke_width,
                adv.scale_stroke_color, adv.scale_stroke_width
            ], () => {
                applyStylesToSvg();
            });

            // Function to toggle track visibility
            const applyTrackVisibility = () => {
                if (!svgContent.value) return;
                if (!svgContainer.value) return;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                let updated = false;

                // GC content track - use querySelectorAll to find ALL gc_content groups (for multi-record linear diagrams)
                const gcContentGroups = svg.querySelectorAll('#gc_content, [id="gc_content"]');
                if (gcContentGroups.length > 0) {
                    const shouldHide = mode.value === 'circular' ? form.suppress_gc : !form.show_gc;
                    gcContentGroups.forEach(gcContentGroup => {
                        const currentDisplay = gcContentGroup.getAttribute('display');
                        if (shouldHide && currentDisplay !== 'none') {
                            gcContentGroup.setAttribute('display', 'none');
                            updated = true;
                        } else if (!shouldHide && currentDisplay === 'none') {
                            gcContentGroup.removeAttribute('display');
                            updated = true;
                        }
                    });
                }

                // GC skew track (circular: #skew, linear: #gc_skew) - use querySelectorAll for all groups
                const skewGroups = svg.querySelectorAll('#skew, [id="skew"], #gc_skew, [id="gc_skew"]');
                if (skewGroups.length > 0) {
                    const shouldHide = mode.value === 'circular' ? form.suppress_skew : !form.show_skew;
                    skewGroups.forEach(skewGroup => {
                        const currentDisplay = skewGroup.getAttribute('display');
                        if (shouldHide && currentDisplay !== 'none') {
                            skewGroup.setAttribute('display', 'none');
                            updated = true;
                        } else if (!shouldHide && currentDisplay === 'none') {
                            skewGroup.removeAttribute('display');
                            updated = true;
                        }
                    });
                }

                if (updated) {
                    skipCaptureBaseConfig.value = true;
                    const idx = selectedResultIndex.value;
                    if (idx >= 0 && results.value.length > idx) {
                        const serializer = new XMLSerializer();
                        results.value[idx] = { ...results.value[idx], content: serializer.serializeToString(svg) };
                    }
                    console.log('Track visibility updated');
                }
            };

            // Watch for track visibility changes
            watch(() => [form.suppress_gc, form.suppress_skew, form.show_gc, form.show_skew], () => {
                applyTrackVisibility();
            });

            // Function to add a legend entry dynamically using Pyodide
            const addLegendEntry = async (caption, color) => {
                console.log(`addLegendEntry called with caption="${caption}", color="${color}"`);
                if (!svgContainer.value || !pyodideReady.value) {
                    console.log(`addLegendEntry early return: svgContainer=${!!svgContainer.value}, pyodideReady=${pyodideReady.value}`);
                    return false;
                }

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return false;

                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) {
                    console.log('No legend group found');
                    return false;
                }

                // Get ALL feature legend groups (handles dual legends for linear mode)
                const allTargetGroups = getAllFeatureLegendGroups(svg);
                if (allTargetGroups.length === 0) {
                    console.log('No feature legend groups found');
                    return false;
                }

                // Use the first group to check existing entries (they should be in sync)
                const targetGroup = allTargetGroups[0];

                // Check existing legend entries
                const existingTexts = targetGroup.querySelectorAll('text');
                let finalCaption = caption.trim();

                // Check if exact caption exists
                for (const t of existingTexts) {
                    const existingCaption = t.textContent?.trim();
                    if (existingCaption === finalCaption) {
                        // Found exact match - check if color is the same
                        const transform = t.getAttribute('transform');
                        if (transform) {
                            const match = transform.match(/translate\([^,]+,\s*([\d.]+)\)/);
                            if (match) {
                                const y = match[1];
                                // Find the color rect at the same Y
                                const rects = targetGroup.querySelectorAll('path');
                                for (const r of rects) {
                                    const rt = r.getAttribute('transform');
                                    if (rt && rt.includes(`, ${y})`)) {
                                        const existingColor = r.getAttribute('fill');
                                        if (existingColor === color) {
                                            // Same caption, same color - no change needed
                                            console.log(`addLegendEntry: same caption and color already exist, returning: ${finalCaption}`);
                                            return finalCaption;
                                        }
                                        // Same caption, different color - need unique name
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                // Generate unique caption if needed (e.g., "hypothetical protein (1)")
                const baseCaption = finalCaption.replace(/\s*\(\d+\)$/, '');  // Remove existing (N) suffix
                let counter = 1;
                const existingCaptions = new Set();
                existingTexts.forEach(t => existingCaptions.add(t.textContent?.trim()));

                while (existingCaptions.has(finalCaption)) {
                    finalCaption = `${baseCaption} (${counter})`;
                    counter++;
                }

                // Update the caption parameter for the caller
                caption = finalCaption;

                // Detect rect_size from existing legend entries
                let rectSize = 14;  // Default
                const firstColorRect = targetGroup.querySelector('path[fill]:not([fill="none"]):not([fill^="url("])');
                if (firstColorRect) {
                    const d = firstColorRect.getAttribute('d');
                    if (d) {
                        // Parse path to extract rect size: M 0,-7 L 14,-7 L 14,7 L 0,7 z
                        const lMatch = d.match(/L\s+([\d.]+),/);
                        if (lMatch) {
                            rectSize = parseFloat(lMatch[1]);
                        }
                    }
                }

                // Detect font settings from existing text elements
                let fontSize = 14;
                let fontFamily = 'Arial';
                const firstText = targetGroup.querySelector('text');
                if (firstText) {
                    const fs = firstText.getAttribute('font-size');
                    if (fs) fontSize = parseFloat(fs);
                    const ff = firstText.getAttribute('font-family');
                    if (ff) fontFamily = ff;
                }

                const lineMargin = (24 / 14) * rectSize;
                const xMargin = (22 / 14) * rectSize;

                // Find max Y position in feature legend entries only (not background rect)
                let maxY = -lineMargin;  // Start at -lineMargin so first entry is at y=0
                const textElements = targetGroup.querySelectorAll('text');
                textElements.forEach(el => {
                    const transform = el.getAttribute('transform');
                    if (transform) {
                        const match = transform.match(/translate\([^,]+,\s*([\d.-]+)\)/);
                        if (match) {
                            const y = parseFloat(match[1]);
                            if (y > maxY) maxY = y;
                        }
                    }
                });

                // If no text elements found, check for paths with solid fills (entry rects)
                if (textElements.length === 0) {
                    const colorRects = targetGroup.querySelectorAll('path');
                    colorRects.forEach(el => {
                        const fill = el.getAttribute('fill');
                        if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                            const transform = el.getAttribute('transform');
                            if (transform) {
                                const match = transform.match(/translate\([^,]+,\s*([\d.-]+)\)/);
                                if (match) {
                                    const y = parseFloat(match[1]);
                                    if (y > maxY) maxY = y;
                                }
                            }
                        }
                    });
                }

                // Calculate new Y position
                const newY = maxY + lineMargin;

                try {
                    // Call Python to generate legend entry SVG with correct sizing and font settings
                    const escapedCaption = caption.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
                    const escapedFontFamily = fontFamily.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
                    const parser = new DOMParser();

                    // Helper to parse X and Y from transform
                    const parseTransformXY = (transform) => {
                        if (!transform) return { x: 0, y: 0 };
                        const match = transform.match(/translate\(\s*([\d.-]+)\s*,\s*([\d.-]+)\s*\)/);
                        return match ? { x: parseFloat(match[1]), y: parseFloat(match[2]) } : { x: 0, y: 0 };
                    };

                    // Estimate text width using Pyodide
                    let entryWidth = rectSize + xMargin + 100;  // Default estimate
                    try {
                        const widthResult = pyodide.runPython(`
import json
from gbdraw.core.text import calculate_bbox_dimensions
width, _ = calculate_bbox_dimensions("${escapedCaption}", "${escapedFontFamily}", ${fontSize}, 72)
json.dumps({"width": width})
`);
                        const widthData = JSON.parse(widthResult);
                        entryWidth = rectSize + xMargin + widthData.width + xMargin;
                    } catch (e) {
                        console.warn('Could not calculate text width, using estimate');
                    }

                    // Get canvas width for horizontal wrapping (fallback)
                    const viewBox = svg.getAttribute('viewBox');
                    let canvasWidth = 800;  // Default
                    if (viewBox) {
                        const parts = viewBox.split(/\s+/);
                        if (parts.length >= 4) canvasWidth = parseFloat(parts[2]);
                    }

                    // Add entry to ALL feature legend groups (handles dual legends)
                    for (const group of allTargetGroups) {
                        // Determine if this group is horizontal or vertical
                        const parentId = group.parentElement?.id || '';
                        const isHorizontalGroup = parentId === 'legend_horizontal';

                        let newX = 0, newY = 0;

                        if (isHorizontalGroup) {
                            // For horizontal layout, calculate available width for feature legend
                            // by checking if there's a pairwise legend beside it
                            let featureLegendMaxWidth = canvasWidth;
                            const horizontalLegend = legendGroup.querySelector('#legend_horizontal');
                            if (horizontalLegend) {
                                const hPairwiseLegend = horizontalLegend.querySelector('#pairwise_legend');
                                if (hPairwiseLegend) {
                                    // Get pairwise legend's X position - that's where feature legend should stop
                                    const pairwiseTransform = hPairwiseLegend.getAttribute('transform');
                                    if (pairwiseTransform) {
                                        const match = pairwiseTransform.match(/translate\(\s*([\d.-]+)\s*,/);
                                        if (match) {
                                            // Feature legend should wrap before reaching pairwise legend
                                            // Subtract some padding (xMargin) to leave space
                                            featureLegendMaxWidth = parseFloat(match[1]) - xMargin;
                                        }
                                    }
                                }
                            }

                            // Horizontal layout: find rightmost entry on the last row
                            // Entries are arranged left-to-right, wrapping to new rows
                            let maxY = rectSize / 2;  // Default first row Y
                            let maxXOnMaxY = 0;
                            let lastEntryRightEdge = 0;  // Track actual right edge of last entry

                            const groupTextElements = group.querySelectorAll('text');
                            groupTextElements.forEach(el => {
                                const pos = parseTransformXY(el.getAttribute('transform'));
                                if (pos.y > maxY) {
                                    maxY = pos.y;
                                    maxXOnMaxY = pos.x;
                                    // Calculate right edge: text X + text width + padding
                                    const textBBox = el.getBBox();
                                    lastEntryRightEdge = pos.x + textBBox.width + xMargin;
                                } else if (Math.abs(pos.y - maxY) < 1) {
                                    // Same row, track max X and right edge
                                    if (pos.x > maxXOnMaxY) {
                                        maxXOnMaxY = pos.x;
                                        const textBBox = el.getBBox();
                                        lastEntryRightEdge = pos.x + textBBox.width + xMargin;
                                    }
                                }
                            });

                            // If no text elements, check color rects
                            if (groupTextElements.length === 0) {
                                const colorRects = group.querySelectorAll('path');
                                colorRects.forEach(el => {
                                    const fill = el.getAttribute('fill');
                                    if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                                        const pos = parseTransformXY(el.getAttribute('transform'));
                                        if (pos.y > maxY) {
                                            maxY = pos.y;
                                            maxXOnMaxY = pos.x;
                                            lastEntryRightEdge = pos.x + rectSize + xMargin;
                                        } else if (Math.abs(pos.y - maxY) < 1) {
                                            if (pos.x > maxXOnMaxY) {
                                                maxXOnMaxY = pos.x + rectSize;
                                                lastEntryRightEdge = pos.x + rectSize + xMargin;
                                            }
                                        }
                                    }
                                });
                            }

                            // Calculate new position using actual right edge of last entry
                            let nextX = groupTextElements.length > 0 ? lastEntryRightEdge : 0;

                            // Check if we need to wrap to next row
                            // Use featureLegendMaxWidth (respects pairwise legend position)
                            if (nextX + entryWidth > featureLegendMaxWidth && nextX > 0) {
                                newX = 0;
                                newY = maxY + lineMargin;
                            } else {
                                newX = nextX;
                                newY = maxY;
                            }
                        } else {
                            // Vertical layout: existing behavior (stack vertically)
                            let groupMaxY = -lineMargin;
                            const groupTextElements = group.querySelectorAll('text');
                            groupTextElements.forEach(el => {
                                const pos = parseTransformXY(el.getAttribute('transform'));
                                if (pos.y > groupMaxY) groupMaxY = pos.y;
                            });

                            // If no text elements, check color rects
                            if (groupTextElements.length === 0) {
                                const colorRects = group.querySelectorAll('path');
                                colorRects.forEach(el => {
                                    const fill = el.getAttribute('fill');
                                    if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                                        const pos = parseTransformXY(el.getAttribute('transform'));
                                        if (pos.y > groupMaxY) groupMaxY = pos.y;
                                    }
                                });
                            }

                            newX = 0;
                            newY = groupMaxY + lineMargin;
                        }

                        // Generate SVG for this group's position
                        const resultJson = pyodide.runPython(`generate_legend_entry_svg("${escapedCaption}", "${color}", ${newY}, ${rectSize}, ${fontSize}, "${escapedFontFamily}", ${newX})`);
                        const result = JSON.parse(resultJson);

                        // Insert rect
                        const rectDoc = parser.parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${result.rect}</svg>`, 'image/svg+xml');
                        const rectEl = rectDoc.querySelector('path');
                        if (rectEl) {
                            group.appendChild(document.importNode(rectEl, true));
                        }

                        // Insert text
                        const textDoc = parser.parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${result.text}</svg>`, 'image/svg+xml');
                        const textEl = textDoc.querySelector('text');
                        if (textEl) {
                            group.appendChild(document.importNode(textEl, true));
                        }
                    }

                    // Reposition pairwise legend in vertical layout if needed
                    const verticalLegend = legendGroup.querySelector('#legend_vertical');
                    if (verticalLegend) {
                        const vFeatureLegend = verticalLegend.querySelector('#feature_legend');
                        const vPairwiseLegend = verticalLegend.querySelector('#pairwise_legend');

                        if (vFeatureLegend && vPairwiseLegend) {
                            // Calculate new feature legend height
                            let maxFeatureY = 0;
                            const featureTexts = vFeatureLegend.querySelectorAll('text');
                            featureTexts.forEach(el => {
                                const pos = parseTransformXY(el.getAttribute('transform'));
                                if (pos.y > maxFeatureY) maxFeatureY = pos.y;
                            });

                            // Calculate new pairwise legend position
                            // Backend uses: v_feature_height + self.line_height / 2
                            const newPairwiseY = maxFeatureY + lineMargin + lineMargin / 2;

                            // Get current pairwise transform to preserve X
                            const currentTransform = vPairwiseLegend.getAttribute('transform');
                            let pairwiseX = 0;
                            if (currentTransform) {
                                const match = currentTransform.match(/translate\(\s*([\d.-]+)\s*,/);
                                if (match) pairwiseX = parseFloat(match[1]);
                            }

                            vPairwiseLegend.setAttribute('transform', `translate(${pairwiseX}, ${newPairwiseY})`);
                            console.log(`Repositioned vertical pairwise legend to y=${newPairwiseY}`);
                        }
                    }

                    // Reposition pairwise legend in horizontal layout if needed (vertical centering)
                    const horizontalLegend = legendGroup.querySelector('#legend_horizontal');
                    if (horizontalLegend) {
                        const hFeatureLegend = horizontalLegend.querySelector('#feature_legend');
                        const hPairwiseLegend = horizontalLegend.querySelector('#pairwise_legend');

                        if (hFeatureLegend && hPairwiseLegend) {
                            // Calculate feature legend height (from rows)
                            let minFeatureY = Infinity, maxFeatureY = -Infinity;
                            const featureTexts = hFeatureLegend.querySelectorAll('text');
                            featureTexts.forEach(el => {
                                const pos = parseTransformXY(el.getAttribute('transform'));
                                if (pos.y < minFeatureY) minFeatureY = pos.y;
                                if (pos.y > maxFeatureY) maxFeatureY = pos.y;
                            });

                            if (minFeatureY !== Infinity && maxFeatureY !== -Infinity) {
                                const featureHeight = maxFeatureY - minFeatureY + lineMargin;

                                // Get pairwise legend height
                                const pairwiseBBox = hPairwiseLegend.getBBox();
                                const pairwiseHeight = pairwiseBBox.height;

                                // Get current pairwise transform to preserve X
                                const currentTransform = hPairwiseLegend.getAttribute('transform');
                                let pairwiseX = 0, currentPairwiseY = 0;
                                if (currentTransform) {
                                    const match = currentTransform.match(/translate\(\s*([\d.-]+)\s*,\s*([\d.-]+)\s*\)/);
                                    if (match) {
                                        pairwiseX = parseFloat(match[1]);
                                        currentPairwiseY = parseFloat(match[2]);
                                    }
                                }

                                // Vertically center pairwise legend with feature legend
                                // Backend: if h_feature_height > pairwise_height, offset pairwise by (h_feature_height - pairwise_height) / 2
                                let newPairwiseY = currentPairwiseY;
                                if (featureHeight > pairwiseHeight) {
                                    newPairwiseY = (featureHeight - pairwiseHeight) / 2;
                                }

                                hPairwiseLegend.setAttribute('transform', `translate(${pairwiseX}, ${newPairwiseY})`);
                                console.log(`Repositioned horizontal pairwise legend to y=${newPairwiseY}`);
                            }
                        }
                    }

                    // Update pairwise legend position after adding entry (before canvas expansion check)
                    updatePairwiseLegendPositions(svg);

                    // Note: expandCanvasForVerticalLegend is called by updatePairwiseLegendPositions

                    // Update results for reactivity
                    // Set flag to prevent captureBaseConfig from being called when svgContent watch triggers
                    skipCaptureBaseConfig.value = true;
                    const idx = selectedResultIndex.value;
                    if (idx >= 0 && results.value.length > idx) {
                        const serializer = new XMLSerializer();
                        results.value[idx] = { ...results.value[idx], content: serializer.serializeToString(svg) };
                    }

                    console.log(`Added legend entry: "${finalCaption}" to ${allTargetGroups.length} legend group(s)`);
                    return finalCaption;  // Return the actual caption used (may have (N) suffix)
                } catch (e) {
                    console.error('Failed to add legend entry:', e);
                    return false;
                }
            };

            // Helper function to get all feature legend groups (handles dual legends for linear mode)
            const getAllFeatureLegendGroups = (svg) => {
                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return [];

                const groups = [];

                // Check for dual legends (linear mode with both horizontal and vertical)
                const horizontalLegend = legendGroup.querySelector('#legend_horizontal');
                const verticalLegend = legendGroup.querySelector('#legend_vertical');

                if (horizontalLegend || verticalLegend) {
                    // Dual legend mode
                    if (horizontalLegend) {
                        const hFeature = horizontalLegend.querySelector('#feature_legend');
                        if (hFeature) groups.push(hFeature);
                    }
                    if (verticalLegend) {
                        const vFeature = verticalLegend.querySelector('#feature_legend');
                        if (vFeature) groups.push(vFeature);
                    }
                } else {
                    // Single legend mode (circular or old linear)
                    const featureLegendGroup = legendGroup.querySelector('#feature_legend');
                    groups.push(featureLegendGroup || legendGroup);
                }

                return groups;
            };

            // Get the visible (active) feature legend group for extraction
            const getVisibleFeatureLegendGroup = (svg) => {
                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return null;

                // Check for dual legends
                const horizontalLegend = legendGroup.querySelector('#legend_horizontal');
                const verticalLegend = legendGroup.querySelector('#legend_vertical');

                if (horizontalLegend && verticalLegend) {
                    // Return the visible one
                    const hVisible = horizontalLegend.style.display !== 'none' &&
                                    horizontalLegend.getAttribute('display') !== 'none';
                    const targetLegend = hVisible ? horizontalLegend : verticalLegend;
                    const featureGroup = targetLegend.querySelector('#feature_legend');
                    return featureGroup || targetLegend;
                }

                // Single legend mode
                const featureLegendGroup = legendGroup.querySelector('#feature_legend');
                return featureLegendGroup || legendGroup;
            };

            // Check if current legend layout is horizontal (top/bottom)
            const isCurrentLegendHorizontal = (svg) => {
                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return false;

                const horizontalLegend = legendGroup.querySelector('#legend_horizontal');
                const verticalLegend = legendGroup.querySelector('#legend_vertical');

                if (horizontalLegend && verticalLegend) {
                    const hVisible = horizontalLegend.style.display !== 'none' &&
                                    horizontalLegend.getAttribute('display') !== 'none';
                    return hVisible;
                }

                return false;  // Single legend mode (circular) is vertical
            };

            // Function to update legend entry color by caption (without removing)
            // Updates BOTH horizontal and vertical legends if they exist
            const updateLegendEntryColorByCaption = (caption, color) => {
                if (!svgContainer.value) return false;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return false;

                const targetGroups = getAllFeatureLegendGroups(svg);
                if (targetGroups.length === 0) return false;

                let updated = false;

                // Update in all legend groups
                for (const targetGroup of targetGroups) {
                    // Try new structure first: find entry group by data-legend-key
                    const entryGroup = targetGroup.querySelector(`g[data-legend-key="${CSS.escape(caption)}"]`);
                    if (entryGroup) {
                        // New structure: entry group contains rect path and text path
                        const paths = entryGroup.querySelectorAll('path');
                        for (const path of paths) {
                            const fill = path.getAttribute('fill');
                            if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                                path.setAttribute('fill', color);
                                updated = true;
                                break;
                            }
                        }
                    } else {
                        // Fallback: old structure - find text element and match by Y position
                        const getTransformY = (transform) => {
                            if (!transform) return null;
                            const match = transform.match(/translate\(\s*[\d.-]+\s*,\s*([\d.-]+)\s*\)/);
                            return match ? parseFloat(match[1]) : null;
                        };

                        const texts = targetGroup.querySelectorAll('text');
                        for (const t of texts) {
                            if (t.textContent?.trim() === caption.trim()) {
                                const textY = getTransformY(t.getAttribute('transform'));
                                if (textY !== null) {
                                    const rects = targetGroup.querySelectorAll('path');
                                    for (const r of rects) {
                                        const rectY = getTransformY(r.getAttribute('transform'));
                                        if (rectY !== null && Math.abs(rectY - textY) < 0.1) {
                                            const fill = r.getAttribute('fill');
                                            if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                                                r.setAttribute('fill', color);
                                                updated = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                                break;
                            }
                        }
                    }
                }

                if (updated) {
                    // Save to results
                    skipCaptureBaseConfig.value = true;
                    const idx = selectedResultIndex.value;
                    if (idx >= 0 && results.value.length > idx) {
                        const serializer = new XMLSerializer();
                        results.value[idx] = { ...results.value[idx], content: serializer.serializeToString(svg) };
                    }
                    console.log(`Updated legend entry color: "${caption}" to ${color}`);
                }

                return updated;
            };

            // Function to check if a legend entry exists with given caption
            const legendEntryExists = (caption) => {
                if (!svgContainer.value) return false;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return false;

                // Check all legend groups (handles dual legends)
                const targetGroups = getAllFeatureLegendGroups(svg);
                if (targetGroups.length === 0) return false;

                // Check the first group (they should be in sync)
                const targetGroup = targetGroups[0];

                const texts = targetGroup.querySelectorAll('text');
                for (const t of texts) {
                    if (t.textContent?.trim() === caption.trim()) {
                        return true;
                    }
                }
                return false;
            };

            // Helper to parse Y coordinate from transform attribute
            const parseTransformY = (transform) => {
                if (!transform) return null;
                // Match both "translate(x, y)" and "translate(x,y)" formats
                const match = transform.match(/translate\(\s*[\d.-]+\s*,\s*([\d.-]+)\s*\)/);
                return match ? parseFloat(match[1]) : null;
            };

            // Helper to parse both X and Y from transform attribute
            const parseTransformXY = (transform) => {
                if (!transform) return { x: 0, y: 0 };
                const match = transform.match(/translate\(\s*([\d.-]+)\s*,\s*([\d.-]+)\s*\)/);
                return match ? { x: parseFloat(match[1]), y: parseFloat(match[2]) } : { x: 0, y: 0 };
            };

            // Function to remove a legend entry by caption
            // Removes from BOTH horizontal and vertical legends if they exist
            const removeLegendEntry = (caption) => {
                if (!svgContainer.value) return false;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return false;

                const targetGroups = getAllFeatureLegendGroups(svg);
                if (targetGroups.length === 0) return false;

                let removed = false;

                // Remove from all legend groups
                for (const targetGroup of targetGroups) {
                    // Detect rect_size from existing entries to calculate text_x_offset
                    let rectSize = 14;
                    const firstColorRect = targetGroup.querySelector('path[fill]:not([fill="none"]):not([fill^="url("])');
                    if (firstColorRect) {
                        const d = firstColorRect.getAttribute('d');
                        if (d) {
                            const lMatch = d.match(/L\s+([\d.]+),/);
                            if (lMatch) rectSize = parseFloat(lMatch[1]);
                        }
                    }
                    const textXOffset = (22 / 14) * rectSize;

                    // Find text element with this caption
                    const texts = targetGroup.querySelectorAll('text');

                    texts.forEach(t => {
                        if (t.textContent?.trim() === caption.trim()) {
                            // Use X+Y coordinate matching (same as extractLegendEntries)
                            const textTransform = parseTransformXY(t.getAttribute('transform'));
                            const textX = textTransform.x;
                            const textY = textTransform.y;

                            // Find and remove the color rect at the correct X+Y position
                            const rects = targetGroup.querySelectorAll('path');
                            const expectedRectX = textX - textXOffset;

                            rects.forEach(r => {
                                const rectTransform = parseTransformXY(r.getAttribute('transform'));
                                const rectX = rectTransform.x;
                                const rectY = rectTransform.y;

                                // Check both Y matches AND X position is correct for this text
                                if (Math.abs(rectY - textY) < 1 && Math.abs(rectX - expectedRectX) < textXOffset) {
                                    // Make sure it's a color rect (has solid fill, not gradient)
                                    const fill = r.getAttribute('fill');
                                    if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                                        r.remove();
                                    }
                                }
                            });

                            t.remove();
                            removed = true;
                        }
                    });
                }

                if (removed) {
                    // Compact remaining entries to fill gaps
                    compactLegendEntries(svg);

                    skipCaptureBaseConfig.value = true;
                    const idx = selectedResultIndex.value;
                    if (idx >= 0 && results.value.length > idx) {
                        const serializer = new XMLSerializer();
                        results.value[idx] = { ...results.value[idx], content: serializer.serializeToString(svg) };
                    }
                    console.log(`Removed legend entry: "${caption}"`);
                }

                return removed;
            };

            // Expand canvas height if vertical legend exceeds canvas
            const expandCanvasForVerticalLegend = (svg) => {
                // Only expand for linear mode with vertical legend visible
                if (mode.value !== 'linear') return;
                if (isCurrentLegendHorizontal(svg)) return;

                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return;

                // Get vertical legend dimensions
                const verticalLegend = legendGroup.querySelector('#legend_vertical');
                if (!verticalLegend || verticalLegend.getAttribute('display') === 'none') return;

                // Get legend group's Y position in canvas
                let legendGroupY = 0;
                const legendGroupTransform = legendGroup.getAttribute('transform');
                if (legendGroupTransform) {
                    const match = legendGroupTransform.match(/translate\(\s*([\d.-]+)\s*,\s*([\d.-]+)\s*\)/);
                    if (match) legendGroupY = parseFloat(match[2]);
                }

                // Calculate total legend content height by measuring feature + pairwise legend
                const featureLegend = verticalLegend.querySelector('#feature_legend');
                const pairwiseLegend = verticalLegend.querySelector('#pairwise_legend');

                let legendContentHeight = 0;
                if (featureLegend) {
                    const featureBBox = featureLegend.getBBox();
                    legendContentHeight = featureBBox.y + featureBBox.height;
                }

                if (pairwiseLegend) {
                    // Get pairwise legend position and height
                    const pairwiseTransform = pairwiseLegend.getAttribute('transform');
                    let pairwiseY = 0;
                    if (pairwiseTransform) {
                        const match = pairwiseTransform.match(/translate\(\s*([\d.-]+)\s*,\s*([\d.-]+)\s*\)/);
                        if (match) pairwiseY = parseFloat(match[2]);
                    }
                    const pairwiseBBox = pairwiseLegend.getBBox();
                    const pairwiseBottom = pairwiseY + pairwiseBBox.y + pairwiseBBox.height;
                    legendContentHeight = Math.max(legendContentHeight, pairwiseBottom);
                }

                // Get current viewBox
                const viewBox = svg.getAttribute('viewBox');
                if (!viewBox) return;
                const parts = viewBox.split(/\s+/).map(parseFloat);
                if (parts.length !== 4) return;
                let [vbX, vbY, vbW, vbH] = parts;

                // Calculate the bottom edge of the legend in canvas coordinates
                const legendBottomEdge = legendGroupY + legendContentHeight;
                const bottomPadding = 20;  // Padding from canvas edge

                console.log(`Canvas expansion check: legendGroupY=${legendGroupY.toFixed(1)}, legendContentHeight=${legendContentHeight.toFixed(1)}, legendBottomEdge=${legendBottomEdge.toFixed(1)}, vbH=${vbH.toFixed(1)}`);

                // Check if expansion needed (legend bottom + padding exceeds canvas)
                if (legendBottomEdge + bottomPadding > vbH) {
                    const newVbH = legendBottomEdge + bottomPadding;
                    console.log(`Expanding canvas for vertical legend: ${vbH.toFixed(1)} -> ${newVbH.toFixed(1)}`);

                    // Just expand viewBox - don't shift diagram elements (keeps diagram in place)
                    svg.setAttribute('viewBox', `${vbX} ${vbY} ${vbW} ${newVbH}`);
                }
            };

            // Update pairwise legend positions after feature legend changes
            const updatePairwiseLegendPositions = (svg) => {
                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return;

                // Detect rect_size and line_height from existing entries
                let rectSize = 14;
                const firstColorRect = legendGroup.querySelector('path[fill]:not([fill="none"]):not([fill^="url("])');
                if (firstColorRect) {
                    const d = firstColorRect.getAttribute('d');
                    if (d) {
                        const lMatch = d.match(/L\s+([\d.]+),/);
                        if (lMatch) rectSize = parseFloat(lMatch[1]);
                    }
                }
                const lineMargin = (24 / 14) * rectSize;

                // Reposition pairwise legend in vertical layout
                const verticalLegend = legendGroup.querySelector('#legend_vertical');
                if (verticalLegend) {
                    const vFeatureLegend = verticalLegend.querySelector('#feature_legend');
                    const vPairwiseLegend = verticalLegend.querySelector('#pairwise_legend');

                    if (vFeatureLegend && vPairwiseLegend) {
                        // Calculate new feature legend height
                        let maxFeatureY = 0;
                        const featureTexts = vFeatureLegend.querySelectorAll('text');
                        featureTexts.forEach(el => {
                            const pos = parseTransformXY(el.getAttribute('transform'));
                            if (pos.y > maxFeatureY) maxFeatureY = pos.y;
                        });

                        // Calculate new pairwise legend position
                        const newPairwiseY = maxFeatureY + lineMargin + lineMargin / 2;

                        // Get current pairwise transform to preserve X
                        const currentTransform = vPairwiseLegend.getAttribute('transform');
                        let pairwiseX = 0;
                        if (currentTransform) {
                            const match = currentTransform.match(/translate\(\s*([\d.-]+)\s*,/);
                            if (match) pairwiseX = parseFloat(match[1]);
                        }

                        vPairwiseLegend.setAttribute('transform', `translate(${pairwiseX}, ${newPairwiseY})`);
                        console.log(`Repositioned vertical pairwise legend to y=${newPairwiseY}`);
                    }
                }

                // Reposition pairwise legend in horizontal layout (vertical centering)
                const horizontalLegend = legendGroup.querySelector('#legend_horizontal');
                if (horizontalLegend) {
                    const hFeatureLegend = horizontalLegend.querySelector('#feature_legend');
                    const hPairwiseLegend = horizontalLegend.querySelector('#pairwise_legend');

                    if (hFeatureLegend && hPairwiseLegend) {
                        // Calculate feature legend height (from rows)
                        let minFeatureY = Infinity, maxFeatureY = -Infinity;
                        const featureTexts = hFeatureLegend.querySelectorAll('text');
                        featureTexts.forEach(el => {
                            const pos = parseTransformXY(el.getAttribute('transform'));
                            if (pos.y < minFeatureY) minFeatureY = pos.y;
                            if (pos.y > maxFeatureY) maxFeatureY = pos.y;
                        });

                        if (minFeatureY !== Infinity && maxFeatureY !== -Infinity) {
                            const featureHeight = maxFeatureY - minFeatureY + lineMargin;

                            // Get pairwise legend height
                            const pairwiseBBox = hPairwiseLegend.getBBox();
                            const pairwiseHeight = pairwiseBBox.height;

                            // Get current pairwise transform to preserve X
                            const currentTransform = hPairwiseLegend.getAttribute('transform');
                            let pairwiseX = 0, currentPairwiseY = 0;
                            if (currentTransform) {
                                const match = currentTransform.match(/translate\(\s*([\d.-]+)\s*,\s*([\d.-]+)\s*\)/);
                                if (match) {
                                    pairwiseX = parseFloat(match[1]);
                                    currentPairwiseY = parseFloat(match[2]);
                                }
                            }

                            // Vertically center pairwise legend with feature legend
                            let newPairwiseY = currentPairwiseY;
                            if (featureHeight > pairwiseHeight) {
                                newPairwiseY = (featureHeight - pairwiseHeight) / 2;
                            }

                            hPairwiseLegend.setAttribute('transform', `translate(${pairwiseX}, ${newPairwiseY})`);
                            console.log(`Repositioned horizontal pairwise legend to y=${newPairwiseY}`);
                        }
                    }
                }

                // After repositioning, check if canvas needs expansion
                expandCanvasForVerticalLegend(svg);
            };

            // Compact legend entries after deletion to remove gaps
            const compactLegendEntries = (svg) => {
                const targetGroups = getAllFeatureLegendGroups(svg);
                if (targetGroups.length === 0) return;

                for (const targetGroup of targetGroups) {
                    // Detect rect_size and line_height from existing entries
                    let rectSize = 14;
                    const firstColorRect = targetGroup.querySelector('path[fill]:not([fill="none"]):not([fill^="url("])');
                    if (firstColorRect) {
                        const d = firstColorRect.getAttribute('d');
                        if (d) {
                            const lMatch = d.match(/L\s+([\d.]+),/);
                            if (lMatch) rectSize = parseFloat(lMatch[1]);
                        }
                    }
                    const lineHeight = (24 / 14) * rectSize;
                    const textXOffset = (22 / 14) * rectSize;

                    // Get all text elements and their positions
                    const texts = Array.from(targetGroup.querySelectorAll('text'));
                    if (texts.length === 0) continue;

                    // Get all color rects
                    const allRects = Array.from(targetGroup.querySelectorAll('path')).filter(r => {
                        const fill = r.getAttribute('fill');
                        return fill && fill !== 'none' && !fill.startsWith('url(');
                    });

                    // Get positions and find matching rect for each text BEFORE any moves
                    const entries = texts.map(t => {
                        const pos = parseTransformXY(t.getAttribute('transform'));
                        // Find matching rect by position (before any moves happen)
                        const expectedRectX = pos.x - textXOffset;
                        let matchedRect = null;
                        let bestDistance = Infinity;
                        for (const r of allRects) {
                            const rectPos = parseTransformXY(r.getAttribute('transform'));
                            if (Math.abs(rectPos.y - pos.y) < 1) {
                                const distance = Math.abs(rectPos.x - expectedRectX);
                                if (distance < textXOffset && distance < bestDistance) {
                                    bestDistance = distance;
                                    matchedRect = r;
                                }
                            }
                        }
                        return { text: t, rect: matchedRect, x: pos.x, y: pos.y };
                    });

                    // Detect if horizontal or vertical layout
                    const uniqueYs = [...new Set(entries.map(e => Math.round(e.y)))];
                    const isHorizontal = uniqueYs.length < entries.length; // Multiple entries per row = horizontal

                    if (isHorizontal) {
                        // Horizontal layout: re-flow all entries to fill gaps
                        // Sort by original position (Y then X) to maintain order
                        entries.sort((a, b) => {
                            if (Math.abs(a.y - b.y) < 1) return a.x - b.x;
                            return a.y - b.y;
                        });

                        // Get max width from pairwise legend position or canvas
                        let maxWidth = 800;  // Default fallback
                        const legendGroup = svg.getElementById('legend');
                        if (legendGroup) {
                            const horizontalLegend = legendGroup.querySelector('#legend_horizontal');
                            if (horizontalLegend) {
                                const hPairwiseLegend = horizontalLegend.querySelector('#pairwise_legend');
                                if (hPairwiseLegend) {
                                    const pairwiseTransform = hPairwiseLegend.getAttribute('transform');
                                    if (pairwiseTransform) {
                                        const match = pairwiseTransform.match(/translate\(\s*([\d.-]+)\s*,/);
                                        if (match) {
                                            maxWidth = parseFloat(match[1]) - textXOffset;
                                        }
                                    }
                                } else {
                                    // No pairwise, use canvas width from viewBox
                                    const viewBox = svg.getAttribute('viewBox');
                                    if (viewBox) {
                                        const parts = viewBox.split(/\s+/).map(parseFloat);
                                        if (parts.length === 4) maxWidth = parts[2] - textXOffset;
                                    }
                                }
                            }
                        }

                        // Re-flow entries: place each entry, wrap to next row if needed
                        let newX = textXOffset;
                        let newY = rectSize / 2;

                        entries.forEach(entry => {
                            // Calculate width of this entry
                            const textBBox = entry.text.getBBox();
                            const entryWidth = rectSize + textXOffset + textBBox.width + textXOffset;

                            // Check if entry fits on current row
                            if (newX + entryWidth > maxWidth && newX > textXOffset) {
                                // Wrap to next row
                                newX = textXOffset;
                                newY += lineHeight;
                            }

                            // Move text
                            entry.text.setAttribute('transform', `translate(${newX}, ${newY})`);

                            // Move pre-captured rect (no searching needed)
                            if (entry.rect) {
                                const expectedRectX = newX - textXOffset;
                                entry.rect.setAttribute('transform', `translate(${expectedRectX}, ${newY})`);
                            }

                            newX += entryWidth;
                        });
                    } else {
                        // Vertical layout: sort by Y, compact
                        entries.sort((a, b) => a.y - b.y);

                        let newY = rectSize / 2;
                        entries.forEach(entry => {
                            // Move text
                            entry.text.setAttribute('transform', `translate(${textXOffset}, ${newY})`);

                            // Move pre-captured rect (no searching needed)
                            if (entry.rect) {
                                entry.rect.setAttribute('transform', `translate(0, ${newY})`);
                            }

                            newY += lineHeight;
                        });
                    }
                }

                // Update pairwise legend position after compaction
                updatePairwiseLegendPositions(svg);
            };

            // Extract legend entries from current SVG for the Legend Editor panel
            // Uses the visible (active) legend group for extraction
            const extractLegendEntries = () => {
                if (!svgContainer.value) {
                    legendEntries.value = [];
                    return;
                }

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) {
                    legendEntries.value = [];
                    return;
                }

                const targetGroup = getVisibleFeatureLegendGroup(svg);
                if (!targetGroup) {
                    legendEntries.value = [];
                    return;
                }

                const entries = [];

                // Helper to parse X and Y from transform
                const parseTransform = (transform) => {
                    if (!transform) return { x: 0, y: 0 };
                    const match = transform.match(/translate\(\s*([\d.-]+)\s*,\s*([\d.-]+)\s*\)/);
                    return match ? { x: parseFloat(match[1]), y: parseFloat(match[2]) } : { x: 0, y: 0 };
                };

                // Detect rect_size from existing entries to calculate text_x_offset
                let rectSize = 14;
                const firstColorRect = targetGroup.querySelector('path[fill]:not([fill="none"]):not([fill^="url("])');
                if (firstColorRect) {
                    const d = firstColorRect.getAttribute('d');
                    if (d) {
                        const lMatch = d.match(/L\s+([\d.]+),/);
                        if (lMatch) rectSize = parseFloat(lMatch[1]);
                    }
                }
                const textXOffset = (22 / 14) * rectSize;

                // Find all text elements in legend (these are the captions)
                const textElements = targetGroup.querySelectorAll('text');
                textElements.forEach(textEl => {
                    const caption = textEl.textContent?.trim();
                    if (!caption) return;

                    const textTransform = parseTransform(textEl.getAttribute('transform'));
                    const xPos = textTransform.x;
                    const yPos = textTransform.y;

                    // Find the color rect matching this text element
                    // For vertical layout: same Y, rect X â‰ˆ 0
                    // For horizontal layout: same Y, rect X â‰ˆ text X - textXOffset
                    let color = '#cccccc';
                    const paths = targetGroup.querySelectorAll('path');
                    let bestMatch = null;
                    let bestDistance = Infinity;

                    paths.forEach(p => {
                        const fill = p.getAttribute('fill');
                        if (!fill || fill === 'none' || fill.startsWith('url(')) return;

                        const rectTransform = parseTransform(p.getAttribute('transform'));
                        const rectX = rectTransform.x;
                        const rectY = rectTransform.y;

                        // Check if Y positions match (within tolerance)
                        if (Math.abs(rectY - yPos) < 1) {
                            // Calculate expected rect X position based on text X
                            const expectedRectX = xPos - textXOffset;
                            const distance = Math.abs(rectX - expectedRectX);

                            // Find the closest matching rect
                            if (distance < bestDistance) {
                                bestDistance = distance;
                                bestMatch = fill;
                            }
                        }
                    });

                    if (bestMatch) {
                        color = bestMatch;
                    }

                    // Preserve state from existing entry with same caption
                    const existingEntry = legendEntries.value.find(e => e.caption === caption);
                    const showStroke = existingEntry?.showStroke || false;
                    // Preserve featureIds if they exist, otherwise they'll be built later
                    const existingFeatureIds = existingEntry?.featureIds || [];
                    // Use existing originalCaption if available, otherwise set it to current caption
                    const originalCaption = existingEntry?.originalCaption || caption;

                    entries.push({ caption, originalCaption, color, xPos, yPos, showStroke, featureIds: existingFeatureIds });
                });

                // Sort by Y position first, then by X position (for horizontal layout)
                entries.sort((a, b) => {
                    if (Math.abs(a.yPos - b.yPos) < 1) {
                        return a.xPos - b.xPos;  // Same row, sort by X
                    }
                    return a.yPos - b.yPos;
                });

                // Build feature-to-legend mapping based on current SVG colors
                // This links features to their legend entries by matching fill color
                // Always rebuild to ensure the mapping reflects current state (e.g., after color changes)
                if (extractedFeatures.value.length > 0) {
                    for (const entry of entries) {
                        const matchingFeatures = extractedFeatures.value.filter(f => {
                            const el = svg.querySelector(`#${CSS.escape(f.svg_id)}`);
                            if (!el) return false;
                            const fillColor = el.getAttribute('fill');
                            return fillColor && fillColor.toLowerCase() === entry.color.toLowerCase();
                        });
                        entry.featureIds = matchingFeatures.map(f => f.svg_id);
                    }
                }

                legendEntries.value = entries;

                // Store original order and colors if this is the first extraction (after diagram generation)
                if (originalLegendOrder.value.length === 0 && entries.length > 0) {
                    originalLegendOrder.value = entries.map(e => e.caption);
                    // Store original colors for each legend entry
                    entries.forEach(e => {
                        if (!originalLegendColors.value[e.caption]) {
                            originalLegendColors.value[e.caption] = e.color;
                        }
                    });
                }
            };

            // Update legend entry color
            // Updates BOTH horizontal and vertical legends if they exist
            const updateLegendEntryColor = (idx, newColor) => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                const entry = legendEntries.value[idx];
                if (!entry) return;

                const targetGroups = getAllFeatureLegendGroups(svg);
                if (targetGroups.length === 0) return;

                // Update in all legend groups
                for (const targetGroup of targetGroups) {
                    // Try new structure first: find entry group by data-legend-key
                    const entryGroup = targetGroup.querySelector(`g[data-legend-key="${CSS.escape(entry.caption)}"]`);
                    if (entryGroup) {
                        // New structure: entry group contains rect path and text path
                        const paths = entryGroup.querySelectorAll('path');
                        for (const path of paths) {
                            const fill = path.getAttribute('fill');
                            if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                                path.setAttribute('fill', newColor);
                                break;
                            }
                        }
                    } else {
                        // Fallback: old structure - find text element and match by Y position
                        const texts = targetGroup.querySelectorAll('text');
                        for (const t of texts) {
                            if (t.textContent?.trim() === entry.caption.trim()) {
                                const transform = t.getAttribute('transform');
                                if (transform) {
                                    const match = transform.match(/translate\([^,]+,\s*([\d.-]+)\)/);
                                    if (match) {
                                        const textY = parseFloat(match[1]);
                                        const paths = targetGroup.querySelectorAll('path');
                                        paths.forEach(p => {
                                            const pt = p.getAttribute('transform');
                                            if (pt) {
                                                const pMatch = pt.match(/translate\([^,]+,\s*([\d.-]+)\)/);
                                                if (pMatch && Math.abs(parseFloat(pMatch[1]) - textY) < 1) {
                                                    const fill = p.getAttribute('fill');
                                                    if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                                                        p.setAttribute('fill', newColor);
                                                    }
                                                }
                                            }
                                        });
                                    }
                                }
                                break;
                            }
                        }
                    }
                }

                // Update local state
                legendEntries.value[idx].color = newColor;

                // Track this as a custom color override (protects from palette updates)
                legendColorOverrides[entry.caption] = newColor;

                // Save to results
                skipCaptureBaseConfig.value = true;
                const resultIdx = selectedResultIndex.value;
                if (resultIdx >= 0 && results.value.length > resultIdx) {
                    const serializer = new XMLSerializer();
                    results.value[resultIdx] = { ...results.value[resultIdx], content: serializer.serializeToString(svg) };
                }
            };

            // Update legend entry caption
            // Updates BOTH horizontal and vertical legends if they exist
            // Also updates manualSpecificRules and legendStrokeOverrides to maintain linkage
            const updateLegendEntryCaption = (idx, newCaption) => {
                if (!svgContainer.value || !newCaption.trim()) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                const entry = legendEntries.value[idx];
                if (!entry) return;

                const oldCaption = entry.caption;
                if (oldCaption === newCaption) return; // No change needed

                const targetGroups = getAllFeatureLegendGroups(svg);
                if (targetGroups.length === 0) return;

                // Update in all legend groups
                for (const targetGroup of targetGroups) {
                    // Try new structure first: find entry group by data-legend-key
                    const entryGroup = targetGroup.querySelector(`g[data-legend-key="${CSS.escape(oldCaption)}"]`);
                    if (entryGroup) {
                        // Update the data-legend-key attribute
                        entryGroup.setAttribute('data-legend-key', newCaption);
                        // Update text content within the entry group
                        const texts = entryGroup.querySelectorAll('text');
                        texts.forEach(t => {
                            if (t.textContent?.trim() === oldCaption.trim()) {
                                t.textContent = newCaption;
                            }
                        });
                    } else {
                        // Fallback: old structure - just update text
                        const texts = targetGroup.querySelectorAll('text');
                        texts.forEach(t => {
                            if (t.textContent?.trim() === oldCaption.trim()) {
                                t.textContent = newCaption;
                            }
                        });
                    }
                }

                // Update manualSpecificRules to maintain feature-legend linkage
                for (const rule of manualSpecificRules) {
                    if (rule.cap === oldCaption) {
                        rule.cap = newCaption;
                    }
                }

                // Update featureColorOverrides to maintain feature-legend linkage
                for (const key of Object.keys(featureColorOverrides)) {
                    if (featureColorOverrides[key].caption === oldCaption) {
                        featureColorOverrides[key].caption = newCaption;
                    }
                }

                // Update legendStrokeOverrides key if it exists
                if (legendStrokeOverrides[oldCaption]) {
                    legendStrokeOverrides[newCaption] = legendStrokeOverrides[oldCaption];
                    delete legendStrokeOverrides[oldCaption];
                }

                // Update legendColorOverrides key if it exists
                if (legendColorOverrides[oldCaption]) {
                    legendColorOverrides[newCaption] = legendColorOverrides[oldCaption];
                    delete legendColorOverrides[oldCaption];
                }

                // Update addedLegendCaptions set if needed
                if (addedLegendCaptions.value.has(oldCaption)) {
                    addedLegendCaptions.value.delete(oldCaption);
                    addedLegendCaptions.value.add(newCaption);
                }

                // Update local state
                legendEntries.value[idx].caption = newCaption;

                // Save to results
                skipCaptureBaseConfig.value = true;
                const resultIdx = selectedResultIndex.value;
                if (resultIdx >= 0 && results.value.length > resultIdx) {
                    const serializer = new XMLSerializer();
                    results.value[resultIdx] = { ...results.value[resultIdx], content: serializer.serializeToString(svg) };
                }
            };

            // Get stroke color for a legend entry (from overrides or from SVG default)
            const getLegendEntryStrokeColor = (idx) => {
                const entry = legendEntries.value[idx];
                if (!entry) return '#000000';
                const override = legendStrokeOverrides[entry.caption];
                if (override?.strokeColor) return override.strokeColor;
                // Return original if stored, otherwise default black
                return override?.originalStrokeColor || '#000000';
            };

            // Get stroke width for a legend entry
            const getLegendEntryStrokeWidth = (idx) => {
                const entry = legendEntries.value[idx];
                if (!entry) return '';
                const override = legendStrokeOverrides[entry.caption];
                if (override?.strokeWidth !== undefined && override?.strokeWidth !== null) return override.strokeWidth;
                // Return original if stored
                return override?.originalStrokeWidth ?? '';
            };

            // Update stroke color for a legend entry and apply to matching features
            const updateLegendEntryStrokeColor = (idx, color) => {
                const entry = legendEntries.value[idx];
                if (!entry) return;

                // Initialize override if not exists (capture original values)
                if (!legendStrokeOverrides[entry.caption]) {
                    const originalValues = captureOriginalStrokeValues(entry.caption);
                    legendStrokeOverrides[entry.caption] = {
                        originalStrokeColor: originalValues.strokeColor,
                        originalStrokeWidth: originalValues.strokeWidth
                    };
                }
                legendStrokeOverrides[entry.caption].strokeColor = color;

                // Apply to SVG features
                applyStrokeToFeaturesByCaption(entry.caption, color, null);
            };

            // Update stroke width for a legend entry and apply to matching features
            const updateLegendEntryStrokeWidth = (idx, width) => {
                const entry = legendEntries.value[idx];
                if (!entry) return;

                const widthVal = width === '' ? null : parseFloat(width);

                // Initialize override if not exists
                if (!legendStrokeOverrides[entry.caption]) {
                    const originalValues = captureOriginalStrokeValues(entry.caption);
                    legendStrokeOverrides[entry.caption] = {
                        originalStrokeColor: originalValues.strokeColor,
                        originalStrokeWidth: originalValues.strokeWidth
                    };
                }
                legendStrokeOverrides[entry.caption].strokeWidth = widthVal;

                // Apply to SVG features
                applyStrokeToFeaturesByCaption(entry.caption, null, widthVal);
            };

            // Reset stroke for a legend entry to original values
            const resetLegendEntryStroke = (idx) => {
                const entry = legendEntries.value[idx];
                if (!entry) return;
                if (!svgContainer.value) return;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                // Get original stroke values (can be null)
                const originalColor = originalSvgStroke.value.color;
                const originalWidth = originalSvgStroke.value.width;
                let updatedCount = 0;

                // Primary method: use featureIds from legend entry
                if (entry.featureIds && entry.featureIds.length > 0) {
                    for (const svgId of entry.featureIds) {
                        const elements = svg.querySelectorAll(`#${CSS.escape(svgId)}`);
                        elements.forEach(el => {
                            if (originalColor === null) {
                                el.removeAttribute('stroke');
                            } else {
                                el.setAttribute('stroke', originalColor);
                            }
                            if (originalWidth === null) {
                                el.removeAttribute('stroke-width');
                            } else {
                                el.setAttribute('stroke-width', originalWidth);
                            }
                            updatedCount++;
                        });
                    }
                } else {
                    // Fallback: match by fill color
                    const legendFillColor = entry.color;
                    if (legendFillColor) {
                        const normalizedColor = legendFillColor.toLowerCase();
                        const featurePaths = svg.querySelectorAll('path[id^="f"]');
                        featurePaths.forEach(path => {
                            const fill = path.getAttribute('fill');
                            if (fill && fill.toLowerCase() === normalizedColor) {
                                if (originalColor === null) {
                                    path.removeAttribute('stroke');
                                } else {
                                    path.setAttribute('stroke', originalColor);
                                }
                                if (originalWidth === null) {
                                    path.removeAttribute('stroke-width');
                                } else {
                                    path.setAttribute('stroke-width', originalWidth);
                                }
                                updatedCount++;
                            }
                        });
                    }
                }

                // Remove override
                delete legendStrokeOverrides[entry.caption];

                // Save to results
                if (updatedCount > 0) {
                    skipCaptureBaseConfig.value = true;
                    const resultIdx = selectedResultIndex.value;
                    if (resultIdx >= 0 && results.value.length > resultIdx) {
                        const serializer = new XMLSerializer();
                        results.value[resultIdx] = { ...results.value[resultIdx], content: serializer.serializeToString(svg) };
                    }
                }
            };

            // Reset ALL strokes to original values (gbdraw's auto-determined defaults)
            const resetAllStrokes = () => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                // Get original stroke values captured from SVG generation (can be null)
                const originalColor = originalSvgStroke.value.color;
                const originalWidth = originalSvgStroke.value.width;

                // Reset all feature paths
                const featurePaths = svg.querySelectorAll('path[id^="f"]');
                let updatedCount = 0;
                featurePaths.forEach(path => {
                    if (originalColor === null) {
                        path.removeAttribute('stroke');
                    } else {
                        path.setAttribute('stroke', originalColor);
                    }
                    if (originalWidth === null) {
                        path.removeAttribute('stroke-width');
                    } else {
                        path.setAttribute('stroke-width', originalWidth);
                    }
                    updatedCount++;
                });

                // Reset legend rect strokes too
                const legendGroups = getAllFeatureLegendGroups(svg);
                for (const targetGroup of legendGroups) {
                    const paths = targetGroup.querySelectorAll('path');
                    paths.forEach(p => {
                        const fill = p.getAttribute('fill');
                        if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                            if (originalColor === null) {
                                p.removeAttribute('stroke');
                            } else {
                                p.setAttribute('stroke', originalColor);
                            }
                            if (originalWidth === null) {
                                p.removeAttribute('stroke-width');
                            } else {
                                p.setAttribute('stroke-width', originalWidth);
                            }
                        }
                    });
                }

                // Clear all stroke overrides
                Object.keys(legendStrokeOverrides).forEach(key => delete legendStrokeOverrides[key]);

                // Save to results
                if (updatedCount > 0) {
                    skipCaptureBaseConfig.value = true;
                    const resultIdx = selectedResultIndex.value;
                    if (resultIdx >= 0 && results.value.length > resultIdx) {
                        const serializer = new XMLSerializer();
                        results.value[resultIdx] = { ...results.value[resultIdx], content: serializer.serializeToString(svg) };
                    }
                    console.log(`Reset all strokes: updated ${updatedCount} elements to original (color=${originalColor}, width=${originalWidth})`);
                }
            };

            // Capture original stroke values for features matching a caption
            const captureOriginalStrokeValues = (caption) => {
                if (!svgContainer.value) return { strokeColor: '#000000', strokeWidth: 0.5 };
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return { strokeColor: '#000000', strokeWidth: 0.5 };

                // Get the fill color for this legend entry to match features by color
                const legendEntry = legendEntries.value.find(e => e.caption === caption);
                const legendFillColor = legendEntry?.color;

                // Find features matching this caption
                const matchingFeatures = extractedFeatures.value.filter(f => {
                    const featureCaption = f.product || f.gene || f.locus_tag || f.note || `${f.type} at ${f.start}..${f.end}`;
                    return featureCaption === caption;
                });

                // Also check manualSpecificRules for caption matches
                const ruleMatch = manualSpecificRules.find(r => r.cap === caption);
                if (ruleMatch) {
                    const ruleFeatures = extractedFeatures.value.filter(f =>
                        f.type === ruleMatch.feat &&
                        (ruleMatch.qual === 'hash' ? f.svg_id === ruleMatch.val :
                         f[ruleMatch.qual] === ruleMatch.val)
                    );
                    matchingFeatures.push(...ruleFeatures);
                }

                // Get first matching element's stroke values
                for (const feat of matchingFeatures) {
                    const el = svg.querySelector(`#${CSS.escape(feat.svg_id)}`);
                    if (el) {
                        return {
                            strokeColor: el.getAttribute('stroke') || '#000000',
                            strokeWidth: parseFloat(el.getAttribute('stroke-width')) || 0.5
                        };
                    }
                }

                // Try to find by fill color if no match found by caption
                if (legendFillColor) {
                    const normalizedLegendColor = legendFillColor.toLowerCase();
                    const featurePaths = svg.querySelectorAll('path[id^="f"]');
                    for (const path of featurePaths) {
                        const fill = path.getAttribute('fill');
                        if (fill && fill.toLowerCase() === normalizedLegendColor) {
                            return {
                                strokeColor: path.getAttribute('stroke') || '#000000',
                                strokeWidth: parseFloat(path.getAttribute('stroke-width')) || 0.5
                            };
                        }
                    }
                }

                return { strokeColor: '#000000', strokeWidth: 0.5 };
            };

            // Apply stroke settings to all features matching a caption
            const applyStrokeToFeaturesByCaption = (caption, strokeColor, strokeWidth) => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                let updatedCount = 0;
                const processedIds = new Set();

                // Find the legend entry by caption
                const legendEntry = legendEntries.value.find(e => e.caption === caption);

                // Primary method: use featureIds from legend entry (most reliable)
                if (legendEntry && legendEntry.featureIds && legendEntry.featureIds.length > 0) {
                    for (const svgId of legendEntry.featureIds) {
                        if (processedIds.has(svgId)) continue;
                        processedIds.add(svgId);
                        const elements = svg.querySelectorAll(`#${CSS.escape(svgId)}`);
                        elements.forEach(el => {
                            if (strokeColor !== null) {
                                el.setAttribute('stroke', strokeColor);
                                updatedCount++;
                            }
                            if (strokeWidth !== null) {
                                el.setAttribute('stroke-width', strokeWidth);
                            }
                        });
                    }
                    console.log(`Applied stroke to ${legendEntry.featureIds.length} features via featureIds for "${caption}"`);
                } else {
                    // Fallback: match by fill color
                    const legendFillColor = legendEntry?.color;
                    if (legendFillColor) {
                        const normalizedLegendColor = legendFillColor.toLowerCase();
                        const featurePaths = svg.querySelectorAll('path[id^="f"]');
                        featurePaths.forEach(path => {
                            const fill = path.getAttribute('fill');
                            if (fill && fill.toLowerCase() === normalizedLegendColor) {
                                const pathId = path.getAttribute('id');
                                if (pathId && !processedIds.has(pathId)) {
                                    processedIds.add(pathId);
                                    if (strokeColor !== null) {
                                        path.setAttribute('stroke', strokeColor);
                                        updatedCount++;
                                    }
                                    if (strokeWidth !== null) {
                                        path.setAttribute('stroke-width', strokeWidth);
                                    }
                                }
                            }
                        });
                    }
                    console.log(`Fallback: Applied stroke via fill color matching for "${caption}"`);
                }

                // Also apply to legend rect stroke (if visible)
                const legendGroups = getAllFeatureLegendGroups(svg);
                for (const targetGroup of legendGroups) {
                    const texts = targetGroup.querySelectorAll('text');
                    for (const t of texts) {
                        if (t.textContent?.trim() === caption.trim()) {
                            const transform = t.getAttribute('transform');
                            if (transform) {
                                const match = transform.match(/translate\([^,]+,\s*([\d.-]+)\)/);
                                if (match) {
                                    const textY = parseFloat(match[1]);
                                    const paths = targetGroup.querySelectorAll('path');
                                    paths.forEach(p => {
                                        const pt = p.getAttribute('transform');
                                        if (pt) {
                                            const pMatch = pt.match(/translate\([^,]+,\s*([\d.-]+)\)/);
                                            if (pMatch && Math.abs(parseFloat(pMatch[1]) - textY) < 1) {
                                                if (strokeColor !== null) {
                                                    p.setAttribute('stroke', strokeColor);
                                                }
                                                if (strokeWidth !== null) {
                                                    p.setAttribute('stroke-width', strokeWidth);
                                                }
                                            }
                                        }
                                    });
                                }
                            }
                            break;
                        }
                    }
                }

                if (updatedCount > 0) {
                    // Save to results
                    skipCaptureBaseConfig.value = true;
                    const resultIdx = selectedResultIndex.value;
                    if (resultIdx >= 0 && results.value.length > resultIdx) {
                        const serializer = new XMLSerializer();
                        results.value[resultIdx] = { ...results.value[resultIdx], content: serializer.serializeToString(svg) };
                    }
                    console.log(`Applied stroke to ${updatedCount} elements for caption "${caption}"`);
                }
            };

            // Delete legend entry by index
            const deleteLegendEntry = (idx) => {
                const entry = legendEntries.value[idx];
                if (!entry) return;

                // Save to deleted entries for potential restoration
                deletedLegendEntries.value.push({ ...entry });

                removeLegendEntry(entry.caption);
                extractLegendEntries();  // Refresh the list
            };

            // Restore all deleted legend entries
            const restoreDeletedLegendEntries = () => {
                if (deletedLegendEntries.value.length === 0) return;

                for (const entry of deletedLegendEntries.value) {
                    addLegendEntry(entry.caption, entry.color);
                }
                deletedLegendEntries.value = [];
                extractLegendEntries();
            };

            // Move legend entry up (swap with previous)
            const moveLegendEntryUp = (idx) => {
                if (idx <= 0) return;
                swapLegendEntries(idx, idx - 1);
            };

            // Move legend entry down (swap with next)
            const moveLegendEntryDown = (idx) => {
                if (idx >= legendEntries.value.length - 1) return;
                swapLegendEntries(idx, idx + 1);
            };

            // Sort legend entries alphabetically
            const sortLegendEntries = (direction = 'asc') => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                const entries = [...legendEntries.value];
                if (entries.length < 2) return;

                // Collect all current Y positions
                const yPositions = entries.map(e => e.yPos).sort((a, b) => a - b);

                // Sort entries by caption
                const sortedEntries = [...entries].sort((a, b) => {
                    const cmp = a.caption.localeCompare(b.caption, undefined, { sensitivity: 'base' });
                    return direction === 'asc' ? cmp : -cmp;
                });

                // Get all feature legend groups
                const targetGroups = getAllFeatureLegendGroups(svg);
                if (targetGroups.length === 0) return;

                // Create a mapping from old Y position to new Y position
                const yMapping = new Map();
                entries.forEach((entry, idx) => {
                    const sortedIdx = sortedEntries.findIndex(e => e.caption === entry.caption && e.color === entry.color);
                    if (sortedIdx !== -1) {
                        yMapping.set(entry.yPos, yPositions[sortedIdx]);
                    }
                });

                // Update SVG elements
                for (const targetGroup of targetGroups) {
                    const allElements = targetGroup.querySelectorAll('path, text');
                    allElements.forEach(el => {
                        const transform = el.getAttribute('transform');
                        if (!transform) return;

                        const match = transform.match(/translate\(([^,]+),\s*([\d.-]+)\)/);
                        if (!match) return;

                        const x = match[1];
                        const y = parseFloat(match[2]);

                        // Find matching Y position
                        for (const [oldY, newY] of yMapping) {
                            if (Math.abs(y - oldY) < 1) {
                                el.setAttribute('transform', `translate(${x}, ${newY})`);
                                break;
                            }
                        }
                    });
                }

                // Save to results
                skipCaptureBaseConfig.value = true;
                const resultIdx = selectedResultIndex.value;
                if (resultIdx >= 0 && results.value.length > resultIdx) {
                    const serializer = new XMLSerializer();
                    results.value[resultIdx] = { ...results.value[resultIdx], content: serializer.serializeToString(svg) };
                }

                // Re-extract to reflect new order
                extractLegendEntries();
            };

            // Sort legend entries by default (generation) order
            // Original entries keep their generation order, new entries go to end
            const sortLegendEntriesByDefault = () => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                const entries = [...legendEntries.value];
                if (entries.length < 2) return;
                if (originalLegendOrder.value.length === 0) return; // No original order stored

                // Collect all current Y positions
                const yPositions = entries.map(e => e.yPos).sort((a, b) => a - b);

                // Sort entries: original entries in original order, then new entries alphabetically
                const sortedEntries = [...entries].sort((a, b) => {
                    const aOrigIdx = originalLegendOrder.value.indexOf(a.caption);
                    const bOrigIdx = originalLegendOrder.value.indexOf(b.caption);

                    // Both in original order
                    if (aOrigIdx !== -1 && bOrigIdx !== -1) {
                        return aOrigIdx - bOrigIdx;
                    }
                    // Only a in original order - a comes first
                    if (aOrigIdx !== -1) return -1;
                    // Only b in original order - b comes first
                    if (bOrigIdx !== -1) return 1;
                    // Neither in original order - sort alphabetically
                    return a.caption.localeCompare(b.caption, undefined, { sensitivity: 'base' });
                });

                // Get all feature legend groups
                const targetGroups = getAllFeatureLegendGroups(svg);
                if (targetGroups.length === 0) return;

                // Create a mapping from old Y position to new Y position
                const yMapping = new Map();
                entries.forEach((entry) => {
                    const sortedIdx = sortedEntries.findIndex(e => e.caption === entry.caption && e.color === entry.color);
                    if (sortedIdx !== -1) {
                        yMapping.set(entry.yPos, yPositions[sortedIdx]);
                    }
                });

                // Update SVG elements
                for (const targetGroup of targetGroups) {
                    const allElements = targetGroup.querySelectorAll('path, text');
                    allElements.forEach(el => {
                        const transform = el.getAttribute('transform');
                        if (!transform) return;

                        const match = transform.match(/translate\(([^,]+),\s*([\d.-]+)\)/);
                        if (!match) return;

                        const x = match[1];
                        const y = parseFloat(match[2]);

                        // Find matching Y position
                        for (const [oldY, newY] of yMapping) {
                            if (Math.abs(y - oldY) < 1) {
                                el.setAttribute('transform', `translate(${x}, ${newY})`);
                                break;
                            }
                        }
                    });
                }

                // Save to results
                skipCaptureBaseConfig.value = true;
                const resultIdx = selectedResultIndex.value;
                if (resultIdx >= 0 && results.value.length > resultIdx) {
                    const serializer = new XMLSerializer();
                    results.value[resultIdx] = { ...results.value[resultIdx], content: serializer.serializeToString(svg) };
                }

                // Re-extract to reflect new order
                extractLegendEntries();
            };

            // Swap two legend entries by exchanging their Y positions in the SVG
            const swapLegendEntries = (idx1, idx2) => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                // Get all feature legend groups (handles dual legends)
                const targetGroups = getAllFeatureLegendGroups(svg);
                if (targetGroups.length === 0) return;

                const entry1 = legendEntries.value[idx1];
                const entry2 = legendEntries.value[idx2];
                if (!entry1 || !entry2) return;

                const y1 = entry1.yPos;
                const y2 = entry2.yPos;

                // Swap in all legend groups
                for (const targetGroup of targetGroups) {
                    const allElements = targetGroup.querySelectorAll('path, text');
                    allElements.forEach(el => {
                        const transform = el.getAttribute('transform');
                        if (!transform) return;

                        const match = transform.match(/translate\(([^,]+),\s*([\d.-]+)\)/);
                        if (!match) return;

                        const x = match[1];
                        const y = parseFloat(match[2]);

                        // Check if this element belongs to entry1 or entry2
                        if (Math.abs(y - y1) < 1) {
                            // This element belongs to entry1, move to y2
                            el.setAttribute('transform', `translate(${x}, ${y2})`);
                        } else if (Math.abs(y - y2) < 1) {
                            // This element belongs to entry2, move to y1
                            el.setAttribute('transform', `translate(${x}, ${y1})`);
                        }
                    });
                }

                // Update local state (swap yPos values)
                legendEntries.value[idx1].yPos = y2;
                legendEntries.value[idx2].yPos = y1;

                // Swap entries in array to reflect visual order
                const temp = { ...legendEntries.value[idx1] };
                legendEntries.value[idx1] = { ...legendEntries.value[idx2], yPos: y1 };
                legendEntries.value[idx2] = { ...temp, yPos: y2 };

                // Save to results
                skipCaptureBaseConfig.value = true;
                const resultIdx = selectedResultIndex.value;
                if (resultIdx >= 0 && results.value.length > resultIdx) {
                    const serializer = new XMLSerializer();
                    results.value[resultIdx] = { ...results.value[resultIdx], content: serializer.serializeToString(svg) };
                }

                // Re-extract to ensure correct ordering
                extractLegendEntries();
            };

            // Add new legend entry from the UI
            const addNewLegendEntry = async () => {
                if (!newLegendCaption.value.trim()) return;

                const added = await addLegendEntry(newLegendCaption.value.trim(), newLegendColor.value);
                if (added) {
                    newLegendCaption.value = '';
                    newLegendColor.value = '#808080';
                    // Refresh after a short delay to allow DOM update
                    setTimeout(() => extractLegendEntries(), 100);
                }
            };

            // Legend drag functions
            const parseTransform = (transformStr) => {
                if (!transformStr) return { x: 0, y: 0 };
                const match = transformStr.match(/translate\(\s*([-\d.]+)\s*,?\s*([-\d.]+)?\s*\)/);
                if (match) {
                    return { x: parseFloat(match[1]) || 0, y: parseFloat(match[2]) || 0 };
                }
                return { x: 0, y: 0 };
            };

            const startLegendDrag = (e) => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;
                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return;

                // Prevent default to avoid text selection and stop propagation to prevent diagram drag
                e.preventDefault();
                e.stopPropagation();

                legendDragging.value = true;
                legendDragStart.x = e.clientX;
                legendDragStart.y = e.clientY;

                // Parse current transform
                const currentTransform = parseTransform(legendGroup.getAttribute('transform'));
                legendOriginalTransform.value = { ...currentTransform };

                // Add visual feedback
                legendGroup.style.cursor = 'grabbing';
                legendGroup.style.opacity = '0.8';

                // Add document-level event listeners
                document.addEventListener('mousemove', onLegendDrag);
                document.addEventListener('mouseup', endLegendDrag);
            };

            const onLegendDrag = (e) => {
                if (!legendDragging.value) return;
                if (!svgContainer.value) return;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;
                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return;

                // Calculate delta, accounting for zoom level
                const deltaX = (e.clientX - legendDragStart.x) / zoom.value;
                const deltaY = (e.clientY - legendDragStart.y) / zoom.value;

                // Apply new transform
                const newX = legendOriginalTransform.value.x + deltaX;
                const newY = legendOriginalTransform.value.y + deltaY;
                legendGroup.setAttribute('transform', `translate(${newX}, ${newY})`);

                // Store current offset
                legendCurrentOffset.x = newX;
                legendCurrentOffset.y = newY;
            };

            const endLegendDrag = () => {
                if (!legendDragging.value) return;

                legendDragging.value = false;

                // Remove document-level event listeners
                document.removeEventListener('mousemove', onLegendDrag);
                document.removeEventListener('mouseup', endLegendDrag);

                // Reset visual feedback
                if (svgContainer.value) {
                    const svg = svgContainer.value.querySelector('svg');
                    if (svg) {
                        const legendGroup = svg.getElementById('legend');
                        if (legendGroup) {
                            legendGroup.style.cursor = 'grab';
                            legendGroup.style.opacity = '1';
                        }
                    }
                }
            };

            // Reset ONLY the legend position - does not affect colors, legend entries, or feature edits
            const resetLegendPositionOnly = () => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;
                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return;

                // Reset to original position (restore initial transform)
                const initial = legendInitialTransform.value;
                if (initial.x !== 0 || initial.y !== 0) {
                    legendGroup.setAttribute('transform', `translate(${initial.x}, ${initial.y})`);
                } else {
                    legendGroup.removeAttribute('transform');
                }
                legendCurrentOffset.x = 0;
                legendCurrentOffset.y = 0;
            };

            // Full legend reset - resets position AND all color/legend edits
            // Only used for complete diagram regeneration, NOT for position-only reset
            const resetLegendPosition = () => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;
                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return;

                // Reset to original position (restore initial transform)
                const initial = legendInitialTransform.value;
                if (initial.x !== 0 || initial.y !== 0) {
                    legendGroup.setAttribute('transform', `translate(${initial.x}, ${initial.y})`);
                } else {
                    legendGroup.removeAttribute('transform');
                }
                legendCurrentOffset.x = 0;
                legendCurrentOffset.y = 0;

                // Reset all stroke overrides to original values
                for (const caption of Object.keys(legendStrokeOverrides)) {
                    const override = legendStrokeOverrides[caption];
                    if (override) {
                        applyStrokeToFeaturesByCaption(
                            caption,
                            override.originalStrokeColor || null,
                            override.originalStrokeWidth ?? null
                        );
                    }
                }
                // Clear all stroke overrides
                Object.keys(legendStrokeOverrides).forEach(key => delete legendStrokeOverrides[key]);

                // Clear all color overrides and re-apply palette colors
                Object.keys(legendColorOverrides).forEach(key => delete legendColorOverrides[key]);
                applyPaletteToSvg();

                const featureLegendGroups = getAllFeatureLegendGroups(svg);

                // Remove dynamically added legend entries (not in original order and not from file)
                if (originalLegendOrder.value.length > 0) {
                    const originalCaptions = new Set(originalLegendOrder.value);
                    for (const targetGroup of featureLegendGroups) {
                        const entryGroups = targetGroup.querySelectorAll('g[data-legend-key]');
                        for (const entryGroup of entryGroups) {
                            const caption = entryGroup.getAttribute('data-legend-key');
                            if (caption && !originalCaptions.has(caption) && !fileLegendCaptions.value.has(caption)) {
                                // This entry was added dynamically (not from file) - remove it
                                entryGroup.remove();
                            }
                        }
                    }
                }

                // Restore original legend colors for entries not handled by palette
                // (e.g., "hypothetical protein" and other dynamic captions)
                for (const caption of Object.keys(originalLegendColors.value)) {
                    const originalColor = originalLegendColors.value[caption];
                    if (!originalColor) continue;

                    // Update legend entry color in all legend groups
                    for (const targetGroup of featureLegendGroups) {
                        const entryGroup = targetGroup.querySelector(`g[data-legend-key="${CSS.escape(caption)}"]`);
                        if (entryGroup) {
                            const paths = entryGroup.querySelectorAll('path');
                            for (const path of paths) {
                                const fill = path.getAttribute('fill');
                                if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                                    path.setAttribute('fill', originalColor);
                                    break;
                                }
                            }
                        }
                    }
                }

                // Also restore any deleted legend entries
                restoreDeletedLegendEntries();

                // Clear the list of captions added via Legend Editor (keep file-loaded ones)
                for (const cap of addedLegendCaptions.value) {
                    if (!fileLegendCaptions.value.has(cap)) {
                        addedLegendCaptions.value.delete(cap);
                    }
                }

                // Clear manual specific rules (feature color overrides) - but keep file-loaded rules
                for (let i = manualSpecificRules.length - 1; i >= 0; i--) {
                    if (!manualSpecificRules[i].fromFile) {
                        manualSpecificRules.splice(i, 1);
                    }
                }

                // Clear feature color overrides
                Object.keys(featureColorOverrides).forEach(k => delete featureColorOverrides[k]);

                // Re-apply palette to features (now that specific rules are cleared)
                applyPaletteToSvg();

                // Re-extract legend entries to refresh the UI
                extractLegendEntries();
            };

            const setupLegendDrag = () => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;
                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return;

                // Store the legend's initial transform from the SVG
                const initialTransform = parseTransform(legendGroup.getAttribute('transform'));
                legendInitialTransform.value = { ...initialTransform };

                // Reset offset tracking
                legendCurrentOffset.x = 0;
                legendCurrentOffset.y = 0;

                // Set cursor style
                legendGroup.style.cursor = 'grab';

                // Remove existing listener to avoid duplicates
                legendGroup.removeEventListener('mousedown', startLegendDrag);
                // Add mousedown listener
                legendGroup.addEventListener('mousedown', startLegendDrag);
            };

            // Main diagram drag functions (moves tick, labels, axis, definition, records as one group)
            const startDiagramDrag = (e) => {
                // Don't start if clicking on legend or feature elements
                if (e.target.closest('#legend') ||
                    e.target.closest('path[data-feature-id]') ||
                    e.target.closest('rect[data-feature-id]')) {
                    return;
                }
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                // Check if clicking inside a diagram element
                const clickedGroup = e.target.closest('g[id]');
                if (!clickedGroup) return;

                const clickedId = clickedGroup.id;
                // Only start drag if clicking on a main diagram element (not legend)
                // Exclude all legend-related groups to prevent conflicts with legend drag
                if (clickedId === 'legend' || clickedId === 'feature_legend' || clickedId === 'pairwise_legend' ||
                    clickedId === 'horizontal_legend' || clickedId === 'vertical_legend') {
                    return;
                }

                e.preventDefault();
                diagramDragging.value = true;
                diagramDragStart.x = e.clientX;
                diagramDragStart.y = e.clientY;

                // Visual feedback on all diagram elements
                diagramElements.value.forEach(el => {
                    el.style.opacity = '0.8';
                });

                document.addEventListener('mousemove', onDiagramDrag);
                document.addEventListener('mouseup', endDiagramDrag);
            };

            const onDiagramDrag = (e) => {
                if (!diagramDragging.value) return;

                // Calculate delta, accounting for zoom level
                const deltaX = (e.clientX - diagramDragStart.x) / zoom.value;
                const deltaY = (e.clientY - diagramDragStart.y) / zoom.value;

                // Apply transform to all diagram elements, preserving their original positions
                diagramElements.value.forEach(el => {
                    const original = diagramElementOriginalTransforms.value.get(el) || { x: 0, y: 0 };
                    const newX = original.x + diagramOffset.x + deltaX;
                    const newY = original.y + diagramOffset.y + deltaY;
                    el.setAttribute('transform', `translate(${newX}, ${newY})`);
                });
            };

            const endDiagramDrag = () => {
                if (!diagramDragging.value) return;

                // Update stored offset
                const deltaX = (event.clientX - diagramDragStart.x) / zoom.value;
                const deltaY = (event.clientY - diagramDragStart.y) / zoom.value;
                diagramOffset.x += deltaX;
                diagramOffset.y += deltaY;

                diagramDragging.value = false;
                document.removeEventListener('mousemove', onDiagramDrag);
                document.removeEventListener('mouseup', endDiagramDrag);

                // Reset visual feedback
                diagramElements.value.forEach(el => {
                    el.style.opacity = '1';
                });
            };

            const resetDiagramPosition = () => {
                // Reset offset
                diagramOffset.x = 0;
                diagramOffset.y = 0;

                console.log('[DEBUG] resetDiagramPosition called');
                console.log('[DEBUG] diagramElements count:', diagramElements.value.length);
                console.log('[DEBUG] originalTransforms size:', diagramElementOriginalTransforms.value.size);
                // Log all entries in originalTransforms Map
                console.log('[DEBUG] All originalTransforms entries:');
                diagramElementOriginalTransforms.value.forEach((transform, mapEl) => {
                    console.log(`[DEBUG]   Map entry: ${mapEl.id} -> (${transform.x}, ${transform.y})`);
                });

                // Restore original transforms for all diagram elements
                diagramElements.value.forEach((el, idx) => {
                    const original = diagramElementOriginalTransforms.value.get(el);
                    const currentTransform = el.getAttribute('transform');
                    // Check if element reference matches any key in the Map
                    let foundInMap = false;
                    diagramElementOriginalTransforms.value.forEach((_, mapEl) => {
                        if (mapEl === el) foundInMap = true;
                    });
                    console.log(`[DEBUG] Reset element ${idx} (${el.id}): current="${currentTransform}", foundInMap=${foundInMap}, original=`, original);
                    if (original && (original.x !== 0 || original.y !== 0)) {
                        el.setAttribute('transform', `translate(${original.x}, ${original.y})`);
                    } else {
                        el.removeAttribute('transform');
                    }
                });
            };

            const resetAllPositions = () => {
                resetDiagramPosition();
                resetLegendPositionOnly();  // Only reset position, preserve color/legend edits
            };

            // Calculate absolute canvas configuration for circular mode based on position
            // Uses base config to avoid accumulation errors
            const getCircularAbsoluteConfig = (position, baseConfig) => {
                const { viewBoxWidth, viewBoxHeight, diagramCenterX, diagramCenterY, legendWidth, legendHeight } = baseConfig;
                // Use generated viewBox dimensions for corner positions to maintain diagram position
                const genVbW = baseConfig.generatedViewBoxWidth || viewBoxWidth;
                const genVbH = baseConfig.generatedViewBoxHeight || viewBoxHeight;
                console.log(`[DEBUG] getCircularAbsoluteConfig called with position="${position}" (type: ${typeof position}, length: ${position.length})`);
                console.log(`[DEBUG] position === 'left': ${position === 'left'}, position === 'right': ${position === 'right'}`);
                console.log(`[DEBUG] viewBoxWidth=${viewBoxWidth}, genVbW=${genVbW}`);

                switch (position) {
                    case 'left':
                        debugLog('Matched case: left');
                        return {
                            vbWidth: viewBoxWidth + legendWidth * 1.1,
                            vbHeight: viewBoxHeight,
                            diagramShiftX: legendWidth * 0.55,  // Shift diagram right
                            diagramShiftY: 0,
                            legendX: 10,
                            legendY: (viewBoxHeight - legendHeight) / 2
                        };
                    case 'right':
                        debugLog('Matched case: right');
                        return {
                            vbWidth: viewBoxWidth + legendWidth * 1.1,
                            vbHeight: viewBoxHeight,
                            diagramShiftX: 0,  // No shift, legend goes to expanded area
                            diagramShiftY: 0,
                            legendX: viewBoxWidth + legendWidth * 0.05,
                            legendY: (viewBoxHeight - legendHeight) / 2
                        };
                    case 'upper_left':
                        // Use generated viewBox size to maintain diagram position
                        return {
                            vbWidth: genVbW,
                            vbHeight: genVbH,
                            diagramShiftX: 0,
                            diagramShiftY: 0,
                            legendX: 0.025 * genVbW,
                            legendY: 0.05 * genVbH
                        };
                    case 'upper_right':
                        return {
                            vbWidth: genVbW,
                            vbHeight: genVbH,
                            diagramShiftX: 0,
                            diagramShiftY: 0,
                            legendX: 0.85 * genVbW,
                            legendY: 0.05 * genVbH
                        };
                    case 'lower_left':
                        return {
                            vbWidth: genVbW,
                            vbHeight: genVbH,
                            diagramShiftX: 0,
                            diagramShiftY: 0,
                            legendX: 0.025 * genVbW,
                            legendY: 0.78 * genVbH
                        };
                    case 'lower_right':
                        return {
                            vbWidth: genVbW,
                            vbHeight: genVbH,
                            diagramShiftX: 0,
                            diagramShiftY: 0,
                            legendX: 0.875 * genVbW,
                            legendY: 0.75 * genVbH
                        };
                    case 'none':
                    default:
                        console.log(`[DEBUG] Matched case: default (position was "${position}")`);
                        return {
                            vbWidth: genVbW,
                            vbHeight: genVbH,
                            diagramShiftX: 0,
                            diagramShiftY: 0,
                            legendX: 0,
                            legendY: 0
                        };
                }
            };

            // Reposition elements when legend position dropdown changes
            // Uses ABSOLUTE positioning from base config to avoid accumulation errors
            const repositionForLegendChange = (newPosition, oldPosition) => {
                if (!svgContainer.value || !svgContent.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                const legendGroup = svg.getElementById('legend');
                const isLinear = mode.value === 'linear';

                // Get current legend dimensions
                let legendWidth = 120, legendHeight = 150;
                if (legendGroup) {
                    const bbox = legendGroup.getBBox();
                    legendWidth = bbox.width || legendWidth;
                    legendHeight = bbox.height || legendHeight;
                }

                if (!isLinear) {
                    // === CIRCULAR MODE: Use absolute positioning from base config ===
                    debugLog('Circular mode reposition:', { newPosition, oldPosition });
                    debugLog('circularBaseConfig:', circularBaseConfig.value);

                    // Handle legend visibility
                    if (legendGroup) {
                        if (newPosition === 'none') {
                            legendGroup.style.display = 'none';
                        } else {
                            legendGroup.style.display = '';
                        }
                    }

                    if (newPosition === 'none') {
                        generatedLegendPosition.value = newPosition;
                        return;
                    }

                    // Update base config legend dimensions if they've changed
                    const baseConfig = {
                        ...circularBaseConfig.value,
                        legendWidth: legendWidth,
                        legendHeight: legendHeight
                    };
                    // Debug: Check if legend dimensions changed from original
                    const origLegendWidth = circularBaseConfig.value.legendWidth || 0;
                    const origLegendHeight = circularBaseConfig.value.legendHeight || 0;
                    if (Math.abs(legendWidth - origLegendWidth) > 1 || Math.abs(legendHeight - origLegendHeight) > 1) {
                        console.log(`[DEBUG] âš ï¸ Legend size CHANGED: ${origLegendWidth.toFixed(1)}x${origLegendHeight.toFixed(1)} -> ${legendWidth.toFixed(1)}x${legendHeight.toFixed(1)}`);
                        console.log(`[DEBUG] âš ï¸ Shift calculation affected: old=${(origLegendWidth * 0.55).toFixed(1)}, new=${(legendWidth * 0.55).toFixed(1)}`);
                    }
                    debugLog('baseConfig:', baseConfig);

                    // Calculate absolute configuration for new position
                    const config = getCircularAbsoluteConfig(newPosition, baseConfig);
                    debugLog('calculated config:', config);

                    // Set viewBox to absolute value (not delta)
                    svg.setAttribute('viewBox', `0 0 ${config.vbWidth} ${config.vbHeight}`);

                    // Set legend to absolute position
                    if (legendGroup) {
                        legendGroup.setAttribute('transform', `translate(${config.legendX}, ${config.legendY})`);
                        legendInitialTransform.value = { x: config.legendX, y: config.legendY };
                        legendCurrentOffset.x = 0;
                        legendCurrentOffset.y = 0;
                    }

                    // Set diagram elements to absolute positions based on base transforms + shift
                    debugLog('Circular: diagramElementBaseTransforms size:', diagramElementBaseTransforms.value.size);
                    debugLog('Circular: diagramElements count:', diagramElements.value.length);

                    // Debug: Show all base transforms at start of repositioning
                    debugLog('Base transforms at reposition start:');
                    for (const [el, transform] of diagramElementBaseTransforms.value) {
                        console.log(`  ${el.id}: {x:${transform.x}, y:${transform.y}}`);
                    }

                    if (diagramElements.value.length > 0) {
                        diagramElements.value.forEach((el, idx) => {
                            const currentTransform = el.getAttribute('transform');
                            const baseTransform = diagramElementBaseTransforms.value.get(el) || { x: 0, y: 0 };
                            const foundInMap = diagramElementBaseTransforms.value.has(el);
                            const newX = baseTransform.x + config.diagramShiftX;
                            const newY = baseTransform.y + config.diagramShiftY;
                            console.log(`[DEBUG] Element ${idx} (${el.id}): currentTransform="${currentTransform}", foundInMap=${foundInMap}, baseTransform={x:${baseTransform.x}, y:${baseTransform.y}}, newTransform={x:${newX}, y:${newY}}`);
                            el.setAttribute('transform', `translate(${newX}, ${newY})`);

                            // Update current transforms (for drag operations)
                            diagramElementOriginalTransforms.value.set(el, { x: newX, y: newY });
                            console.log(`[DEBUG] repositionForLegendChange UPDATED originalTransforms for ${el.id}: (${newX}, ${newY})`);
                        });
                        diagramOffset.x = 0;
                        diagramOffset.y = 0;
                        console.log(`[DEBUG] repositionForLegendChange FINISHED updating ${diagramElements.value.length} elements`);
                    }

                } else {
                    // === LINEAR MODE: Dual legend support with proper repositioning ===
                    debugLog('Linear mode reposition:', { newPosition, oldPosition });

                    // Get SVG dimensions
                    let viewBox = svg.getAttribute('viewBox');
                    if (!viewBox) return;
                    const parts = viewBox.split(/\s+/).map(parseFloat);
                    if (parts.length !== 4) return;
                    let [vbX, vbY, vbW, vbH] = parts;
                    debugLog('viewBox:', { vbX, vbY, vbW, vbH });

                    // Helper to check layout type
                    const isHorizontalLayout = (pos) => pos === 'top' || pos === 'bottom';
                    const isVerticalLayout = (pos) => pos === 'left' || pos === 'right';

                    // Get generated position to determine what shifts are needed
                    const generatedPos = linearBaseConfig.value.generatedPosition || 'right';
                    const wasHorizontal = isHorizontalLayout(generatedPos);
                    const nowHorizontal = isHorizontalLayout(newPosition);
                    debugLog('layout:', { generatedPos, wasHorizontal, nowHorizontal });

                    // Handle legend visibility
                    if (legendGroup) {
                        if (newPosition === 'none') {
                            legendGroup.setAttribute('display', 'none');
                        } else {
                            legendGroup.removeAttribute('display');

                            // Find dual legend groups
                            const horizontalLegend = legendGroup.querySelector('#legend_horizontal');
                            const verticalLegend = legendGroup.querySelector('#legend_vertical');
                            debugLog('dual legends found:', { horizontal: !!horizontalLegend, vertical: !!verticalLegend });

                            // Toggle visibility between horizontal and vertical legends
                            if (horizontalLegend && verticalLegend) {
                                // Debug: Show the actual SVG structure of both legend groups
                                debugLog('Horizontal legend innerHTML (first 500 chars):', horizontalLegend.innerHTML.substring(0, 500));
                                debugLog('Vertical legend innerHTML (first 500 chars):', verticalLegend.innerHTML.substring(0, 500));
                                debugLog('Before toggle - horizontal display:', horizontalLegend.getAttribute('display'));
                                debugLog('Before toggle - vertical display:', verticalLegend.getAttribute('display'));

                                // First, temporarily show both to get accurate dimensions
                                horizontalLegend.removeAttribute('display');
                                verticalLegend.removeAttribute('display');

                                // Get dimensions from both legends
                                const hBbox = horizontalLegend.getBBox();
                                const vBbox = verticalLegend.getBBox();
                                debugLog('Horizontal legend bbox:', { width: hBbox.width, height: hBbox.height });
                                debugLog('Vertical legend bbox:', { width: vBbox.width, height: vBbox.height });

                                // Now set proper visibility
                                if (nowHorizontal) {
                                    // Show horizontal legend, hide vertical
                                    verticalLegend.setAttribute('display', 'none');
                                    legendWidth = hBbox.width || linearBaseConfig.value.horizontalLegendWidth || legendWidth;
                                    legendHeight = hBbox.height || linearBaseConfig.value.horizontalLegendHeight || legendHeight;
                                    debugLog('Showing HORIZONTAL legend, using dimensions:', { legendWidth, legendHeight });
                                } else {
                                    // Show vertical legend, hide horizontal
                                    horizontalLegend.setAttribute('display', 'none');
                                    legendWidth = vBbox.width || linearBaseConfig.value.verticalLegendWidth || legendWidth;
                                    legendHeight = vBbox.height || linearBaseConfig.value.verticalLegendHeight || legendHeight;
                                    debugLog('Showing VERTICAL legend, using dimensions:', { legendWidth, legendHeight });
                                }

                                debugLog('After toggle - horizontal display:', horizontalLegend.getAttribute('display'));
                                debugLog('After toggle - vertical display:', verticalLegend.getAttribute('display'));

                                // Ensure gradient IDs are unique and update colors for BOTH legends
                                ensureUniquePairwiseGradientIds(svg);

                                // Update stop colors for both pairwise gradients
                                if (currentColors.value.pairwise_match_min && currentColors.value.pairwise_match_max) {
                                    [horizontalLegend, verticalLegend].forEach((legend, idx) => {
                                        if (!legend) return;
                                        const pairwiseLegend = legend.querySelector('#pairwise_legend');
                                        if (pairwiseLegend) {
                                            const gradient = pairwiseLegend.querySelector('linearGradient');
                                            if (gradient) {
                                                const stops = gradient.querySelectorAll('stop');
                                                if (stops.length >= 2) {
                                                    stops[0].setAttribute('stop-color', currentColors.value.pairwise_match_min);
                                                    stops[1].setAttribute('stop-color', currentColors.value.pairwise_match_max);
                                                    console.log(`[DEBUG] Updated ${idx === 0 ? 'horizontal' : 'vertical'} pairwise gradient:`, currentColors.value.pairwise_match_min, '->', currentColors.value.pairwise_match_max);
                                                }
                                            }
                                        }
                                    });
                                }

                                // Apply correct viewBox for the layout type
                                const vbAttr = nowHorizontal
                                    ? svg.getAttribute('data-horizontal-viewbox')
                                    : svg.getAttribute('data-vertical-viewbox');
                                debugLog('Applying viewBox attribute:', vbAttr);
                                if (vbAttr) {
                                    const vbParts = vbAttr.split(/\s+/).map(parseFloat);
                                    if (vbParts.length === 4) {
                                        [vbX, vbY, vbW, vbH] = vbParts;
                                        svg.setAttribute('viewBox', `${vbX} ${vbY} ${vbW} ${vbH}`);
                                        debugLog('ViewBox set to:', { vbX, vbY, vbW, vbH });
                                    }
                                }

                                // Expand canvas height if vertical legend exceeds canvas height
                                const legendPadding = 40;  // Top + bottom padding
                                const requiredHeight = legendHeight + legendPadding;
                                if (!nowHorizontal && requiredHeight > vbH) {
                                    const newVbH = requiredHeight;
                                    debugLog('Expanding canvas height:', { oldHeight: vbH, newHeight: newVbH });

                                    // Just expand viewBox - don't shift diagram elements (keeps diagram in place)
                                    vbH = newVbH;
                                    svg.setAttribute('viewBox', `${vbX} ${vbY} ${vbW} ${vbH}`);
                                    debugLog('ViewBox after height expansion:', { vbX, vbY, vbW, vbH });
                                }
                            }

                            // Calculate legend position based on new position and viewBox
                            const padding = 20;
                            let finalX, finalY;

                            switch (newPosition) {
                                case 'top':
                                    finalX = (vbW - legendWidth) / 2;
                                    finalY = padding;
                                    break;
                                case 'bottom':
                                    finalX = (vbW - legendWidth) / 2;
                                    finalY = vbH - legendHeight - padding;
                                    break;
                                case 'left':
                                    finalX = padding;
                                    finalY = (vbH - legendHeight) / 2;
                                    break;
                                case 'right':
                                default:
                                    finalX = vbW - legendWidth - padding;
                                    finalY = (vbH - legendHeight) / 2;
                                    break;
                            }

                            legendGroup.setAttribute('transform', `translate(${finalX}, ${finalY})`);
                            legendInitialTransform.value = { x: finalX, y: finalY };
                            legendCurrentOffset.x = 0;
                            legendCurrentOffset.y = 0;
                        }
                    }

                    // Calculate diagram element shifts based on layout change
                    // The diagram elements were positioned for the generated layout.
                    // When switching between horizontal and vertical layouts, we need to account for
                    // the different viewBox dimensions and legend placement.
                    const hasStoredViewBox = svg.hasAttribute('data-horizontal-viewbox') &&
                                            svg.hasAttribute('data-vertical-viewbox');

                    if (hasStoredViewBox && diagramElements.value.length > 0) {
                        // Get both viewBox configs
                        const hVbAttr = svg.getAttribute('data-horizontal-viewbox');
                        const vVbAttr = svg.getAttribute('data-vertical-viewbox');
                        const hVb = hVbAttr ? hVbAttr.split(/\s+/).map(parseFloat) : null;
                        const vVb = vVbAttr ? vVbAttr.split(/\s+/).map(parseFloat) : null;

                        let shiftX = 0;
                        let shiftY = 0;

                        if (hVb && vVb) {
                            // Get legend dimensions
                            const vLegendWidth = linearBaseConfig.value.verticalLegendWidth || legendWidth;
                            const hLegendHeight = linearBaseConfig.value.horizontalLegendHeight || legendHeight;

                            // Calculate shifts based on the generated position and new position
                            // The key insight: Python positions diagram content differently based on legend position:
                            // - horizontal (top): diagram shifts down by legend height
                            // - horizontal (bottom): diagram at normal Y position
                            // - vertical (left): diagram shifts right by legend width
                            // - vertical (right): diagram at normal X position

                            // Determine required X shift based on left positioning
                            const generatedWithLeftLegend = generatedPos === 'left';
                            const needsLeftLegend = newPosition === 'left';

                            if (!generatedWithLeftLegend && needsLeftLegend) {
                                // Diagram was NOT shifted right originally, but needs to be now
                                shiftX = vLegendWidth;
                            } else if (generatedWithLeftLegend && !needsLeftLegend) {
                                // Diagram WAS shifted right originally, needs to shift back left
                                shiftX = -vLegendWidth;
                            }
                            // If both are same (both left or both not-left), no X shift

                            // Determine required Y shift based on top positioning
                            const generatedWithTopLegend = generatedPos === 'top';
                            const needsTopLegend = newPosition === 'top';

                            if (!generatedWithTopLegend && needsTopLegend) {
                                // Diagram was NOT shifted down originally, but needs to be now
                                shiftY = hLegendHeight;
                            } else if (generatedWithTopLegend && !needsTopLegend) {
                                // Diagram WAS shifted down originally, needs to shift back up
                                shiftY = -hLegendHeight;
                            }
                            // If both are same (both top or both not-top), no Y shift
                        }

                        // Apply shifts to diagram elements
                        debugLog('Linear: diagramElementBaseTransforms size:', diagramElementBaseTransforms.value.size);
                        debugLog('Linear: diagramElements count:', diagramElements.value.length);
                        diagramElements.value.forEach((el, idx) => {
                            const baseTransform = diagramElementBaseTransforms.value.get(el) || { x: 0, y: 0 };
                            const foundInMap = diagramElementBaseTransforms.value.has(el);
                            console.log(`[DEBUG] Linear Element ${idx} (${el.id}): foundInMap=${foundInMap}, baseTransform=`, baseTransform);
                            const newX = baseTransform.x + shiftX;
                            const newY = baseTransform.y + shiftY;
                            el.setAttribute('transform', `translate(${newX}, ${newY})`);
                            diagramElementOriginalTransforms.value.set(el, { x: newX, y: newY });
                        });
                        diagramOffset.x = 0;
                        diagramOffset.y = 0;
                    }
                }

                // Update tracked generated position
                generatedLegendPosition.value = newPosition;

                // Apply palette colors to ALL elements BEFORE serialization
                // This ensures pairwise track colors, legend colors, etc. are all up-to-date
                // We apply directly to the DOM without triggering the serialization in applyPaletteToSvg
                const colors = currentColors.value;

                // Update pairwise track colors (comparison1, comparison2, etc.)
                if (colors.pairwise_match_min && colors.pairwise_match_max) {
                    let compIdx = 1;
                    let compGroup = svg.getElementById(`comparison${compIdx}`);
                    while (compGroup) {
                        const matchPaths = compGroup.querySelectorAll('path');
                        matchPaths.forEach((path, pathIdx) => {
                            const pathKey = `comp${compIdx}_path${pathIdx}`;
                            const currentFill = path.getAttribute('fill');
                            if (currentFill) {
                                let factor;
                                if (pairwiseMatchFactors.value[pathKey] !== undefined) {
                                    factor = pairwiseMatchFactors.value[pathKey];
                                } else {
                                    const origMin = window._origPairwiseMin || '#FFE7E7';
                                    const origMax = window._origPairwiseMax || '#FF7272';
                                    factor = estimateColorFactor(currentFill, origMin, origMax);
                                    pairwiseMatchFactors.value[pathKey] = factor;
                                }
                                const newColor = interpolateColor(colors.pairwise_match_min, colors.pairwise_match_max, factor);
                                path.setAttribute('fill', newColor);
                            }
                        });
                        compIdx++;
                        compGroup = svg.getElementById(`comparison${compIdx}`);
                    }
                }

                // Update feature legend colors in both legends
                const featureLegendGroups = getAllFeatureLegendGroups(svg);
                const keyToColorKey = {
                    'CDS': 'CDS', 'repeat_region': 'repeat_region', 'tmRNA': 'tmRNA',
                    'tRNA': 'tRNA', 'rRNA': 'rRNA', 'ncRNA': 'ncRNA',
                    'misc_feature': 'misc_feature', 'mobile_element': 'mobile_element',
                    'GC content': 'gc_content', 'GC skew (+)': 'skew_high', 'GC skew (-)': 'skew_low'
                };
                featureLegendGroups.forEach(featureLegendGroup => {
                    if (!featureLegendGroup) return;

                    // Find entry groups with data-legend-key attribute (new structure)
                    const entryGroups = featureLegendGroup.querySelectorAll('g[data-legend-key]');

                    if (entryGroups.length > 0) {
                        // New structure: use data-legend-key for identification
                        entryGroups.forEach(entryGroup => {
                            const legendKey = entryGroup.getAttribute('data-legend-key');
                            if (!legendKey) return;
                            if (legendColorOverrides[legendKey]) return;

                            const colorKey = keyToColorKey[legendKey];
                            const newColor = colorKey ? colors[colorKey] : colors[legendKey];
                            if (!newColor) return;

                            const paths = entryGroup.querySelectorAll('path');
                            for (const path of paths) {
                                const fill = path.getAttribute('fill');
                                if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                                    path.setAttribute('fill', newColor);
                                    break;
                                }
                            }
                        });
                    } else {
                        // Fallback: old structure (position-based matching)
                        const texts = featureLegendGroup.querySelectorAll('text');
                        const allPaths = featureLegendGroup.querySelectorAll('path');
                        const parseXY = (transform) => {
                            if (!transform) return { x: 0, y: 0 };
                            const match = transform.match(/translate\(\s*([\d.-]+)\s*,\s*([\d.-]+)\s*\)/);
                            return match ? { x: parseFloat(match[1]), y: parseFloat(match[2]) } : { x: 0, y: 0 };
                        };
                        texts.forEach(textEl => {
                            const textContent = textEl.textContent?.trim();
                            if (!textContent) return;
                            if (legendColorOverrides[textContent]) return;
                            const colorKey = keyToColorKey[textContent];
                            const newColor = colorKey ? colors[colorKey] : colors[textContent];
                            if (!newColor) return;
                            const textPos = parseXY(textEl.getAttribute('transform'));
                            let bestPath = null;
                            let bestX = -Infinity;
                            for (const path of allPaths) {
                                const pathPos = parseXY(path.getAttribute('transform'));
                                const fill = path.getAttribute('fill');
                                if (Math.abs(pathPos.y - textPos.y) < 2 && pathPos.x < textPos.x &&
                                    fill && fill !== 'none' && !fill.startsWith('url(')) {
                                    if (pathPos.x > bestX) {
                                        bestX = pathPos.x;
                                        bestPath = path;
                                    }
                                }
                            }
                            if (bestPath) {
                                bestPath.setAttribute('fill', newColor);
                            }
                        });
                    }
                });

                // Persist changes to results.value so they survive re-rendering
                // Set flags to prevent captureBaseConfig and position reapply when svgContent watch triggers
                skipCaptureBaseConfig.value = true;
                skipPositionReapply.value = true;  // Prevent watch from calling repositionForLegendChange again
                const idx = selectedResultIndex.value;
                if (idx >= 0 && results.value.length > idx) {
                    const serializer = new XMLSerializer();
                    const serialized = serializer.serializeToString(svg);

                    // Debug: Check what transforms are in the serialized SVG
                    if (!isLinear && diagramElements.value.length > 0) {
                        const firstEl = diagramElements.value[0];
                        const domTransform = firstEl.getAttribute('transform');
                        // Check if serialized content contains this transform
                        const transformMatch = serialized.match(new RegExp(`id="${firstEl.id}"[^>]*transform="([^"]+)"`));
                        const serializedTransform = transformMatch ? transformMatch[1] : 'NOT FOUND';
                        console.log(`[DEBUG] Before save - DOM transform: ${domTransform}`);
                        console.log(`[DEBUG] Before save - Serialized transform: ${serializedTransform}`);
                    }

                    results.value[idx] = { ...results.value[idx], content: serialized };
                }

                console.log(`Legend repositioned (${isLinear ? 'linear' : 'circular'}): ${oldPosition} -> ${newPosition}`);
            };

            // Discover and setup draggable diagram elements
            // Store actual DOM elements since IDs can be duplicated (record and definition share same ID)
            const diagramElements = ref([]);
            let setupDiagramDragCallCount = 0;  // Debug counter

            const setupDiagramDrag = (preserveOffset = false) => {
                setupDiagramDragCallCount++;
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                // Reset offset only for fresh diagram generation, not for incremental edits
                if (!preserveOffset) {
                    diagramOffset.x = 0;
                    diagramOffset.y = 0;
                }

                // Known main diagram element IDs
                const knownIds = ['tick', 'labels', 'Axis', 'gc_content', 'skew', 'gc_skew', 'length_bar'];
                const foundElements = [];
                const foundIds = [];

                // Add known IDs that exist
                knownIds.forEach(id => {
                    const el = svg.getElementById(id);
                    if (el) {
                        foundElements.push(el);
                        foundIds.push(id);
                    }
                });

                // Find ALL groups (including those with duplicate IDs like record and definition)
                const allGroups = svg.querySelectorAll('g[id]');
                allGroups.forEach(group => {
                    const id = group.id;
                    if (!id) return;

                    // Skip legend groups
                    if (id === 'legend' || id === 'feature_legend' || id === 'pairwise_legend') return;

                    // Skip if this exact element is already added
                    if (foundElements.includes(group)) return;

                    // Check for record/definition-like IDs (accession numbers, etc.)
                    const isAccession = id.match(/^[A-Z]{2}_?\d+/) ||  // NC_012920, AP027078
                                       id.match(/^[A-Z]+\d+\.\d+$/);   // AP027078.1
                    const isKnown = knownIds.includes(id);
                    const isDynamic = id.startsWith('record_') ||
                                     id.startsWith('definition_') ||
                                     id.startsWith('seq_') ||
                                     id.startsWith('track_') ||
                                     id.startsWith('match_') ||
                                     id.startsWith('comparison');  // pairwise match groups

                    if (isAccession || isKnown || isDynamic) {
                        foundElements.push(group);
                        if (!foundIds.includes(id)) {
                            foundIds.push(id);
                        }
                    }
                });

                diagramElements.value = foundElements;
                diagramElementIds.value = foundIds;

                // Store original transforms for each element
                const originalTransforms = new Map();
                console.log(`[DEBUG] ========== setupDiagramDrag CALL #${setupDiagramDragCallCount} ==========`);
                console.log(`[DEBUG] setupDiagramDrag: preserveOffset=${preserveOffset}, offset=(${diagramOffset.x}, ${diagramOffset.y}), generatedLegendPosition=${generatedLegendPosition.value}`);
                foundElements.forEach((el, idx) => {
                    const transform = parseTransform(el.getAttribute('transform'));
                    console.log(`[DEBUG] setupDiagramDrag element ${idx} (${el.id}): DOM transform=(${transform.x}, ${transform.y})`);
                    if (preserveOffset && (diagramOffset.x !== 0 || diagramOffset.y !== 0)) {
                        // For incremental edits, the current DOM transform includes the user's drag offset.
                        // Subtract the offset to get the "true" original transform for correct drag behavior.
                        const adjusted = {
                            x: transform.x - diagramOffset.x,
                            y: transform.y - diagramOffset.y
                        };
                        console.log(`[DEBUG] setupDiagramDrag element ${idx}: adjusted to (${adjusted.x}, ${adjusted.y})`);
                        originalTransforms.set(el, adjusted);
                    } else {
                        originalTransforms.set(el, transform);
                    }
                });
                diagramElementOriginalTransforms.value = originalTransforms;
                // Debug: Log the final originalTransforms that were set
                console.log(`[DEBUG] setupDiagramDrag FINISHED: Set ${originalTransforms.size} original transforms`);
                originalTransforms.forEach((transform, el) => {
                    console.log(`[DEBUG]   -> ${el.id}: (${transform.x}, ${transform.y})`);
                });

                // Set cursor on all diagram elements
                foundElements.forEach(el => {
                    el.style.cursor = 'grab';
                });

                // Add mousedown listener to SVG for diagram dragging
                svg.removeEventListener('mousedown', startDiagramDrag);
                svg.addEventListener('mousedown', startDiagramDrag);
            };

            // Canvas size functions
            const applyCanvasPadding = () => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                // Get original viewBox or create one from width/height
                let viewBox = svg.getAttribute('viewBox');
                if (!viewBox) {
                    const width = parseFloat(svg.getAttribute('width')) || 800;
                    const height = parseFloat(svg.getAttribute('height')) || 600;
                    viewBox = `0 0 ${width} ${height}`;
                }

                const parts = viewBox.split(/\s+/).map(parseFloat);
                if (parts.length !== 4) return;

                // Store original viewBox if not already stored
                if (!svg.dataset.originalViewBox) {
                    svg.dataset.originalViewBox = viewBox;
                }

                const [origX, origY, origW, origH] = svg.dataset.originalViewBox.split(/\s+/).map(parseFloat);

                // Calculate new viewBox with padding
                const newX = origX - canvasPadding.left;
                const newY = origY - canvasPadding.top;
                const newW = origW + canvasPadding.left + canvasPadding.right;
                const newH = origH + canvasPadding.top + canvasPadding.bottom;

                svg.setAttribute('viewBox', `${newX} ${newY} ${newW} ${newH}`);

                // Update width/height to maintain aspect ratio
                const origWidth = parseFloat(svg.dataset.originalWidth || svg.getAttribute('width')) || origW;
                const origHeight = parseFloat(svg.dataset.originalHeight || svg.getAttribute('height')) || origH;
                if (!svg.dataset.originalWidth) {
                    svg.dataset.originalWidth = origWidth;
                    svg.dataset.originalHeight = origHeight;
                }

                const scaleX = newW / origW;
                const scaleY = newH / origH;
                svg.setAttribute('width', origWidth * scaleX);
                svg.setAttribute('height', origHeight * scaleY);
            };

            const resetCanvasPadding = () => {
                canvasPadding.top = 0;
                canvasPadding.right = 0;
                canvasPadding.bottom = 0;
                canvasPadding.left = 0;

                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                // Restore original viewBox
                if (svg.dataset.originalViewBox) {
                    svg.setAttribute('viewBox', svg.dataset.originalViewBox);
                }
                if (svg.dataset.originalWidth) {
                    svg.setAttribute('width', svg.dataset.originalWidth);
                    svg.setAttribute('height', svg.dataset.originalHeight);
                }
            };

            // Watch canvas padding changes
            watch(canvasPadding, () => {
                applyCanvasPadding();
            }, { deep: true });

            // Watch for legend position changes to reposition elements without regeneration
            watch(() => form.legend, (newPos, oldPos) => {
                // Only reposition if:
                // 1. SVG exists
                // 2. oldPos is defined (not initial setup)
                // 3. Position actually changed
                // 4. newPos is different from the CURRENT tracked position
                //    (generatedLegendPosition tracks the current position, updated after each reposition)
                if (svgContent.value &&
                    oldPos !== undefined &&
                    newPos !== oldPos &&
                    newPos !== generatedLegendPosition.value) {
                    Vue.nextTick(() => {
                        // Pass the current tracked position as oldPosition for reference
                        repositionForLegendChange(newPos, generatedLegendPosition.value);
                    });
                }
            });

            // Capture original stroke values from SVG (gbdraw's auto-determined defaults)
            const captureOriginalStroke = () => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                // Find first feature path and capture its stroke values
                const firstFeaturePath = svg.querySelector('path[id^="f"]');
                if (firstFeaturePath) {
                    // Preserve exact values including null/none - don't default
                    const strokeColor = firstFeaturePath.getAttribute('stroke'); // null, 'none', or color
                    const strokeWidthAttr = firstFeaturePath.getAttribute('stroke-width');
                    const strokeWidth = strokeWidthAttr !== null ? parseFloat(strokeWidthAttr) : null;

                    originalSvgStroke.value = { color: strokeColor, width: strokeWidth };
                    console.log(`Captured original stroke: color=${strokeColor}, width=${strokeWidth}`);
                }
            };

            // Capture base configuration from newly generated SVG (for non-accumulating repositioning)
            const captureBaseConfig = () => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                const viewBox = svg.getAttribute('viewBox');
                if (!viewBox) return;
                const parts = viewBox.split(/\s+/).map(parseFloat);
                if (parts.length !== 4) return;
                const [vbX, vbY, vbW, vbH] = parts;

                const legendGroup = svg.getElementById('legend');
                let legendWidth = 120, legendHeight = 150;
                if (legendGroup) {
                    const bbox = legendGroup.getBBox();
                    legendWidth = bbox.width || legendWidth;
                    legendHeight = bbox.height || legendHeight;
                }

                const isLinear = mode.value === 'linear';

                if (isLinear) {
                    // For linear mode, read data attributes if available, or calculate defaults
                    const verticalVb = svg.getAttribute('data-vertical-viewbox');
                    const horizontalVb = svg.getAttribute('data-horizontal-viewbox');

                    if (verticalVb && horizontalVb) {
                        const vParts = verticalVb.split(/\s+/).map(parseFloat);
                        const hParts = horizontalVb.split(/\s+/).map(parseFloat);
                        linearBaseConfig.value.verticalViewBox = { x: vParts[0], y: vParts[1], w: vParts[2], h: vParts[3] };
                        linearBaseConfig.value.horizontalViewBox = { x: hParts[0], y: hParts[1], w: hParts[2], h: hParts[3] };
                    } else {
                        // Fallback: use current viewBox for both
                        linearBaseConfig.value.verticalViewBox = { x: vbX, y: vbY, w: vbW, h: vbH };
                        linearBaseConfig.value.horizontalViewBox = { x: vbX, y: vbY, w: vbW, h: vbH };
                    }

                    // Get legend dimensions from dual legend groups if they exist
                    if (legendGroup) {
                        const horizontalLegend = legendGroup.querySelector('#legend_horizontal');
                        const verticalLegend = legendGroup.querySelector('#legend_vertical');

                        if (horizontalLegend && verticalLegend) {
                            // Temporarily show both to get accurate dimensions
                            const hDisplay = horizontalLegend.getAttribute('display');
                            const vDisplay = verticalLegend.getAttribute('display');
                            horizontalLegend.removeAttribute('display');
                            verticalLegend.removeAttribute('display');

                            const hBbox = horizontalLegend.getBBox();
                            const vBbox = verticalLegend.getBBox();

                            linearBaseConfig.value.horizontalLegendWidth = hBbox.width || legendWidth;
                            linearBaseConfig.value.horizontalLegendHeight = hBbox.height || legendHeight;
                            linearBaseConfig.value.verticalLegendWidth = vBbox.width || legendWidth;
                            linearBaseConfig.value.verticalLegendHeight = vBbox.height || legendHeight;

                            // Restore original display states
                            if (hDisplay) horizontalLegend.setAttribute('display', hDisplay);
                            if (vDisplay) verticalLegend.setAttribute('display', vDisplay);
                        } else {
                            // Single legend - use same dimensions for both
                            linearBaseConfig.value.verticalLegendWidth = legendWidth;
                            linearBaseConfig.value.verticalLegendHeight = legendHeight;
                            linearBaseConfig.value.horizontalLegendWidth = legendWidth;
                            linearBaseConfig.value.horizontalLegendHeight = legendHeight;
                        }
                    }

                    linearBaseConfig.value.generatedPosition = form.legend;

                    // Store diagram element base transforms
                    linearBaseConfig.value.diagramBaseTransforms = new Map(diagramElementOriginalTransforms.value);
                } else {
                    // For circular mode, calculate base viewBox (without legend-induced expansion)
                    const legendPos = form.legend;
                    let baseVbW = vbW;

                    // If legend is on left or right, the viewBox was expanded - calculate base width
                    if (legendPos === 'left' || legendPos === 'right') {
                        baseVbW = vbW - legendWidth * 1.1;
                    }

                    // Calculate diagram center (typically half of the base width/height)
                    const diagramCenterX = baseVbW / 2;
                    const diagramCenterY = vbH / 2;

                    circularBaseConfig.value = {
                        viewBoxWidth: baseVbW,
                        viewBoxHeight: vbH,
                        generatedViewBoxWidth: vbW,   // Actual viewBox width at generation time
                        generatedViewBoxHeight: vbH,  // Actual viewBox height at generation time
                        diagramCenterX: diagramCenterX,
                        diagramCenterY: diagramCenterY,
                        legendWidth: legendWidth,
                        legendHeight: legendHeight,
                        generatedPosition: legendPos
                    };
                }

                // Store base transforms for all diagram elements
                diagramElementBaseTransforms.value = new Map(diagramElementOriginalTransforms.value);
            };

            // Watch for SVG changes to refresh legend entries and setup drag
            watch(svgContent, () => {
                // IMPORTANT: Capture state BEFORE nextTick, while old DOM elements are still valid
                // After nextTick, Vue will have updated the DOM and old element refs become invalid
                const isIncrementalEdit = skipCaptureBaseConfig.value;
                const shouldSkipPositionReapply = skipPositionReapply.value;
                // Reset position reapply flag immediately (it's only for one cycle)
                skipPositionReapply.value = false;

                // Build ID -> transforms lookup from current base transforms BEFORE DOM update
                // This must happen synchronously (before nextTick) to access old element IDs
                let savedBaseTransformsById = null;
                if (isIncrementalEdit && diagramElementBaseTransforms.value.size > 0) {
                    savedBaseTransformsById = new Map();
                    for (const [el, transform] of diagramElementBaseTransforms.value) {
                        const id = el.id || '';
                        if (id) {  // Only save if element has valid ID
                            if (!savedBaseTransformsById.has(id)) {
                                savedBaseTransformsById.set(id, []);
                            }
                            savedBaseTransformsById.get(id).push(transform);
                        }
                    }
                    debugLog('Saved', savedBaseTransformsById.size, 'base transform IDs before DOM update');
                }

                Vue.nextTick(() => {
                    // Debug: Check what the DOM looks like AFTER Vue updates it
                    if (svgContainer.value) {
                        const svg = svgContainer.value.querySelector('svg');
                        if (svg) {
                            const tickEl = svg.getElementById('tick');
                            if (tickEl) {
                                console.log(`[DEBUG] After DOM update - tick transform: ${tickEl.getAttribute('transform')}`);
                            }
                        }
                    }

                    // Skip extractLegendEntries when setFeatureColor is handling it
                    // This prevents race condition where watcher overwrites correct legend state
                    if (!skipExtractOnSvgChange.value) {
                        extractLegendEntries();
                    }
                    setupLegendDrag();
                    setupDiagramDrag(isIncrementalEdit);  // Preserve offset during incremental edits

                    if (!isIncrementalEdit) {
                        // Full capture for fresh generation
                        captureBaseConfig();
                        captureOriginalStroke();
                        debugLog('Full base config capture (fresh generation)');

                        // Reset canvas padding for new SVG
                        canvasPadding.top = 0;
                        canvasPadding.right = 0;
                        canvasPadding.bottom = 0;
                        canvasPadding.left = 0;

                        // Re-apply stroke overrides to new SVG (preserve user customizations)
                        reapplyStrokeOverrides();

                        // Ensure pairwise gradient IDs are unique for linear mode dual legends
                        // This must be done before any palette changes to prevent gradient conflicts
                        if (svgContainer.value) {
                            const svgEl = svgContainer.value.querySelector('svg');
                            if (svgEl) {
                                ensureUniquePairwiseGradientIds(svgEl);
                                // Serialize the fixed SVG back to results
                                skipCaptureBaseConfig.value = true;
                                const idx = selectedResultIndex.value;
                                if (idx >= 0 && results.value.length > idx) {
                                    const serializer = new XMLSerializer();
                                    results.value[idx] = { ...results.value[idx], content: serializer.serializeToString(svgEl) };
                                }
                            }
                        }
                    } else if (savedBaseTransformsById && savedBaseTransformsById.size > 0) {
                        // Incremental edit - remap saved base transforms to new elements
                        debugLog('Incremental edit - remapping base transforms');

                        const newBaseTransforms = new Map();
                        const idCounters = new Map();

                        diagramElements.value.forEach(newEl => {
                            const id = newEl.id || '';
                            const transforms = savedBaseTransformsById.get(id);
                            if (transforms && transforms.length > 0) {
                                const idx = idCounters.get(id) || 0;
                                if (idx < transforms.length) {
                                    newBaseTransforms.set(newEl, transforms[idx]);
                                    idCounters.set(id, idx + 1);
                                }
                            }
                        });

                        diagramElementBaseTransforms.value = newBaseTransforms;
                        debugLog('Remapped', newBaseTransforms.size, 'base transforms to new elements');

                        // After DOM update, reapply legend position if it differs from CURRENT position
                        // This is needed because Python regenerates SVG with the original position
                        // BUT skip if:
                        // 1. This watch was triggered by repositionForLegendChange itself
                        // 2. The diagram has already been repositioned to the current legend position
                        //    (generatedLegendPosition tracks the CURRENT position after any repositioning)
                        if (!shouldSkipPositionReapply) {
                            const isLinear = mode.value === 'linear';
                            const currentLegendPos = form.legend;
                            // Use generatedLegendPosition which is updated after repositioning,
                            // NOT circularBaseConfig.generatedPosition which is the original generation position
                            const currentDiagramPos = generatedLegendPosition.value;

                            debugLog('Checking position after incremental edit:', { currentLegendPos, currentDiagramPos, isLinear, shouldSkipPositionReapply });

                            // Only reposition if the diagram position doesn't match the current legend setting
                            // After repositioning, generatedLegendPosition is updated to match form.legend
                            if (currentLegendPos && currentDiagramPos && currentLegendPos !== currentDiagramPos) {
                                debugLog('Position differs from current - reapplying position shift');
                                // IMPORTANT: Set flag BEFORE calling repositionForLegendChange
                                // to ensure the subsequent watch(svgContent) doesn't call captureBaseConfig()
                                skipCaptureBaseConfig.value = true;
                                // Get the ORIGINAL generation position for the shift calculation
                                const originalGeneratedPos = isLinear
                                    ? linearBaseConfig.value.generatedPosition
                                    : circularBaseConfig.value.generatedPosition;
                                // Call synchronously - repositionForLegendChange will set the flag again anyway
                                repositionForLegendChange(currentLegendPos, originalGeneratedPos);
                                // Don't reset the flag here - let it be reset after the watch triggered by
                                // repositionForLegendChange's serialization completes
                                return;
                            }
                        } else {
                            debugLog('Skipping position reapply (triggered by repositionForLegendChange)');
                        }
                    } else {
                        debugLog('Incremental edit but no base transforms to remap');
                    }

                    // NOTE: Do NOT reset skipCaptureBaseConfig here!
                    // The flag should stay true for subsequent incremental edits.
                    // It will be reset to false only when a fresh generation starts.
                });
            });

            // Close popup when clicking outside
            const closeFeaturePopup = (e) => {
                if (!e.target.closest('.fixed.z-50')) {
                    if (clickedFeature.value) clickedFeature.value = null;
                }
            };

            // Close popups and panels with Escape key
            const handleEscapeKey = (e) => {
                if (e.key === 'Escape') {
                    if (clickedFeature.value) clickedFeature.value = null;
                    if (showCanvasControls.value) showCanvasControls.value = false;
                    if (showLegendPanel.value) showLegendPanel.value = false;
                    if (showFeaturePanel.value) showFeaturePanel.value = false;
                }
            };

            onMounted(() => {
                document.addEventListener('click', closeFeaturePopup);
                document.addEventListener('keydown', handleEscapeKey);
            });

            onUnmounted(() => {
                document.removeEventListener('click', closeFeaturePopup);
                document.removeEventListener('keydown', handleEscapeKey);
            });

            const setFeatureColor = async (feat, color, customCaption = null) => {
                // Use the best available qualifier for TSV generation
                const qualInfo = getFeatureQualifier(feat);
                if (!qualInfo) {
                    console.warn(`Cannot identify feature: ${feat.type} at ${feat.start}..${feat.end} (no locus_tag, gene, or product)`);
                    return;
                }
                const { qual, val } = qualInfo;

                // Use internal ID for UI tracking (unique across all features)
                const featureKey = feat.id;

                // Default caption if not provided
                const caption = customCaption || feat.product || feat.gene || feat.locus_tag || `${feat.type} at ${feat.start}..${feat.end}`;

                // Track override for UI display (store both color and caption)
                const oldOverride = featureColorOverrides[featureKey];
                const oldCaption = oldOverride?.caption;
                featureColorOverrides[featureKey] = { color, caption };

                // Apply instant preview (update SVG feature color directly)
                applyInstantPreview(feat, color, caption);

                // Handle legend entry FIRST, before adding rule to prevent watch race condition
                await Vue.nextTick();
                let actualCaption = caption;
                if (pyodideReady.value && caption) {
                    // Logic based on THIS FEATURE's existing legend entry (tracked by oldCaption):
                    // - oldCaption exists â†’ this feature already has a legend entry
                    // - oldCaption is undefined â†’ this feature doesn't have a legend entry yet

                    if (oldCaption) {
                        // This feature already has a legend entry
                        if (oldCaption === caption) {
                            // Same caption - just update the color of THIS feature's entry
                            updateLegendEntryColorByCaption(oldCaption, color);
                        } else {
                            // Caption changed - remove old entry, add new one
                            removeLegendEntry(oldCaption);
                            actualCaption = await addLegendEntry(caption, color);
                            if (actualCaption && typeof actualCaption === 'string') {
                                addedLegendCaptions.value.add(actualCaption);
                            }
                        }
                    } else {
                        // This feature doesn't have a legend entry yet - add new one
                        actualCaption = await addLegendEntry(caption, color);
                        if (actualCaption && typeof actualCaption === 'string') {
                            addedLegendCaptions.value.add(actualCaption);
                        }
                    }

                    // Update tracked caption if it changed (may have (N) suffix)
                    if (actualCaption && typeof actualCaption === 'string' && actualCaption !== caption) {
                        featureColorOverrides[featureKey] = { color, caption: actualCaption };
                    }
                    // Don't call extractLegendEntries here - will be called after rule is added
                }

                // Set flag to skip extractLegendEntries in watch(svgContent) during rule update
                // This prevents race condition where watcher overwrites correct legend state
                skipExtractOnSvgChange.value = true;

                // NOW add/update the rule with the correct caption (possibly numbered)
                const finalCaption = (actualCaption && typeof actualCaption === 'string') ? actualCaption : caption;
                const existingIdx = manualSpecificRules.findIndex(r =>
                    r.feat === feat.type && r.qual === qual && r.val === val
                );

                if (existingIdx >= 0) {
                    // Update existing rule with final caption
                    manualSpecificRules[existingIdx].color = color;
                    manualSpecificRules[existingIdx].cap = finalCaption;
                } else {
                    // Add new rule with final caption
                    manualSpecificRules.push({
                        feat: feat.type,
                        qual: qual,
                        val: val,
                        color: color,
                        cap: finalCaption
                    });
                }

                // Wait for watchers to complete, then refresh legend editor
                await Vue.nextTick();
                await Vue.nextTick();  // Double nextTick to ensure watcher completes
                skipExtractOnSvgChange.value = false;
                extractLegendEntries();  // Final refresh with correct legend state
            };

            // Clear feature list and save/restore legend positions when switching modes
            watch(() => mode.value, (newMode, oldMode) => {
                // Save current legend position to the old mode's variable
                if (oldMode === 'circular') {
                    circularLegendPosition.value = form.legend;
                } else if (oldMode === 'linear') {
                    linearLegendPosition.value = form.legend;
                }

                // Restore legend position for the new mode
                if (newMode === 'circular') {
                    form.legend = circularLegendPosition.value;
                } else if (newMode === 'linear') {
                    form.legend = linearLegendPosition.value;
                }

                // Clear feature list
                extractedFeatures.value = [];
                featureRecordIds.value = [];
                selectedFeatureRecordIdx.value = 0;
                Object.keys(featureColorOverrides).forEach(k => delete featureColorOverrides[k]);
                showFeaturePanel.value = false;
            });

            watch(() => files.d_color, async (newFile) => {
                if (!newFile) return;
                try {
                    const text = await newFile.text();
                    const lines = text.split(/\r?\n/);
                    let count = 0;
                    
                    for (const line of lines) {
                        // Skip comments, empty lines, and section headers
                        if (!line.trim() || line.trim().startsWith('#') || line.trim().startsWith('[')) continue;
                        
                        const parts = line.split('\t');
                        if (parts.length >= 2) {
                            const key = parts[0].trim();
                            const color = parts[1].trim();
                            
                            // Apply if it's a color code (#...) or color name (red, blue, etc.)
                            if (key && (color.startsWith('#') || /^[a-z]+$/i.test(color))) {
                                currentColors.value[key] = color;
                                count++;
                            }
                        }
                    }
                    console.log(`Loaded ${count} colors from file.`);
                } catch (e) {
                    console.error("Failed to load color file:", e);
                    alert("Failed to load color file. Please check the TSV format.");
                }
            });
            watch(() => files.t_color, async (newFile) => {
                if (!newFile) return;
                try {
                    const text = await newFile.text();
                    const lines = text.split(/\r?\n/);
                    let count = 0;
                    const rulesWithCaptions = [];

                    for (const line of lines) {
                        // Skip comments and empty lines
                        if (!line.trim() || line.trim().startsWith('#')) continue;

                        const parts = line.split('\t');
                        // TSV format: Feature, Qualifier, Regex, Color, [Caption]
                        if (parts.length >= 4) {
                            const rule = {
                                feat: parts[0].trim(),
                                qual: parts[1].trim(),
                                val: parts[2].trim(),
                                color: parts[3].trim(),
                                cap: parts[4] ? parts[4].trim() : "",
                                fromFile: true  // Mark as loaded from file (preserved on reset)
                            };
                            manualSpecificRules.push(rule);
                            count++;
                            // Track rules with captions for legend entry creation
                            if (rule.cap) {
                                rulesWithCaptions.push(rule);
                            }
                        }
                    }
                    console.log(`Loaded ${count} rules from file.`);

                    // Add legend entries for rules with captions
                    if (rulesWithCaptions.length > 0 && pyodideReady.value) {
                        await Vue.nextTick();
                        for (const rule of rulesWithCaptions) {
                            const actualCaption = await addLegendEntry(rule.cap, rule.color);
                            if (actualCaption && typeof actualCaption === 'string') {
                                addedLegendCaptions.value.add(actualCaption);
                                // Also track as file-loaded (preserved on reset)
                                fileLegendCaptions.value.add(actualCaption);
                            }
                        }
                        extractLegendEntries();
                        console.log(`Added ${rulesWithCaptions.length} legend entries from specific table.`);
                    }
                } catch (e) {
                    console.error("Failed to load rules file:", e);
                    alert("Failed to load rules file. Please check the TSV format.");
                }
            });
            watch(() => files.qualifier_priority, async (newFile) => {
                if (!newFile) return;
                try {
                    const text = await newFile.text();
                    const lines = text.split(/\r?\n/);
                    let count = 0;
                    
                    for (const line of lines) {
                        if (!line.trim() || line.trim().startsWith('#')) continue;
                        const parts = line.split('\t');
                        // TSV format: Feature<TAB>Qualifier1,Qualifier2,Qualifier3
                        if (parts.length >= 2) {
                            const feat = parts[0].trim();
                            const order = parts[1].trim();
                            
                            // If the same feature exists, overwrite it; otherwise, add it.
                            const idx = manualPriorityRules.findIndex(r => r.feat === feat);
                            if (idx >= 0) {
                                manualPriorityRules[idx].order = order;
                            } else {
                                manualPriorityRules.push({ feat, order });
                            }
                            count++;
                        }
                    }
                    console.log(`Loaded ${count} priority rules.`);
                } catch (e) {
                    console.error("Failed to load priority file:", e);
                    alert("Failed to load priority file.");
                }
            });
            watch(() => files.whitelist, async (newFile) => {
                if (!newFile) return;
                try {
                    const text = await newFile.text();
                    const lines = text.split(/\r?\n/);
                    let count = 0;
                    
                    for (const line of lines) {
                        if (!line.trim() || line.trim().startsWith('#')) continue;
                        const parts = line.split('\t');
                        if (parts.length >= 3) {
                            manualWhitelist.push({
                                feat: parts[0].trim(),
                                qual: parts[1].trim(),
                                key: parts[2].trim()
                            });
                            count++;
                        }
                    }
                    console.log(`Loaded ${count} whitelist rules.`);
                } catch (e) {
                    console.error("Failed to load whitelist file:", e);
                    alert("Failed to load whitelist file.");
                }
            });

            watch(() => files.blacklist, async (newFile) => {
                if (!newFile) return;
                try {
                    const text = await newFile.text();
                    // Load newline or comma-separated text and append to the textarea
                    const words = text.split(/[\r\n,]+/).map(w => w.trim()).filter(w => w);
                    
                    if (words.length > 0) {
                        const existing = manualBlacklist.value ? manualBlacklist.value.trim() : "";
                        // If there is existing text, add a comma before appending
                        const separator = existing && !existing.endsWith(',') ? ", " : "";
                        manualBlacklist.value = existing + separator + words.join(", ");
                        
                        console.log(`Loaded ${words.length} blacklist words.`);
                    }
                } catch (e) {
                    console.error("Failed to load blacklist file:", e);
                    alert("Failed to load blacklist file.");
                }
            });

            // Debounce helper for definition text updates
            let definitionUpdateTimeout = null;
            const updateDefinitionText = async () => {
                if (!pyodideReady.value || !svgContent.value || mode.value !== 'circular') return;
                if (!svgContainer.value) return;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                // Find the current GenBank file path
                const gbPath = cInputType.value === 'gb' ? '/input.gb' : '/input.gb';

                try {
                    const species = form.species || '';
                    const strain = form.strain || '';
                    const fontSize = adv.def_font_size || 18;

                    const resultJson = pyodide.runPython(
                        `regenerate_definition_svg("${gbPath}", ${species ? `"${species.replace(/"/g, '\\"')}"` : 'None'}, ${strain ? `"${strain.replace(/"/g, '\\"')}"` : 'None'}, ${fontSize})`
                    );
                    const result = JSON.parse(resultJson);

                    if (result.error) {
                        console.error("Definition update error:", result.error);
                        return;
                    }

                    // Find and replace the definition group in the SVG (using _definition suffix)
                    const definitionGroupId = result.definition_group_id;
                    console.log('Looking for definition group:', definitionGroupId);
                    const existingGroup = svg.getElementById(definitionGroupId);

                    if (existingGroup) {
                        // Parse the new SVG group
                        const parser = new DOMParser();
                        const newDoc = parser.parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${result.svg}</svg>`, 'image/svg+xml');
                        const newGroup = newDoc.querySelector('g');

                        if (newGroup) {
                            // Preserve the transform of the existing group
                            const existingTransform = existingGroup.getAttribute('transform');
                            if (existingTransform) {
                                newGroup.setAttribute('transform', existingTransform);
                            }

                            // Replace the old group with the new one
                            existingGroup.parentNode.replaceChild(
                                svg.ownerDocument.importNode(newGroup, true),
                                existingGroup
                            );

                            // Update the stored SVG content
                            skipCaptureBaseConfig.value = true;
                            const idx = selectedResultIndex.value;
                            if (idx >= 0 && results.value.length > idx) {
                                const serializer = new XMLSerializer();
                                results.value[idx] = { ...results.value[idx], content: serializer.serializeToString(svg) };
                            }

                            console.log('Definition text updated');
                        }
                    } else {
                        console.log('Definition group not found in SVG:', definitionGroupId);
                    }
                } catch (e) {
                    console.error("Failed to update definition text:", e);
                }
            };

            // Watch for species/strain changes with debounce
            watch(() => form.species, () => {
                if (definitionUpdateTimeout) clearTimeout(definitionUpdateTimeout);
                definitionUpdateTimeout = setTimeout(updateDefinitionText, 500);
            });
            watch(() => form.strain, () => {
                if (definitionUpdateTimeout) clearTimeout(definitionUpdateTimeout);
                definitionUpdateTimeout = setTimeout(updateDefinitionText, 500);
            });
            watch(() => adv.def_font_size, () => {
                if (definitionUpdateTimeout) clearTimeout(definitionUpdateTimeout);
                definitionUpdateTimeout = setTimeout(updateDefinitionText, 500);
            });

            onMounted(async () => {
                try {
                    pyodide = await loadPyodide();
                    loadingStatus.value = "Installing dependencies...";
                    await pyodide.loadPackage("micropip");
                    const micropip = pyodide.pyimport("micropip");
                    await micropip.install(["biopython","svgwrite", "pandas", "fonttools", "bcbio-gff"]);
                    loadingStatus.value = "Installing gbdraw...";
                    await micropip.install(GBDRAW_WHEEL_NAME);
                    await pyodide.runPythonAsync(`
                        import warnings
                        warnings.simplefilter('ignore', SyntaxWarning)
                        import tomllib
                        from importlib import resources
                        import json
                        import traceback
                        import glob
                        import os
                        from gbdraw.circular import circular_main
                        from gbdraw.linear import linear_main
                        def get_palettes_json():
                            try:
                                with resources.files("gbdraw.data").joinpath("color_palettes.toml").open("rb") as fh:
                                    return json.dumps(tomllib.load(fh))
                            except: return "{}"

                        def run_gbdraw_wrapper(mode, args):

                            for f in glob.glob("*.svg"):
                                try: os.remove(f)
                                except: pass

                            full_args = args + ["-f", "svg"]
                            try:
                                if mode == 'circular': circular_main(full_args)
                                else: linear_main(full_args)
                            except SystemExit as e:
                                if e.code != 0: return json.dumps({"error": f"SystemExit: {e}"})
                            except Exception:
                                return json.dumps({"error": traceback.format_exc()})

                            files = glob.glob("*.svg")
                            if not files: return json.dumps({"error": "No output files generated."})
                            results = []
                            for fname in sorted(files):
                                with open(fname, "r") as f:
                                    results.append({"name": fname, "content": f.read()})
                            return json.dumps(results)

                        def generate_legend_entry_svg(caption, color, y_offset, rect_size=14, font_size=14, font_family="Arial", x_offset=0):
                            """Generate SVG elements for a single legend entry"""
                            from svgwrite.path import Path
                            from svgwrite.text import Text
                            import io

                            # Create color rectangle path
                            half = rect_size / 2
                            rect_d = f"M 0,{-half} L {rect_size},{-half} L {rect_size},{half} L 0,{half} z"
                            rect_svg = f'<path d="{rect_d}" fill="{color}" stroke="none" transform="translate({x_offset}, {y_offset})"/>'

                            # Create text element
                            x_margin = (22 / 14) * rect_size
                            text_svg = f'<text font-size="{font_size}" font-family="{font_family}" dominant-baseline="central" text-anchor="start" transform="translate({x_offset + x_margin}, {y_offset})">{caption}</text>'

                            return json.dumps({"rect": rect_svg, "text": text_svg})

                        def regenerate_definition_svg(gb_path, species=None, strain=None, font_size=18):
                            """Regenerate just the definition group SVG for instant preview"""
                            from Bio import SeqIO
                            from gbdraw.render.groups.circular.definition import DefinitionGroup
                            from gbdraw.canvas import CircularCanvasConfigurator
                            from importlib import resources

                            try:
                                # Load default config
                                with resources.files("gbdraw.data").joinpath("config.toml").open("rb") as fh:
                                    config_dict = tomllib.load(fh)

                                # Override font size if provided
                                if font_size:
                                    config_dict["objects"]["definition"]["circular"]["font_size"] = font_size

                                # Parse the GenBank file
                                records = list(SeqIO.parse(gb_path, "genbank"))
                                if not records:
                                    return json.dumps({"error": "No records found"})

                                record = records[0]

                                # Create canvas config
                                canvas_config = CircularCanvasConfigurator(
                                    output_prefix="temp",
                                    config_dict=config_dict,
                                    legend="none",
                                    gb_record=record,
                                )

                                # Create definition group with custom species/strain
                                def_group = DefinitionGroup(
                                    gb_record=record,
                                    canvas_config=canvas_config,
                                    config_dict=config_dict,
                                    species=species if species else None,
                                    strain=strain if strain else None,
                                )

                                # Get the SVG content
                                group = def_group.get_group()
                                # Serialize to string using svgwrite's tostring() method
                                svg_content = group.tostring()

                                # Return the definition group ID (with _definition suffix)
                                definition_group_id = def_group.definition_group_id
                                return json.dumps({"svg": svg_content, "definition_group_id": definition_group_id})
                            except Exception as e:
                                import traceback
                                return json.dumps({"error": traceback.format_exc()})

                        def extract_features_from_genbank(gb_path):
                            """Extract feature info from GenBank file for UI display"""
                            import hashlib
                            from Bio import SeqIO
                            features = []
                            record_ids = []
                            idx = 0
                            try:
                                for rec_idx, record in enumerate(SeqIO.parse(gb_path, "genbank")):
                                    record_id = record.id or f"Record_{rec_idx}"
                                    record_ids.append(record_id)
                                    for feat in record.features:
                                        if feat.type in ['CDS', 'tRNA', 'rRNA', 'ncRNA', 'misc_RNA', 'tmRNA',
                                                         'repeat_region', 'misc_feature', 'mobile_element',
                                                         'regulatory', 'gene', 'mRNA', 'exon', 'intron']:
                                            # Overall coordinates for display
                                            start = int(feat.location.start)
                                            end = int(feat.location.end)
                                            strand_raw = feat.location.strand

                                            # For svg_id hash, use FIRST part's coordinates (matches Python drawer)
                                            # CompoundLocation has .parts, SimpleLocation doesn't
                                            if hasattr(feat.location, 'parts') and feat.location.parts:
                                                first_part = feat.location.parts[0]
                                                hash_start = int(first_part.start)
                                                hash_end = int(first_part.end)
                                                hash_strand = first_part.strand
                                            else:
                                                hash_start = start
                                                hash_end = end
                                                hash_strand = strand_raw

                                            # Compute same hash as SVG rendering uses (must match Python drawer)
                                            key = f"{feat.type}:{hash_start}:{hash_end}:{hash_strand}"
                                            svg_id = "f" + hashlib.md5(key.encode()).hexdigest()[:8]
                                            features.append({
                                                "id": f"f{idx}",  # Unique internal ID for UI tracking
                                                "svg_id": svg_id,  # Matches SVG path id attribute
                                                "record_id": record_id,  # For multi-record filtering
                                                "record_idx": rec_idx,
                                                "type": feat.type,
                                                "start": start,
                                                "end": end,
                                                "strand": "+" if strand_raw == 1 else "-",
                                                "locus_tag": feat.qualifiers.get("locus_tag", [""])[0],
                                                "gene": feat.qualifiers.get("gene", [""])[0],
                                                "product": feat.qualifiers.get("product", [""])[0],
                                                "note": feat.qualifiers.get("note", [""])[0][:50] if feat.qualifiers.get("note") else "",
                                            })
                                            idx += 1
                            except Exception as e:
                                return json.dumps({"error": str(e)})
                            return json.dumps({"features": features, "record_ids": record_ids})
                    `);
                    const paletteJson = pyodide.runPython("get_palettes_json()");
                    const allPalettes = JSON.parse(paletteJson);
                    paletteNames.value = Object.keys(allPalettes).filter(k => k !== 'title').sort();
                    currentColors.value = allPalettes['default'] || {};
                    pyodideReady.value = true;
                } catch (e) {
                    loadingStatus.value = "Startup Error: " + e.message;
                    console.error(e);
                }
            });

            const updatePalette = () => {
                if(!pyodide) return;
                const paletteJson = pyodide.runPython("get_palettes_json()");
                const all = JSON.parse(paletteJson);
                currentColors.value =  { ...(all[selectedPalette.value] || {}) };
            };
            const resetColors = () => updatePalette();
            const writeToFS = async (fileObj, path) => {
                if(!fileObj) return false;
                const buffer = await fileObj.arrayBuffer();
                pyodide.FS.writeFile(path, new Uint8Array(buffer));
                return true;
            };

            const runAnalysis = async () => {
                if (!pyodideReady.value) return;
                processing.value = true;
                results.value = [];
                selectedResultIndex.value = 0;
                errorLog.value = null;
                zoom.value = 1.0;
                // Reset incremental edit flags for fresh generation
                // This ensures the watch(svgContent) treats this as a new diagram, not an edit
                skipCaptureBaseConfig.value = false;
                skipPositionReapply.value = false;
                // Clear stored pairwise match factors for re-calculation
                pairwiseMatchFactors.value = {};
                // Clear tracked legend entries (will be regenerated)
                addedLegendCaptions.value = new Set();
                fileLegendCaptions.value = new Set();
                // Clear feature color overrides (custom legend entries from previous records)
                Object.keys(featureColorOverrides).forEach(k => delete featureColorOverrides[k]);
                legendEntries.value = [];
                // Clear deleted legend entries (fresh start)
                deletedLegendEntries.value = [];
                // Clear legend color overrides (custom colors from Legend Editor)
                Object.keys(legendColorOverrides).forEach(k => delete legendColorOverrides[k]);
                // Clear original legend order and colors (will be captured on first extraction)
                originalLegendOrder.value = [];
                originalLegendColors.value = {};
                // Store current palette's pairwise colors as reference for interpolation
                window._origPairwiseMin = currentColors.value.pairwise_match_min || '#FFE7E7';
                window._origPairwiseMax = currentColors.value.pairwise_match_max || '#FF7272';

                try {
                    let args = [];
                    
                    if(form.prefix && form.prefix.trim() !== "") args.push("-o", form.prefix.trim());
                    if(form.species) args.push("--species", form.species);
                    if(form.strain) args.push("--strain", form.strain);
                    if(form.separate_strands) args.push("--separate_strands");
                    
                    if(adv.features.length) args.push("-k", adv.features.join(","));
                    if(adv.window_size) args.push("--window", adv.window_size);
                    if(adv.step_size) args.push("--step", adv.step_size);
                    if(adv.nt && adv.nt !== "GC") args.push("--nt", adv.nt);

                    if(adv.def_font_size) args.push("--definition_font_size", adv.def_font_size);
                    if(adv.label_font_size) args.push("--label_font_size", adv.label_font_size);
                    
                    // Styles
                    if(adv.block_stroke_width !== null) args.push("--block_stroke_width", adv.block_stroke_width);
                    if(adv.block_stroke_color) args.push("--block_stroke_color", adv.block_stroke_color);
                    if(adv.line_stroke_width !== null) args.push("--line_stroke_width", adv.line_stroke_width);
                    if(adv.line_stroke_color) args.push("--line_stroke_color", adv.line_stroke_color);
                    if(adv.axis_stroke_width !== null) args.push("--axis_stroke_width", adv.axis_stroke_width);
                    if(adv.axis_stroke_color) args.push("--axis_stroke_color", adv.axis_stroke_color);
                    
                    // Legend Params
                    if(adv.legend_box_size) args.push("--legend_box_size", adv.legend_box_size);
                    if(adv.legend_font_size) args.push("--legend_font_size", adv.legend_font_size);

                    // Colors
                    let dContent = "";
                    for(const [k,v] of Object.entries(currentColors.value)) dContent += `${k}\t${v}\n`;
                    pyodide.FS.writeFile("/combined_d.tsv", dContent);
                    args.push("-d", "/combined_d.tsv");

                    let tContent = "";
                    // if (files.t_color) { tContent = await files.t_color.text(); if(!tContent.endsWith('\n')) tContent += '\n'; }
                    manualSpecificRules.forEach(r => { tContent += `${r.feat}\t${r.qual}\t${r.val}\t${r.color}\t${r.cap}\n`; });
                    if(tContent.trim() !== "") { pyodide.FS.writeFile("/combined_t.tsv", tContent); args.push("-t", "/combined_t.tsv"); }

                    // Filtering
                    if (filterMode.value === 'Blacklist') {
                        // Even if there is a file (files.blacklist), ignore it and use the manualBlacklist taken in by Watch as correct
                        if (manualBlacklist.value) { 
                            args.push("--label_blacklist", manualBlacklist.value.replace(/\n/g, ",")); 
                        }
                    } else if (filterMode.value === 'Whitelist') {
                        // Even if there is a file (files.whitelist), ignore it and use the manualWhitelist taken in by Watch as correct
                        if (manualWhitelist.length > 0) {
                            let wlContent = "";
                            manualWhitelist.forEach(r => { if(r.feat && r.qual) wlContent += `${r.feat}\t${r.qual}\t${r.key}\n` });
                            pyodide.FS.writeFile("/manual_wl.tsv", wlContent);
                            args.push("--label_whitelist", "/manual_wl.tsv");
                        }
                    }
                    // Priority File
                    let pContent = "";
                    manualPriorityRules.forEach(r => {
                        pContent += `${r.feat}\t${r.order}\n`;
                    });
                    
                    if (pContent.trim() !== "") {
                        pyodide.FS.writeFile("/priority.tsv", pContent);
                        args.push("--qualifier_priority", "/priority.tsv");
                    }

                    if (mode.value === 'circular') {
                        args.push("--track_type", form.track_type, "-l", form.legend);
                        if(form.show_labels) args.push("--show_labels");
                        if(form.allow_inner_labels) args.push("--allow_inner_labels");
                        if(form.suppress_gc) args.push("--suppress_gc");
                        if(form.suppress_skew) args.push("--suppress_skew");
                        
                        // Circular Offsets
                        if(adv.outer_label_x_offset) args.push("--outer_label_x_radius_offset", adv.outer_label_x_offset);
                        if(adv.outer_label_y_offset) args.push("--outer_label_y_radius_offset", adv.outer_label_y_offset);
                        if(adv.inner_label_x_offset) args.push("--inner_label_x_radius_offset", adv.inner_label_x_offset);
                        if(adv.inner_label_y_offset) args.push("--inner_label_y_radius_offset", adv.inner_label_y_offset);
                        if(adv.scale_interval) args.push("--scale_interval", adv.scale_interval);

                        if (cInputType.value === 'gb') {
                            if(!files.c_gb) throw new Error("Please upload a GenBank file.");
                            await writeToFS(files.c_gb, "/input.gb"); args.push("--gbk", "/input.gb");
                        } else {
                            if(!files.c_gff || !files.c_fasta) throw new Error("GFF3 and FASTA are required.");
                            await writeToFS(files.c_gff, "/input.gff"); await writeToFS(files.c_fasta, "/input.fasta");
                            args.push("--gff", "/input.gff", "--fasta", "/input.fasta");
                        }

                    } else { 
                        args.push("--scale_style", form.scale_style);
                        if(form.align_center) args.push("--align_center");
                        if(form.show_gc) args.push("--show_gc");
                        if(form.show_skew) args.push("--show_skew");
                        if(form.normalize_length) args.push("--normalize_length");
                        if(form.legend !== 'right') args.push("-l", form.legend);
                        args.push("--bitscore", adv.min_bitscore, "--evalue", adv.evalue, "--identity", adv.identity);
                        
                        // Linear Labels
                        if(form.show_labels_linear !== 'none') {
                            args.push("--show_labels");
                            if(form.show_labels_linear === 'first') args.push("first");
                        }
                        // Linear Specifics
                        if(adv.resolve_overlaps) args.push("--resolve_overlaps");
                        if(adv.feature_height) args.push("--feature_height", adv.feature_height);
                        if(adv.gc_height) args.push("--gc_height", adv.gc_height);
                        if(adv.comparison_height) args.push("--comparison_height", adv.comparison_height);
                        
                        // Linear Scale Settings
                        if(adv.scale_interval) args.push("--scale_interval", adv.scale_interval);
                        if(adv.scale_font_size) args.push("--scale_font_size", adv.scale_font_size);
                        if(adv.scale_stroke_width) args.push("--scale_stroke_width", adv.scale_stroke_width);
                        if(adv.scale_stroke_color) args.push("--scale_stroke_color", adv.scale_stroke_color);

                        let inputArgs = [], blastArgs = [];
                        for(let i=0; i<linearSeqs.length; i++) {
                            const seq = linearSeqs[i];
                            if (lInputType.value === 'gb') {
                                if(!seq.gb) throw new Error(`Sequence #${i+1}: Missing GenBank file.`);
                                await writeToFS(seq.gb, `/seq_${i}.gb`); inputArgs.push(`/seq_${i}.gb`);
                            } else {
                                if(!seq.gff || !seq.fasta) throw new Error(`Sequence #${i+1}: GFF3 and FASTA are required.`);
                                await writeToFS(seq.gff, `/seq_${i}.gff`); await writeToFS(seq.fasta, `/seq_${i}.fasta`);
                            }
                            if(i < linearSeqs.length - 1 && seq.blast) {
                                await writeToFS(seq.blast, `/blast_${i}.txt`); blastArgs.push(`/blast_${i}.txt`);
                            }
                        }
                        if(lInputType.value === 'gb') args.push("--gbk", ...inputArgs);
                        else {
                             let gffs = [], fastas = [];
                             for(let i=0; i<linearSeqs.length; i++) { gffs.push(`/seq_${i}.gff`); fastas.push(`/seq_${i}.fasta`); }
                             args.push("--gff", ...gffs, "--fasta", ...fastas);
                        }
                        if(blastArgs.length) args.push("-b", ...blastArgs);
                    }

                    console.log("CMD:", args.join(" "));
                    const jsonResult = pyodide.globals.get("run_gbdraw_wrapper")(mode.value, pyodide.toPy(args.map(String)));
                    const res = JSON.parse(jsonResult);
                    if(res.error) throw new Error(res.error);
                    results.value = res;

                    // Store legend position used at generation time
                    generatedLegendPosition.value = form.legend;

                    // Extract features for color editor (only for GenBank input)
                    extractedFeatures.value = [];

                    // Helper to rebuild featureColorOverrides from manualSpecificRules
                    const rebuildColorOverrides = (features) => {
                        // Clear existing overrides
                        Object.keys(featureColorOverrides).forEach(k => delete featureColorOverrides[k]);

                        // For each feature, check if there's a matching rule
                        for (const feat of features) {
                            // Look for a matching rule in manualSpecificRules
                            for (const rule of manualSpecificRules) {
                                if (rule.feat !== feat.type) continue;

                                let matches = false;
                                // Hash qualifier - highest priority, most reliable
                                if (rule.qual === 'hash' && feat.svg_id) {
                                    try {
                                        const regex = new RegExp(rule.val, 'i');
                                        matches = regex.test(feat.svg_id);
                                    } catch (e) {
                                        matches = feat.svg_id === rule.val;
                                    }
                                } else if (rule.qual === 'locus_tag' && feat.locus_tag) {
                                    try {
                                        const regex = new RegExp(rule.val, 'i');
                                        matches = regex.test(feat.locus_tag);
                                    } catch (e) {
                                        matches = feat.locus_tag === rule.val;
                                    }
                                } else if (rule.qual === 'gene' && feat.gene) {
                                    try {
                                        const regex = new RegExp(rule.val, 'i');
                                        matches = regex.test(feat.gene);
                                    } catch (e) {
                                        matches = feat.gene.toLowerCase().includes(rule.val.toLowerCase());
                                    }
                                } else if (rule.qual === 'product' && feat.product) {
                                    try {
                                        const regex = new RegExp(rule.val, 'i');
                                        matches = regex.test(feat.product);
                                    } catch (e) {
                                        matches = feat.product.toLowerCase().includes(rule.val.toLowerCase());
                                    }
                                }

                                if (matches) {
                                    // Use internal ID as key, store {color, caption} object
                                    featureColorOverrides[feat.id] = { color: rule.color, caption: rule.cap };
                                    break; // First match wins
                                }
                            }
                        }
                    };

                    if (mode.value === 'circular' && cInputType.value === 'gb') {
                        try {
                            const featJson = pyodide.globals.get("extract_features_from_genbank")("/input.gb");
                            const featData = JSON.parse(featJson);
                            if (!featData.error && featData.features) {
                                extractedFeatures.value = featData.features;
                                featureRecordIds.value = featData.record_ids || [];
                                selectedFeatureRecordIdx.value = 0;
                                rebuildColorOverrides(featData.features);
                                console.log(`Extracted ${featData.features.length} features from ${featData.record_ids.length} record(s) for color editor.`);
                            }
                        } catch (e) {
                            console.log("Could not extract features:", e);
                        }
                    } else if (mode.value === 'linear' && lInputType.value === 'gb' && linearSeqs.length > 0) {
                        // Extract features from ALL GenBank files in linear mode
                        try {
                            let allFeatures = [];
                            let allRecordLabels = [];
                            for (let i = 0; i < linearSeqs.length; i++) {
                                const featJson = pyodide.globals.get("extract_features_from_genbank")(`/seq_${i}.gb`);
                                const featData = JSON.parse(featJson);
                                if (!featData.error && featData.features) {
                                    // Add file index to each feature and create unique record labels
                                    featData.features.forEach(f => {
                                        f.fileIdx = i;  // File index
                                        f.displayRecordId = `File ${i + 1}: ${f.record_id}`;
                                        // Make id unique across files by prefixing with file index
                                        f.id = `file${i}_${f.id}`;
                                    });
                                    allFeatures = allFeatures.concat(featData.features);
                                    // Add record labels with file prefix
                                    featData.record_ids.forEach((rid, ridx) => {
                                        allRecordLabels.push({ label: `File ${i + 1}: ${rid}`, fileIdx: i, recordIdx: ridx });
                                    });
                                }
                            }
                            extractedFeatures.value = allFeatures;
                            featureRecordIds.value = allRecordLabels.map(r => r.label);
                            selectedFeatureRecordIdx.value = 0;
                            rebuildColorOverrides(allFeatures);
                            console.log(`Extracted ${allFeatures.length} features from ${linearSeqs.length} file(s) for color editor.`);
                        } catch (e) {
                            console.log("Could not extract features:", e);
                        }
                    }

                } catch (e) {
                    errorLog.value = e.message;
                } finally {
                    processing.value = false;
                }
            };

            const downloadSVG = () => {
            if(!svgContent.value) return;
            const blob = new Blob([svgContent.value], {type: "image/svg+xml"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = results.value[selectedResultIndex.value].name;
            a.click();
            URL.revokeObjectURL(url);
            };

            const downloadPNG = () => {
                if(!svgContent.value) return;
                const svgEl = document.createElement('div');
                svgEl.innerHTML = svgContent.value;
                const svg = svgEl.querySelector('svg');
                if(!svg) return;
                let w = parseFloat(svg.getAttribute('width')); let h = parseFloat(svg.getAttribute('height'));
                if (!w || !h) { const parts = svg.getAttribute('viewBox').split(' '); w = parseFloat(parts[2]); h = parseFloat(parts[3]); }
                const canvas = document.createElement("canvas");
                const dpi = parseInt(downloadDpi.value); const scale = dpi / 96; 
                canvas.width = w * scale; canvas.height = h * scale;
                const ctx = canvas.getContext("2d");
                const img = new Image();
                const svgData = new XMLSerializer().serializeToString(svg);
                const blob = new Blob([svgData], {type: "image/svg+xml;charset=utf-8"});
                const url = URL.createObjectURL(blob);
                img.onload = () => {
                    ctx.fillStyle = "white"; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    canvas.toBlob(async (blob) => {
                         const fixedBlob = await setDpiInPng(blob, dpi);
                         const downloadUrl = URL.createObjectURL(fixedBlob);
                         const link = document.createElement('a');
                         let fname = results.value[selectedResultIndex.value].name;
                         fname = fname.replace(/\.svg$/i, ".png");
                         link.download = fname; link.href = downloadUrl; link.click();
                         URL.revokeObjectURL(downloadUrl); URL.revokeObjectURL(url);
                    }, "image/png");
                };
                img.onerror = () => {
                    console.error('Failed to load SVG for PNG conversion');
                    URL.revokeObjectURL(url);
                };
                img.src = url;
            };

            // ---- New PDF Download Function ----
            const downloadPDF = async () => {
                if(!svgContent.value) return;

                // 1. Create temporary SVG element to read dimensions
                const svgEl = document.createElement('div');
                svgEl.innerHTML = svgContent.value;
                const svg = svgEl.querySelector('svg');
                if(!svg) return;

                // 2. Determine Width/Height (Use attributes or viewBox)
                let w = parseFloat(svg.getAttribute('width'));
                let h = parseFloat(svg.getAttribute('height'));
                if (!w || !h) { 
                    const parts = svg.getAttribute('viewBox').split(' '); 
                    w = parseFloat(parts[2]); 
                    h = parseFloat(parts[3]); 
                }

                // 3. Initialize jsPDF (Use 'pt' as unit for vector fidelity)
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    orientation: w > h ? 'l' : 'p',
                    unit: 'pt',
                    format: [w, h]
                });

                // 4. Convert SVG to PDF
                await doc.svg(svg, {
                    x: 0,
                    y: 0,
                    width: w,
                    height: h
                });

                // 5. Save File
                let fname = results.value[selectedResultIndex.value].name;
                fname = fname.replace(/\.svg$/i, ".pdf");
                doc.save(fname);
            };

            // ---- Config I/O Functions ----
            const exportConfig = () => {
                const configData = {
                    form: form,
                    adv: adv,
                    colors: currentColors.value,
                    palette: selectedPalette.value,
                    rules: manualSpecificRules,
                    filterMode: filterMode.value,
                    whitelist: manualWhitelist,
                    blacklistText: manualBlacklist.value
                };
                const blob = new Blob([JSON.stringify(configData, null, 2)], {type: "application/json"});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = "gbdraw_config.json";
                a.click();
                URL.revokeObjectURL(url);
            };
            const safeDeepMerge = (target, source) => {
                if (!source || typeof source !== 'object') return;

                Object.keys(source).forEach(key => {
                    // 1. Prevent prototype pollution
                    if (['__proto__', 'constructor', 'prototype'].includes(key)) return;
                    
                    // 2. Ignore keys not present in target (whitelisting effect)
                    if (!Object.prototype.hasOwnProperty.call(target, key)) return;

                    const targetValue = target[key];
                    const sourceValue = source[key];

                    // 3. Recursive merge for objects
                    if (targetValue && typeof targetValue === 'object' && !Array.isArray(targetValue) &&
                        sourceValue && typeof sourceValue === 'object' && !Array.isArray(sourceValue)) {
                        safeDeepMerge(targetValue, sourceValue);
                    }
                    // 4. For arrays, intentionally overwrite (replacing lists of settings is natural)
                    else if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {
                        target[key].splice(0, target[key].length, ...sourceValue);
                    }
                    // 5. Update value only if types match or initial value is null
                    else if (typeof targetValue === typeof sourceValue || targetValue === null) {
                        target[key] = sourceValue;
                    }
                });
            };
            const importConfig = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                if (file.size > 10 * 1024 * 1024) {
                    alert("Config file is too large.");
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result, (key, value) => {
                            if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
                                return undefined;
                            }
                            return value;
                        });
                        
                        if (data.form) safeDeepMerge(form, data.form);
                        if (data.adv) safeDeepMerge(adv, data.adv);
                        if (data.colors) currentColors.value = data.colors; 
                        if (data.palette) selectedPalette.value = data.palette;
                        
                        if (data.rules && Array.isArray(data.rules)) {
                            manualSpecificRules.length = 0;
                            data.rules.forEach(r => {
                                manualSpecificRules.push({
                                    feat: String(r.feat || ''),
                                    qual: String(r.qual || ''),
                                    val: String(r.val || ''),
                                    color: String(r.color || '#000000'),
                                    cap: String(r.cap || '')
                                });
                            });
                        }
                        if (data.filterMode) filterMode.value = data.filterMode;
                        if (data.whitelist && Array.isArray(data.whitelist)) {
                            manualWhitelist.length = 0;
                            data.whitelist.forEach(w => {
                            manualWhitelist.push({
                                feat: String(w.feat || ''),
                                qual: String(w.qual || ''),
                                key: String(w.key || '')
                            });
                        });
                    }
                        if (data.blacklistText) manualBlacklist.value = String(data.blacklistText);
                        
                        alert("Configuration loaded successfully!");
                    } catch (err) {
                        console.error(err);
                        alert("Failed to load config: Invalid JSON structure.");
                    }
                };
                reader.readAsText(file);
                e.target.value = ''; 
            };

            return {
                pyodideReady, processing, loadingStatus, errorLog, results, selectedResultIndex, svgContent, zoom, handleWheel,
                canvasContainerRef, startPan, doPan, endPan,
                sidebarWidth, startResizing,
                mode, cInputType, lInputType, files, linearSeqs, form, adv,
                paletteNames, selectedPalette, currentColors, updatePalette, resetColors,
                filterMode, manualBlacklist, manualWhitelist, featureKeys, newColorFeat, newColorVal, addCustomColor,
                newFeatureToAdd, addFeature, manualSpecificRules, newSpecRule, addSpecificRule,
                // Feature Color Editor
                extractedFeatures, featureRecordIds, selectedFeatureRecordIdx,
                showFeaturePanel, featureSearch, filteredFeatures,
                featureColorOverrides, getFeatureColor, setFeatureColor, canEditFeatureColor,
                // SVG Feature Click
                svgContainer, clickedFeature, clickedFeaturePos, updateClickedFeatureColor,
                resetClickedFeatureFillColor, updateClickedFeatureStroke, resetClickedFeatureStroke, applyStrokeToAllSiblings,
                // Color Scope Dialog
                colorScopeDialog, handleColorScopeChoice,
                // Reset Color Dialog
                resetColorDialog, handleResetColorChoice,
                // Legend Editor
                showLegendPanel, legendEntries, newLegendCaption, newLegendColor,
                updateLegendEntryColor, updateLegendEntryCaption, deleteLegendEntry, addNewLegendEntry,
                moveLegendEntryUp, moveLegendEntryDown, sortLegendEntries, sortLegendEntriesByDefault, resetLegendPosition,
                // Legend Entry Stroke
                getLegendEntryStrokeColor, getLegendEntryStrokeWidth,
                updateLegendEntryStrokeColor, updateLegendEntryStrokeWidth, resetLegendEntryStroke, resetAllStrokes,
                // Diagram Drag & Canvas
                resetAllPositions, canvasPadding, showCanvasControls, resetCanvasPadding,
                downloadDpi, runAnalysis, downloadSVG, downloadPNG, downloadPDF,
                exportConfig, importConfig, manualPriorityRules, newPriorityRule, addPriorityRule
            };
        }
    }).mount('#app');
</script>
</body>
</html>