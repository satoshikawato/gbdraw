<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com https://cdn.tailwindcss.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com;
    style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://unpkg.com https://cdn.jsdelivr.net;
    font-src 'self' https://fonts.gstatic.com https://unpkg.com https://cdn.jsdelivr.net data:;
    img-src 'self' data: blob:;
    connect-src 'self' https://cdn.jsdelivr.net https://unpkg.com https://cdn.tailwindcss.com https://pypi.org https://files.pythonhosted.org https://cdnjs.cloudflare.com;
    worker-src 'self' blob:;
    object-src 'none';
    base-uri 'self';
    form-action 'self';
    frame-ancestors 'none';
    ">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gbdraw Web App</title>
    <script src="https://unpkg.com/vue@3.5.25/dist/vue.global.js" integrity="sha384-E8hqvY4j8uyv6njj1udAOIuT4tsPt3lJET321mQPDQ29OMiTOYMuG/UDD6o52yW4" crossorigin="anonymous"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.js" integrity="sha384-l95tshxQlbjf4kdyWZf10uUL5Dw8/iN9q16SQ+ttOEWA8SN0cLG6BGDGY17GxToh" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@phosphor-icons/web@2.1.2/src/index.js" integrity="sha384-J7cw2fbG1T4C5MirTVUxsZGaMfw2m0XsCgOQEqUvB1OF9VIsHWuZF1GmyVRzs7eu" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/3.0.3/jspdf.umd.min.js" integrity="sha384-GwHhSt8QjC7J+v0zZ0Flfho/T76YHEcCL9w4rvjTIUHauh6gWJeBSIi3vWXxNhtA" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.6.0/dist/svg2pdf.umd.min.js" integrity="sha384-UMdplNeJF/mRqnsNO/vfK5po5eKyTMGCymHkdARQ9NFscA4DX3buGxfhUJcPLbWj" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.2.7/purify.min.js" integrity="sha384-qJNkHwhlYywDHfyoEe1np+1lYvX/8x+3gHCKFhSSBMQyCFlvFnn+zXmaebXl21rV" crossorigin="anonymous"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+JP:wght@300;400;500;700&display=swap');
        body { font-family: 'Inter', 'Noto Sans JP', sans-serif; background-color: #f8fafc; color: #334155; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f5f9; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        .card { @apply bg-white p-5 rounded-xl shadow-sm border border-slate-200 mb-4 transition-all; }
        .card-header { @apply text-base font-bold mb-3 text-slate-700 flex items-center gap-2 border-b pb-2; }
        .input-group { @apply mb-3; }
        .input-label { @apply block text-xs font-bold text-slate-500 uppercase tracking-wider mb-1 flex items-center gap-1; }
        .form-input { @apply w-full bg-slate-50 border border-slate-200 text-slate-700 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2 transition-all; }
        .form-checkbox { @apply w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2; }
        
        .btn { @apply font-bold rounded-lg text-sm px-4 py-2 shadow-sm transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2; }
        .btn-primary { @apply text-white bg-blue-600 hover:bg-blue-700; }
        .btn-secondary { @apply text-slate-700 bg-white border border-slate-300 hover:bg-slate-50; }
        .btn-danger { @apply text-red-600 bg-white border border-red-200 hover:bg-red-50; }
        .btn-sm { @apply px-2 py-1 text-xs; }

        /* Highlighted Generate Button Style */
        .btn-generate {
            @apply text-white bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 border-b-4 border-indigo-800 shadow-lg shadow-indigo-200;
        }
        .btn-generate:active { @apply border-b-0 translate-y-1; }

        .upload-zone {
            background-color: #fefce8;
            @apply border-2 border-dashed border-slate-300 rounded-lg p-3 text-center cursor-pointer select-none hover:border-blue-500 hover:bg-blue-50 relative transition-colors flex flex-col items-center justify-center min-h-[60px]; 
        }
        .upload-zone.ready { @apply bg-green-50 border-green-500; }
        
        details > summary { @apply list-none cursor-pointer font-bold text-slate-600 hover:text-blue-600 transition-colors flex items-center gap-2 select-none; }
        details > summary::-webkit-details-marker { display: none; }
        details[open] > summary { @apply mb-4 text-blue-600; }
        details > summary::before { content: ''; @apply w-4 h-4 bg-contain bg-no-repeat transition-transform duration-200; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%2364748b' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='9 18 15 12 9 6'%3E%3C/polyline%3E%3C/svg%3E"); }
        details[open] > summary::before { transform: rotate(90deg); }
    </style>
</head>
<body class="antialiased pb-0 overflow-hidden">

<div id="app" class="h-screen flex flex-col relative">
    
    <div v-if="!pyodideReady" class="fixed inset-0 bg-white z-[100] flex flex-col items-center justify-center p-4 text-center">
        <div class="animate-spin text-5xl mb-6">ðŸ§¬</div>
        <h3 class="text-2xl font-bold text-slate-800">Initializing gbdraw Serverless...</h3>
        <p class="text-slate-500 mt-2">Loading Python engine (Pyodide) and dependencies.</p>
        <p class="text-xs text-slate-400 mt-4 font-mono">{{ loadingStatus }}</p>
    </div>

    <div v-if="processing" class="fixed inset-0 bg-white/90 backdrop-blur-sm z-50 flex flex-col items-center justify-center">
        <div class="animate-spin w-16 h-16 border-4 border-blue-600 border-t-transparent rounded-full mb-6"></div>
        <h3 class="text-xl font-bold text-slate-800 animate-pulse">Generating Diagram...</h3>
    </div>

    <header class="bg-white border-b border-slate-200 sticky top-0 z-40 shadow-sm/50 backdrop-blur-md bg-white/90 h-16 shrink-0">
        <div class="max-w-[1600px] mx-auto px-4 h-full flex items-center justify-between">
            <div class="flex items-center gap-3">
                <div class="bg-blue-600 text-white w-9 h-9 rounded-lg flex items-center justify-center font-bold text-xl shadow-md">ðŸ§¬</div>
                <h1 class="text-xl font-bold text-slate-800 tracking-tight flex items-baseline">
                    gbdraw 
                    <span class="text-slate-400 text-xs font-normal ml-3">A genome diagram generator for microbes and organelles</span>
                </h1>
            </div>
            
            <div class="flex items-center gap-3">
                <div class="flex gap-1 mr-4">
                    <button @click="exportConfig" class="text-xs font-bold text-slate-500 hover:text-blue-600 px-2 py-1 rounded border border-slate-200 bg-white flex items-center gap-1">
                        <i class="ph ph-export"></i> Save Config
                    </button>
                    <button @click="$refs.configInput.click()" class="text-xs font-bold text-slate-500 hover:text-blue-600 px-2 py-1 rounded border border-slate-200 bg-white flex items-center gap-1">
                        <i class="ph ph-arrow-square-in"></i> Load Config
                    </button>
                    <input type="file" ref="configInput" accept=".json" class="hidden" @change="importConfig">
                </div>

                <div class="flex bg-slate-100 p-1 rounded-lg">
                    <button @click="mode = 'circular'" :class="mode === 'circular' ? 'bg-white text-blue-600 shadow ring-1 ring-black/5' : 'text-slate-500 hover:text-slate-700'" class="px-4 py-1.5 rounded-md text-sm font-bold transition-all flex items-center gap-2"><i class="ph ph-circle"></i> Circular</button>
                    <button @click="mode = 'linear'" :class="mode === 'linear' ? 'bg-white text-blue-600 shadow ring-1 ring-black/5' : 'text-slate-500 hover:text-slate-700'" class="px-4 py-1.5 rounded-md text-sm font-bold transition-all flex items-center gap-2"><i class="ph ph-ruler"></i> Linear</button>
                </div>
            </div>
        </div>
    </header>

    <main class="flex-grow container max-w-[1600px] mx-auto px-4 py-6 grid grid-cols-1 lg:grid-cols-12 gap-8 overflow-hidden h-[calc(100vh-64px)]">
        
        <div class="lg:col-span-4 flex flex-col h-full overflow-hidden relative border-r border-slate-100 pr-4">
            
            <div class="flex-grow overflow-y-auto custom-scrollbar pr-2 pb-4 space-y-4">
                
                <div class="card border-l-4 border-l-blue-500">
                    <div class="card-header"><i class="ph ph-folder-open text-xl"></i> Input Genomes</div>
                    
                    <div v-if="mode === 'circular'" class="space-y-4">
                        <div class="flex gap-4 text-sm font-bold bg-slate-50 p-2 rounded-lg inline-flex">
                            <label class="flex items-center gap-2 cursor-pointer hover:text-blue-600"><input type="radio" v-model="cInputType" value="gb" class="text-blue-600 focus:ring-blue-500"> GenBank</label>
                            <label class="flex items-center gap-2 cursor-pointer hover:text-blue-600"><input type="radio" v-model="cInputType" value="gff" class="text-blue-600 focus:ring-blue-500"> GFF3 + FASTA</label>
                        </div>
                        <div v-if="cInputType === 'gb'">
                            <file-uploader label="GenBank File (.gb)" accept=".gb,.gbk,.txt" v-model="files.c_gb"></file-uploader>
                        </div>
                        <div v-else class="grid grid-cols-1 gap-3">
                            <file-uploader label="GFF3 File" accept=".gff,.gff3" v-model="files.c_gff"></file-uploader>
                            <file-uploader label="FASTA File" accept=".fasta,.fa,.fna" v-model="files.c_fasta"></file-uploader>
                        </div>
                    </div>

                    <div v-if="mode === 'linear'" class="space-y-4">
                        <div class="flex gap-4 text-sm font-bold bg-slate-50 p-2 rounded-lg inline-flex mb-2">
                            <label class="flex items-center gap-2 cursor-pointer hover:text-blue-600"><input type="radio" v-model="lInputType" value="gb" class="text-blue-600"> GenBank</label>
                            <label class="flex items-center gap-2 cursor-pointer hover:text-blue-600"><input type="radio" v-model="lInputType" value="gff" class="text-blue-600"> GFF3 + FASTA</label>
                        </div>
                        <div v-for="(seq, idx) in linearSeqs" :key="idx" class="p-3 bg-slate-50 rounded-lg border border-slate-200 relative group text-sm transition-all hover:border-blue-300">
                            <div class="absolute top-2 right-2 text-[10px] font-bold text-white bg-slate-400 px-1.5 py-0.5 rounded-full">#{{ idx + 1 }}</div>
                            <div v-if="lInputType === 'gb'" class="space-y-2">
                                <file-uploader label="GenBank File" accept=".gb,.gbk" v-model="seq.gb"></file-uploader>
                            </div>
                            <div v-else class="space-y-2 mb-2">
                                <file-uploader label="GFF3" accept=".gff" v-model="seq.gff"></file-uploader>
                                <file-uploader label="FASTA" accept=".fasta" v-model="seq.fasta"></file-uploader>
                            </div>
                            <div v-if="idx < linearSeqs.length - 1" class="mt-2 pt-2 border-t border-slate-200 border-dashed">
                                <div class="text-[10px] text-slate-500 font-bold mb-1 flex items-center gap-1"><i class="ph ph-arrows-down-up"></i> Compare to next (BLAST)</div>
                                <file-uploader label="BLAST TSV" accept=".txt,.tsv,.csv" v-model="seq.blast"></file-uploader>
                            </div>
                        </div>
                        <div class="flex gap-2">
                            <button @click="linearSeqs.push({gb:null, gff:null, fasta:null, blast:null})" class="btn btn-secondary text-xs w-full"><i class="ph ph-plus"></i> Add Seq</button>
                            <button v-if="linearSeqs.length > 1" @click="linearSeqs.pop()" class="btn btn-danger text-xs w-full"><i class="ph ph-minus"></i> Remove</button>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header"><i class="ph ph-sliders"></i> Basic Settings</div>
                    <div class="space-y-4">
                        <div class="grid grid-cols-2 gap-4">
                             <div>
                                <label class="input-label">Output Prefix <help-tip text="Prefix for output files. Leave empty to use the record name (e.g., NC_000xxx)."></help-tip></label>
                                <input type="text" v-model="form.prefix" class="form-input" placeholder="Optional (Default: Record ID)">
                            </div>
                             <div>
                                <label class="input-label">Legend <help-tip text="Position of the legend. 'None' hides the legend."></help-tip></label>
                                <select v-model="form.legend" class="form-input">
                                    <option value="right">Right</option><option value="left">Left</option>
                                    <option value="top" v-if="mode==='linear'">Top</option><option value="bottom" v-if="mode==='linear'">Bottom</option>
                                    <option value="upper_left" v-if="mode==='circular'">Upper Left</option><option value="upper_right" v-if="mode==='circular'">Upper Right</option>
                                    <option value="none">None</option>
                                </select>
                            </div>
                        </div>
                       
                        <div v-if="mode === 'circular'">
                            <label class="input-label">Track Layout <help-tip text="Choose how features are displayed. 'Tuckin' is default and compact. 'Middle' aligns to center, 'Spreadout' separates them."></help-tip></label>
                            <select v-model="form.track_type" class="form-input"><option value="tuckin">Tuckin (Compact)</option><option value="middle">Middle</option><option value="spreadout">Spreadout</option></select>
                        </div>

                        <div v-if="mode === 'linear'">
                             <label class="input-label">Scale Style <help-tip text="'Bar' draws a simple line, 'Ruler' draws a ruler with ticks and labels."></help-tip></label>
                             <select v-model="form.scale_style" class="form-input"><option value="bar">Bar (Simple)</option><option value="ruler">Ruler (Ticks)</option></select>
                        </div>

                        <div class="grid grid-cols-2 gap-y-2 gap-x-1 p-2 bg-slate-50 rounded-lg">
                            <div v-if="mode === 'linear'" class="col-span-2 mb-1">
                                <label class="input-label text-[10px] mb-1">Show Labels <help-tip text="Display feature labels on the map. 'First' shows labels only for the top track."></help-tip></label>
                                <select v-model="form.show_labels_linear" class="form-input text-xs py-1">
                                    <option value="none">None</option>
                                    <option value="all">All Records</option>
                                    <option value="first">First Record Only</option>
                                </select>
                            </div>
                            <label v-else class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                <input type="checkbox" v-model="form.show_labels" class="form-checkbox"> Show Labels <help-tip text="Display feature labels on the map."></help-tip>
                            </label>

                            <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                <input type="checkbox" v-model="form.separate_strands" class="form-checkbox"> Separate Strands <help-tip text="Display features on separate strands for better distinction."></help-tip>
                            </label>
                            
                            <template v-if="mode === 'circular'">
                                <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                    <input type="checkbox" v-model="form.allow_inner_labels" class="form-checkbox"> Inner Labels <help-tip text="Enable labels inside the circle. Automatically suppresses GC content/skew to avoid overlap."></help-tip>
                                </label>
                                <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                    <input type="checkbox" v-model="form.suppress_gc" class="form-checkbox"> Hide GC <help-tip text="Suppress the GC content track."></help-tip>
                                </label>
                                <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                    <input type="checkbox" v-model="form.suppress_skew" class="form-checkbox"> Hide Skew <help-tip text="Suppress the GC skew track."></help-tip>
                                </label>
                            </template>
                            
                            <template v-if="mode === 'linear'">
                                <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                    <input type="checkbox" v-model="adv.resolve_overlaps" class="form-checkbox"> Resolve Overlaps <help-tip text="Shift features vertically to avoid overlap. (Experimental)"></help-tip>
                                </label>
                                <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                    <input type="checkbox" v-model="form.align_center" class="form-checkbox"> Align Center <help-tip text="Align the linear map to the center of the page."></help-tip>
                                </label>
                                <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                    <input type="checkbox" v-model="form.normalize_length" class="form-checkbox"> Normalize Len <help-tip text="Normalize sequence lengths to be equal. Suppresses length bar."></help-tip>
                                </label>
                                <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                    <input type="checkbox" v-model="form.show_gc" class="form-checkbox"> Show GC <help-tip text="Display GC content track."></help-tip>
                                </label>
                                <label class="flex items-center gap-2 text-xs text-slate-700 cursor-pointer select-none">
                                    <input type="checkbox" v-model="form.show_skew" class="form-checkbox"> Show Skew <help-tip text="Display GC skew track."></help-tip>
                                </label>
                            </template>
                        </div>
                    </div>
                </div>

                <div class="card bg-slate-50/50">
                    <details>
                        <summary><i class="ph ph-palette"></i> Colors & Filters <help-tip text="Customize colors and filter labels by keyword."></help-tip></summary>
                        <div class="mt-4 space-y-6 pt-4 border-t border-slate-200">
                            
                            <div>
                                <div class="flex justify-between items-center mb-2">
                                    <h4 class="text-xs font-bold text-slate-500">DEFAULT COLORS (-d) <help-tip text="Base colors for features. Acts as the -d override table."></help-tip></h4>
                                    <button @click="resetColors" class="text-[10px] text-blue-600 hover:underline">Reset</button>
                                </div>
                                <select v-model="selectedPalette" @change="updatePalette" class="form-input mb-3">
                                    <option v-for="p in paletteNames" :value="p">{{ p }}</option>
                                </select>
                                <div class="grid grid-cols-5 gap-1.5 bg-white p-2 rounded border border-slate-200">
                                    <div v-for="(color, feat) in currentColors" :key="feat" class="flex flex-col items-center group relative cursor-pointer">
                                        <input type="color" v-model="currentColors[feat]" class="w-8 h-8 p-0 border-0 rounded cursor-pointer transition-transform hover:scale-110">
                                        <span class="text-[9px] text-slate-500 mt-0.5 truncate w-full text-center" :title="feat">{{ feat }}</span>
                                    </div>
                                </div>

                                <div class="mt-2 p-2 bg-slate-50 rounded border border-slate-200 flex gap-2 items-end">
                                    <div class="flex-grow">
                                        <label class="text-[9px] font-bold text-slate-500 block mb-1">ADD FEATURE</label>
                                        <select v-model="newColorFeat" class="form-input text-xs py-1 px-2 h-8">
                                            <option v-for="k in featureKeys" :value="k">{{ k }}</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label class="text-[9px] font-bold text-slate-500 block mb-1">COLOR</label>
                                        <input type="color" v-model="newColorVal" class="h-8 w-10 p-0 border border-slate-300 rounded cursor-pointer">
                                    </div>
                                    <button @click.prevent="addCustomColor" class="btn btn-secondary text-xs h-8">
                                        <i class="ph ph-plus"></i> Add
                                    </button>
                                </div>
                                <div class="mt-2">
                                    <div class="text-[10px] text-center text-slate-400 mb-1">- OR UPLOAD FILE -</div>
                                    <file-uploader label="Override File (-d)" v-model="files.d_color" :small="true"></file-uploader>
                                    <div class="text-[9px] text-slate-400 mt-1">
                                        <help-tip text="Tab-separated value (TSV) file that overrides the color palette. Feature types not specified will use the selected palette colors."></help-tip> 
                                        Override default feature colors.
                                    </div>
                                </div>
                            </div>

                            <div>
                                <h4 class="text-xs font-bold text-slate-500 mb-2">SPECIFIC RULES (-t) <help-tip text="Color features matching specific qualifier values (Regex supported)."></help-tip></h4>
                                
                                <div class="space-y-1 mb-3">
                                    <div v-for="(rule, i) in manualSpecificRules" :key="i" class="flex items-center gap-1 bg-white p-1 rounded border border-slate-200 text-[10px]">
                                        <span class="w-12 font-bold truncate" :title="rule.feat">{{rule.feat}}</span>
                                        <span class="w-12 text-slate-500 truncate" :title="rule.qual">{{rule.qual}}</span>
                                        <span class="flex-grow text-blue-600 truncate font-mono" :title="rule.val">/{{rule.val}}/</span>
                                        <div class="w-4 h-4 rounded border" :style="{backgroundColor: rule.color}"></div>
                                        <button @click="manualSpecificRules.splice(i,1)" class="text-red-500 hover:text-red-700 px-1"><i class="ph ph-trash"></i></button>
                                    </div>
                                    <div v-if="manualSpecificRules.length === 0" class="text-[10px] text-slate-400 italic text-center py-2">No rules added</div>
                                </div>

                                <div class="bg-slate-50 p-2 rounded border border-slate-200">
                                    <div class="grid grid-cols-2 gap-1 mb-1">
                                        <select v-model="newSpecRule.feat" class="form-input text-xs p-1 h-7">
                                            <option v-for="k in featureKeys" :value="k">{{ k }}</option>
                                        </select>
                                        <input v-model="newSpecRule.qual" placeholder="Qualifier" class="form-input text-xs p-1 h-7">
                                    </div>
                                    <div class="flex gap-1 mb-1">
                                        <input v-model="newSpecRule.val" placeholder="Regex (e.g. hypothetical)" class="form-input text-xs p-1 h-7 flex-grow">
                                        <input type="color" v-model="newSpecRule.color" class="h-7 w-8 p-0 border rounded cursor-pointer shrink-0">
                                    </div>
                                    <div class="flex gap-1">
                                        <input v-model="newSpecRule.cap" placeholder="Legend Caption (Optional)" class="form-input text-xs p-1 h-7 flex-grow">
                                        <button @click="addSpecificRule" class="btn btn-secondary text-xs h-7 px-3"><i class="ph ph-plus"></i></button>
                                    </div>
                                </div>

                                <div class="mt-2">
                                    <div class="text-[10px] text-center text-slate-400 mb-1">- OR UPLOAD FILE -</div>
                                    <file-uploader label="Specific Table (-t)" v-model="files.t_color" :small="true"></file-uploader>
                                    <div class="text-[9px] text-slate-400 mt-1">
                                        <help-tip text="TSV file that overrides the color palette for specific features based on qualifiers."></help-tip>
                                        Override colors for specific features.
                                    </div>
                                </div>
                            </div>

                            <div>
                                <h4 class="text-xs font-bold text-slate-500 mb-2">LABEL FILTERING <help-tip text="Control which feature labels are displayed using Blacklist or Whitelist."></help-tip></h4>
                                <div class="flex gap-2 mb-2">
                                    <button v-for="m in ['None', 'Blacklist', 'Whitelist']" @click="filterMode = m" :class="filterMode===m ? 'bg-blue-600 text-white' : 'bg-white text-slate-600 border'" class="flex-1 py-1 rounded text-xs font-bold transition-colors">{{m}}</button>
                                </div>
                                
                                <div v-if="filterMode === 'Blacklist'" class="space-y-2 bg-white p-2 rounded border">
                                    <p class="text-[10px] text-slate-500">Exclude labels containing these keywords.</p>
                                    <textarea v-model="manualBlacklist" class="form-input h-20" placeholder="hypothetical, unknown"></textarea>
                                    <div class="text-[10px] text-center text-slate-400">- OR -</div>
                                    <file-uploader label="Blacklist File" v-model="files.blacklist" :small="true"></file-uploader>
                                </div>

                                <div v-if="filterMode === 'Whitelist'" class="space-y-2 bg-white p-2 rounded border">
                                    <p class="text-[10px] text-slate-500">Only show labels matching rules.</p>
                                    <div v-for="(row, i) in manualWhitelist" :key="i" class="flex gap-1 mb-1">
                                        <input v-model="row.feat" placeholder="Feat" class="form-input px-1 py-1 text-xs w-1/4">
                                        <input v-model="row.qual" placeholder="Qual" class="form-input px-1 py-1 text-xs w-1/4">
                                        <input v-model="row.key" placeholder="Keyword" class="form-input px-1 py-1 text-xs w-1/3">
                                        <button @click="manualWhitelist.splice(i,1)" class="text-red-500 hover:text-red-700 px-1">Ã—</button>
                                    </div>
                                    <button @click="manualWhitelist.push({feat:'CDS', qual:'product', key:''})" class="text-xs text-blue-600 font-bold">+ Add Rule</button>
                                    <div class="text-[10px] text-center text-slate-400 mt-2">- OR -</div>
                                    <file-uploader label="Whitelist File" v-model="files.whitelist" :small="true"></file-uploader>
                                </div>
                                
                                <div class="mt-4 pt-4 border-t border-slate-100">
                                    <h5 class="text-[10px] font-bold text-slate-500 mb-2">QUALIFIER PRIORITY <help-tip text="Define label priority order (e.g. CDS -> product,gene,locus_tag)."></help-tip></h5>
                                    
                                    <div class="space-y-1 mb-3">
                                        <div v-for="(rule, i) in manualPriorityRules" :key="i" class="flex items-center gap-1 bg-white p-1 rounded border border-slate-200 text-[10px]">
                                            <span class="w-16 font-bold truncate shrink-0" :title="rule.feat">{{rule.feat}}</span>
                                            <span class="flex-grow text-slate-600 truncate font-mono" :title="rule.order">{{rule.order}}</span>
                                            <button @click="manualPriorityRules.splice(i,1)" class="text-red-500 hover:text-red-700 px-1"><i class="ph ph-trash"></i></button>
                                        </div>
                                        <div v-if="manualPriorityRules.length === 0" class="text-[10px] text-slate-400 italic text-center py-2">No priority rules defined</div>
                                    </div>

                                    <div class="bg-slate-50 p-2 rounded border border-slate-200 mb-2">
                                        <div class="flex gap-1 mb-1">
                                            <select v-model="newPriorityRule.feat" class="form-input text-xs p-1 h-7 w-24 shrink-0">
                                                <option v-for="k in featureKeys" :value="k">{{ k }}</option>
                                            </select>
                                            <input v-model="newPriorityRule.order" placeholder="product,gene,locus_tag" class="form-input text-xs p-1 h-7 flex-grow">
                                            <button @click="addPriorityRule" class="btn btn-secondary text-xs h-7 px-3"><i class="ph ph-plus"></i></button>
                                        </div>
                                    </div>

                                    <div class="text-[10px] text-center text-slate-400 mb-1">- OR UPLOAD FILE -</div>
                                    <file-uploader label="Priority File (TSV)" v-model="files.qualifier_priority" :small="true"></file-uploader>
                                </div>
                            </div>
                        </div>
                    </details>
                    
                    <div class="border-t border-slate-200 my-2"></div>
                    
                    <details>
                        <summary><i class="ph ph-faders"></i> Advanced Options</summary>
                        <div class="mt-4 space-y-4 pt-4 border-t border-slate-200">
                            
                            <div class="grid grid-cols-3 gap-2">
                                <div><label class="input-label text-[10px]">Window <help-tip text="Window size for GC content/skew. Default: 1kb (<1Mb), 10kb (<10Mb), 100kb (>=10Mb)."></help-tip></label><input type="number" v-model.number="adv.window_size" class="form-input" placeholder="Auto"></div>
                                <div><label class="input-label text-[10px]">Step <help-tip text="Step size for GC content/skew. Default: 100bp (<1Mb), 1kb (<10Mb), 10kb (>=10Mb)."></help-tip></label><input type="number" v-model.number="adv.step_size" class="form-input" placeholder="Auto"></div>
                                <div><label class="input-label text-[10px]">Dinucleotide <help-tip text="Dinucleotide to use (e.g., 'GC'). Default is 'GC'."></help-tip></label><input type="text" v-model="adv.nt" class="form-input" placeholder="GC"></div>
                            </div>

                            <div>
                                <template v-if="mode === 'circular'">
                                    <label class="input-label">Definition & Text</label>
                                    <div class="grid grid-cols-2 gap-2 mb-2">
                                        <input type="text" v-model="form.species" class="form-input" placeholder="Species (e.g. <i>Escherichia coli</i>)">
                                        <input type="text" v-model="form.strain" class="form-input" placeholder="Strain (e.g. K-12)">
                                    </div>
                                </template>

                                <label v-if="mode === 'linear'" class="input-label">Label Settings</label>

                                <div class="grid grid-cols-2 gap-2">
                                    <div v-if="mode === 'circular'">
                                        <label class="text-[9px] text-slate-400">Def Font Size <help-tip text="Font size for the species/strain definition text."></help-tip></label>
                                        <input type="number" v-model.number="adv.def_font_size" class="form-input" placeholder="18">
                                    </div>
                                    
                                    <div :class="mode === 'linear' ? 'col-span-2' : ''">
                                        <label class="text-[9px] text-slate-400">Label Font Size <help-tip text="Font size for feature labels."></help-tip></label>
                                        <input type="number" v-model.number="adv.label_font_size" class="form-input" placeholder="Auto">
                                    </div>
                                </div>
                            </div>

                            <div class="grid grid-cols-2 gap-2">
                                <div><label class="input-label text-[10px]">Legend Box Size <help-tip text="Size of the color boxes in the legend."></help-tip></label><input type="number" v-model.number="adv.legend_box_size" class="form-input" placeholder="Auto"></div>
                                <div><label class="input-label text-[10px]">Legend Font Size <help-tip text="Font size for the legend text."></help-tip></label><input type="number" v-model.number="adv.legend_font_size" class="form-input" placeholder="Auto"></div>
                            </div>

                            <div>
                                <label class="input-label">Styles (Colors & Widths)</label>
                                <div class="bg-slate-50 p-2 rounded border border-slate-200 space-y-2">
                                    <div class="grid grid-cols-2 gap-2">
                                        <div><label class="text-[9px] block">Block Stroke Color <help-tip text="Color of the outline for feature blocks."></help-tip></label><input type="color" v-model="adv.block_stroke_color" class="h-6 w-full p-0 border rounded"></div>
                                        <div><label class="text-[9px] block">Block Stroke Width <help-tip text="Width of the outline for feature blocks."></help-tip></label><input type="number" v-model.number="adv.block_stroke_width" class="form-input py-0.5" placeholder="Auto"></div>
                                    </div>
                                    <div class="grid grid-cols-2 gap-2">
                                        <div><label class="text-[9px] block">Line Stroke Color <help-tip text="Color of the lines representing introns."></help-tip></label><input type="color" v-model="adv.line_stroke_color" class="h-6 w-full p-0 border rounded"></div>
                                        <div><label class="text-[9px] block">Line Stroke Width <help-tip text="Width of the lines representing introns."></help-tip></label><input type="number" v-model.number="adv.line_stroke_width" class="form-input py-0.5" placeholder="Auto"></div>
                                    </div>
                                    <div class="grid grid-cols-2 gap-2">
                                        <div><label class="text-[9px] block">Axis Stroke Color <help-tip text="Color of the main axis line."></help-tip></label><input type="color" v-model="adv.axis_stroke_color" class="h-6 w-full p-0 border rounded"></div>
                                        <div><label class="text-[9px] block">Axis Stroke Width <help-tip text="Width of the main axis line."></help-tip></label><input type="number" v-model.number="adv.axis_stroke_width" class="form-input py-0.5" placeholder="Auto"></div>
                                    </div>
                                </div>
                            </div>

                            <div v-if="mode === 'linear'">
                                <label class="input-label">Linear Specific Settings</label>
                                <div class="bg-slate-50 p-2 rounded border border-slate-200 space-y-2">
                                    <div class="grid grid-cols-3 gap-1 text-xs">
                                        <div><label class="text-[9px] block">Feature H <help-tip text="Height of the feature blocks."></help-tip></label><input type="number" v-model.number="adv.feature_height" class="form-input px-1 py-0.5"></div>
                                        <div><label class="text-[9px] block">GC H <help-tip text="Height of the GC content track."></help-tip></label><input type="number" v-model.number="adv.gc_height" class="form-input px-1 py-0.5"></div>
                                        <div><label class="text-[9px] block">Comp H <help-tip text="Height of the comparison blocks."></help-tip></label><input type="number" v-model.number="adv.comparison_height" class="form-input px-1 py-0.5"></div>
                                    </div>
                                    
                                    <div class="pt-1 border-t border-slate-200">
                                        <label class="text-[9px] font-bold block mb-1">SCALE BAR</label>
                                        <div class="grid grid-cols-3 gap-1">
                                            <input type="number" v-model.number="adv.scale_interval" placeholder="Interval" class="form-input px-1 py-0.5 text-xs" title="Manual tick interval">
                                            <input type="number" v-model.number="adv.scale_font_size" placeholder="Font" class="form-input px-1 py-0.5 text-xs" title="Scale font size">
                                            <input type="number" v-model.number="adv.scale_stroke_width" placeholder="Width" class="form-input px-1 py-0.5 text-xs" title="Scale bar width">
                                        </div>
                                        <div class="mt-1 flex items-center gap-2">
                                            <label class="text-[9px]">Color:</label>
                                            <input type="color" v-model="adv.scale_stroke_color" class="h-5 w-8 p-0 border rounded" title="Scale bar color">
                                        </div>
                                    </div>

                                    <div class="pt-1 border-t border-slate-200">
                                        <label class="text-[9px] font-bold block mb-1">BLAST FILTERS</label>
                                        <div class="grid grid-cols-3 gap-1">
                                            <input type="number" v-model.number="adv.min_bitscore" placeholder="Bitscore" class="form-input px-1 text-xs" title="Min bitscore">
                                            <input type="text" v-model="adv.evalue" placeholder="E-value" class="form-input px-1 text-xs" title="Max E-value">
                                            <input type="number" v-model.number="adv.identity" placeholder="Ident%" class="form-input px-1 text-xs" title="Min identity %">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div v-if="mode === 'circular'">
                                <label class="input-label">Circular Label Offsets <help-tip text="Adjust radius offset factors for labels."></help-tip></label>
                                <div class="bg-slate-50 p-2 rounded border border-slate-200 grid grid-cols-2 gap-2 text-xs">
                                    <div><label class="text-[9px] block">Outer X Offset</label><input type="number" step="0.1" v-model.number="adv.outer_label_x_offset" class="form-input py-0.5"></div>
                                    <div><label class="text-[9px] block">Outer Y Offset</label><input type="number" step="0.1" v-model.number="adv.outer_label_y_offset" class="form-input py-0.5"></div>
                                    <div><label class="text-[9px] block">Inner X Offset</label><input type="number" step="0.1" v-model.number="adv.inner_label_x_offset" class="form-input py-0.5"></div>
                                    <div><label class="text-[9px] block">Inner Y Offset</label><input type="number" step="0.1" v-model.number="adv.inner_label_y_offset" class="form-input py-0.5"></div>
                                    <div><label class="text-[9px] block">Scale Interval</label><input type="number" v-model.number="adv.scale_interval" class="form-input py-0.5"></div>
                                </div>
                            </div>

                            <div>
                                <label class="input-label">Include Features <help-tip text="Select which feature types to draw."></help-tip></label>
                                <div class="flex flex-wrap gap-2 mb-2 p-2 bg-slate-50 rounded border border-slate-200 min-h-[38px]">
                                    <span v-for="(f, i) in adv.features" :key="f" class="inline-flex items-center gap-1 text-[10px] bg-white text-blue-700 px-2 py-1 rounded border border-blue-200 shadow-sm">
                                        {{ f }}
                                        <button @click="adv.features.splice(i, 1)" class="text-slate-400 hover:text-red-500 flex items-center justify-center w-4 h-4 rounded-full hover:bg-red-50 transition-colors">
                                            <i class="ph ph-x"></i>
                                        </button>
                                    </span>
                                    <span v-if="adv.features.length === 0" class="text-[10px] text-slate-400 italic py-1">No features selected</span>
                                </div>
                                <div class="flex gap-2">
                                    <select v-model="newFeatureToAdd" class="form-input text-xs py-1 px-2 h-8">
                                        <option v-for="k in featureKeys" :value="k">{{ k }}</option>
                                    </select>
                                    <button @click.prevent="addFeature" class="btn btn-secondary text-xs h-8 shrink-0">
                                        <i class="ph ph-plus"></i> Add
                                    </button>
                                </div>
                            </div>
                        </div>
                    </details>
                </div>

                <div class="card bg-slate-50/50">
                    <details>
                        <summary><i class="ph ph-info"></i> About & Citation</summary>
                        <div class="mt-4 space-y-4 pt-4 border-t border-slate-200 text-xs text-slate-600">
                            
                            <div class="bg-blue-50 text-blue-800 p-2.5 rounded-lg border border-blue-100 leading-relaxed">
                                <strong class="flex items-center gap-1 mb-1"><i class="ph ph-lock-key"></i> Privacy & Security</strong>
                                This tool runs <strong>entirely in your browser</strong> using WebAssembly (Pyodide). Your genomic data is processed locally and never leaves your device.
                            </div>

                            <div>
                                <strong class="block mb-1 text-slate-700 flex items-center gap-1"><i class="ph ph-quotes"></i> Citation</strong>
                                <p class="mb-1.5 text-[11px]">If you use gbdraw in your research, please cite the GitHub repository:</p>
                                <div class="bg-white p-2 rounded border border-slate-200 font-mono text-[10px] select-all text-slate-500 break-all">
                                    https://github.com/satoshikawato/gbdraw
                                </div>
                            </div>

                            <a href="https://github.com/satoshikawato/gbdraw" target="_blank" rel="noopener noreferrer" class="btn btn-secondary btn-sm justify-center">
                                <i class="ph ph-github-logo text-lg"></i> GitHub
                            </a>
                            <a href="https://github.com/satoshikawato/gbdraw/issues" target="_blank" rel="noopener noreferrer" class="btn btn-secondary btn-sm justify-center">
                                <i class="ph ph-bug text-lg"></i> Issues
                            </a>

                            <div class="pt-2 border-t border-slate-200 text-[10px] text-slate-400 leading-relaxed">
                                <strong>Disclaimer:</strong> This tool is provided "as is" without warranty of any kind. The author is not liable for any damages arising from its use.<br>
                                <span class="mt-1 block">License: MIT | Author: Satoshi Kawato</span>
                            </div>
                        </div>
                    </details>
                </div>

            </div>
            
            <div class="shrink-0 py-4 bg-white/50 backdrop-blur-sm border-t border-slate-100 z-10 relative mt-auto">
            <button @click="runAnalysis" :disabled="processing || !pyodideReady" 
                class="btn w-full py-4 text-lg relative overflow-hidden group text-white bg-blue-600 hover:bg-blue-700 shadow-lg shadow-blue-200 border-b-4 border-blue-800 active:border-b-0 active:translate-y-1 active:shadow-none transition-all">
                <span v-if="!processing" class="flex items-center justify-center gap-2"><i class="ph ph-rocket-launch text-2xl"></i> Generate Diagram</span>
                <span v-else class="flex items-center justify-center gap-2"><i class="ph ph-spinner animate-spin text-xl"></i> Processing...</span>
            </button>
            </div>

        </div>

        <div class="lg:col-span-8 space-y-6 flex flex-col h-full overflow-hidden">
            
            <div v-if="errorLog" class="card border-l-4 border-l-red-500 bg-red-50 mb-0 shrink-0">
                <div class="text-red-700 font-bold mb-2 flex items-center gap-2"><i class="ph ph-warning-circle"></i> Error Occurred</div>
                <pre class="text-xs font-mono text-red-800 whitespace-pre-wrap overflow-auto max-h-40 bg-white/50 p-3 rounded custom-scrollbar">{{ errorLog }}</pre>
            </div>

            <div v-if="results.length > 0" class="card border-2 border-green-100 ring-4 ring-green-50/50 flex flex-col flex-grow overflow-hidden relative">
                <div class="card-header bg-green-50/50 -m-5 mb-0 p-4 border-green-100 flex justify-between items-center shrink-0">
                    <span class="text-green-600 flex items-center gap-2">
                        <i class="ph ph-check-circle text-xl"></i> 
                        <span v-if="results.length === 1">Result Preview</span>
                        <span v-else>
                            <select v-model="selectedResultIndex" class="bg-white border border-green-300 text-green-700 text-xs font-bold rounded py-1 px-2 cursor-pointer focus:ring-2 focus:ring-green-500">
                                <option v-for="(res, idx) in results" :key="idx" :value="idx">Preview: {{ res.name }}</option>
                            </select>
                        </span>
                    </span>
                    <div class="flex gap-2 items-center">
                        <div class="flex items-center gap-1 bg-white px-2 py-1 rounded border border-green-200">
                            <span class="text-[10px] font-bold text-green-700">DPI</span>
                            <select v-model="downloadDpi" class="text-xs bg-transparent border-none focus:ring-0 p-0 text-slate-600 font-mono outline-none cursor-pointer">
                                <option value="72">72 (Web)</option>
                                <option value="96">96 (Screen)</option>
                                <option value="150">150 (Draft)</option>
                                <option value="300">300 (Print)</option>
                                <option value="600">600 (High)</option>
                            </select>
                        </div>
                        <button @click="downloadSVG" class="btn btn-secondary text-xs"><i class="ph ph-download-simple"></i> SVG</button>
                        <button @click="downloadPNG" class="btn btn-primary text-xs"><i class="ph ph-download-simple"></i> PNG</button>
                        <button @click="downloadPDF" class="btn btn-secondary text-xs"><i class="ph ph-file-pdf"></i> PDF</button>
                    </div>
                </div>

                <div class="relative flex-grow overflow-hidden bg-slate-50/30">

                    <!-- Zoom and Canvas controls -->
                    <div class="absolute bottom-4 right-4 flex flex-col gap-2 z-20">
                        <!-- Reset all positions button -->
                        <button v-if="svgContent" @click="resetAllPositions"
                                class="w-8 h-8 flex items-center justify-center bg-white shadow rounded-lg border border-slate-200 hover:bg-slate-100 text-slate-600"
                                title="Reset all element positions">
                            <i class="ph ph-arrow-counter-clockwise"></i>
                        </button>
                        <!-- Canvas size toggle -->
                        <button v-if="svgContent" @click="showCanvasControls = !showCanvasControls"
                                class="w-8 h-8 flex items-center justify-center bg-white shadow rounded-lg border border-slate-200 hover:bg-slate-100 text-slate-600"
                                :class="{ 'bg-blue-50 text-blue-600 border-blue-300': showCanvasControls }"
                                title="Canvas padding controls">
                            <i class="ph ph-frame-corners"></i>
                        </button>
                        <!-- Zoom controls -->
                        <div class="flex gap-1 bg-white shadow rounded-lg p-1 border border-slate-200">
                            <button @click="zoom+=0.1" class="w-8 h-8 flex items-center justify-center hover:bg-slate-100 text-slate-600 rounded"><i class="ph ph-plus"></i></button>
                            <button @click="zoom = 1.0" class="w-12 h-8 flex items-center justify-center hover:bg-slate-100 text-slate-600 text-xs font-mono rounded">{{Math.round(zoom*100)}}%</button>
                            <button @click="zoom = Math.max(0.1, zoom-0.1)" class="w-8 h-8 flex items-center justify-center hover:bg-slate-100 text-slate-600 rounded"><i class="ph ph-minus"></i></button>
                        </div>
                    </div>

                    <!-- Drag hint -->
                    <div v-if="svgContent" class="absolute top-4 left-4 bg-white/90 shadow rounded-lg px-3 py-2 z-20 border border-slate-200">
                        <p class="text-[10px] text-slate-500 flex items-center gap-1">
                            <i class="ph ph-hand-grabbing"></i> Drag diagram or legend to reposition
                        </p>
                    </div>

                    <!-- Canvas padding controls panel -->
                    <div v-if="showCanvasControls && svgContent"
                         class="absolute bottom-4 right-36 bg-white shadow-lg rounded-lg p-3 z-20 border border-slate-200 w-48">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-xs font-bold text-slate-700">Canvas Padding</span>
                            <button @click="resetCanvasPadding" class="text-[10px] text-blue-600 hover:text-blue-800">Reset</button>
                        </div>
                        <div class="grid grid-cols-3 gap-1 text-center">
                            <div></div>
                            <div>
                                <label class="text-[9px] text-slate-400 block">Top</label>
                                <input type="number" v-model.number="canvasPadding.top" step="10" class="w-full text-xs border rounded px-1 py-0.5 text-center">
                            </div>
                            <div></div>
                            <div>
                                <label class="text-[9px] text-slate-400 block">Left</label>
                                <input type="number" v-model.number="canvasPadding.left" step="10" class="w-full text-xs border rounded px-1 py-0.5 text-center">
                            </div>
                            <div class="flex items-center justify-center">
                                <i class="ph ph-selection-background text-slate-300 text-lg"></i>
                            </div>
                            <div>
                                <label class="text-[9px] text-slate-400 block">Right</label>
                                <input type="number" v-model.number="canvasPadding.right" step="10" class="w-full text-xs border rounded px-1 py-0.5 text-center">
                            </div>
                            <div></div>
                            <div>
                                <label class="text-[9px] text-slate-400 block">Bottom</label>
                                <input type="number" v-model.number="canvasPadding.bottom" step="10" class="w-full text-xs border rounded px-1 py-0.5 text-center">
                            </div>
                            <div></div>
                        </div>
                        <p class="text-[9px] text-slate-400 mt-2 text-center">Add space around the diagram</p>
                    </div>

                    <div class="absolute inset-0 overflow-auto flex p-8 custom-scrollbar">
                        <div v-if="svgContent" v-html="svgContent" ref="svgContainer"
                            :key="`svg-${mode}-${selectedResultIndex}-${results.length}`"
                            :style="{transform: `scale(${zoom})`, transformOrigin: 'top center', transition: 'transform 0.2s'}"
                            class="shadow-xl bg-white m-auto origin-top">
                        </div>
                    </div>

                    <!-- Feature Color Picker Popup -->
                    <div v-if="clickedFeature"
                         class="fixed z-50 bg-white rounded-lg shadow-2xl border border-slate-200 p-3 min-w-[240px]"
                         :style="{ top: clickedFeaturePos.y + 'px', left: clickedFeaturePos.x + 'px' }">
                        <div class="flex items-center gap-2 mb-2">
                            <span class="text-xs font-medium text-slate-600 truncate max-w-[200px]">{{ clickedFeature.label }}</span>
                            <button @click="clickedFeature = null" class="text-slate-400 hover:text-slate-600 ml-auto">
                                <i class="ph ph-x"></i>
                            </button>
                        </div>
                        <div class="border-t border-slate-100 pt-2 mb-2">
                            <label class="text-[10px] text-slate-400 block mb-1">Legend name (optional)</label>
                            <input type="text"
                                   v-model="clickedFeature.legendName"
                                   :placeholder="clickedFeature.label"
                                   class="w-full text-xs border border-slate-200 rounded px-2 py-1 focus:outline-none focus:border-blue-400">
                        </div>
                        <div class="flex items-center gap-2">
                            <input type="color"
                                   :value="clickedFeature.color"
                                   @input="clickedFeature.color = $event.target.value"
                                   @change="updateClickedFeatureColor($event.target.value)"
                                   class="w-10 h-8 cursor-pointer border rounded">
                            <span class="text-xs font-mono text-slate-500">{{ clickedFeature.color }}</span>
                        </div>
                    </div>

                </div>

                <!-- Legend Editor Toggle Button -->
                <button v-if="svgContent"
                        @click="showLegendPanel = !showLegendPanel"
                        class="absolute right-0 top-1/3 -translate-y-1/2 bg-purple-600 hover:bg-purple-700 text-white px-2 py-4 rounded-l-lg shadow-lg z-20 transition-all"
                        :class="{ 'translate-x-0': !showLegendPanel, '-translate-x-72': showLegendPanel }"
                        :title="showLegendPanel ? 'Close legend editor' : 'Edit legend'">
                    <i class="ph ph-list-bullets text-lg"></i>
                </button>

                <!-- Legend Editor Panel -->
                <div v-if="svgContent"
                     class="absolute right-0 top-0 bottom-0 w-72 bg-white border-l border-slate-200 shadow-xl z-10 transition-transform duration-300 flex flex-col"
                     :class="showLegendPanel ? 'translate-x-0' : 'translate-x-full'">
                    <div class="px-4 py-3 border-b border-slate-200 flex items-center justify-between shrink-0 bg-purple-50">
                        <div class="flex items-center gap-2">
                            <i class="ph ph-list-bullets text-purple-600"></i>
                            <span class="font-bold text-slate-700">Legend Editor</span>
                        </div>
                        <button @click="showLegendPanel = false" class="text-slate-400 hover:text-slate-600">
                            <i class="ph ph-x text-lg"></i>
                        </button>
                    </div>

                    <!-- Legend position controls -->
                    <div class="px-3 py-2 border-b border-slate-100 bg-slate-50/50">
                        <div class="flex items-center justify-between">
                            <span class="text-[10px] text-slate-500 flex items-center gap-1">
                                <i class="ph ph-hand-grabbing"></i> Drag legend to reposition
                            </span>
                            <button @click="resetLegendPosition"
                                    class="text-[10px] text-blue-600 hover:text-blue-800 flex items-center gap-1 px-2 py-1 rounded hover:bg-blue-50 transition-colors"
                                    title="Reset legend to original position">
                                <i class="ph ph-arrow-counter-clockwise"></i> Reset
                            </button>
                        </div>
                    </div>

                    <div class="flex-1 overflow-y-auto p-3 space-y-2">
                        <div v-for="(entry, idx) in legendEntries" :key="idx"
                             class="flex items-center gap-1 p-2 bg-slate-50 rounded border border-slate-100">
                            <!-- Up/Down buttons -->
                            <div class="flex flex-col shrink-0">
                                <button @click="moveLegendEntryUp(idx)"
                                        :disabled="idx === 0"
                                        class="text-slate-400 hover:text-slate-600 disabled:text-slate-200 disabled:cursor-not-allowed p-0 leading-none"
                                        title="Move up">
                                    <i class="ph ph-caret-up text-xs"></i>
                                </button>
                                <button @click="moveLegendEntryDown(idx)"
                                        :disabled="idx === legendEntries.length - 1"
                                        class="text-slate-400 hover:text-slate-600 disabled:text-slate-200 disabled:cursor-not-allowed p-0 leading-none"
                                        title="Move down">
                                    <i class="ph ph-caret-down text-xs"></i>
                                </button>
                            </div>
                            <!-- Color display (read-only) -->
                            <div class="w-6 h-6 rounded border border-slate-300 shrink-0"
                                 :style="{ backgroundColor: entry.color }"
                                 :title="entry.color"></div>
                            <input type="text"
                                   :value="entry.caption"
                                   @change="updateLegendEntryCaption(idx, $event.target.value)"
                                   class="flex-1 text-xs border border-slate-200 rounded px-2 py-1 min-w-0">
                            <button @click="deleteLegendEntry(idx)"
                                    class="text-red-400 hover:text-red-600 shrink-0"
                                    title="Remove entry">
                                <i class="ph ph-trash text-sm"></i>
                            </button>
                        </div>
                        <div v-if="legendEntries.length === 0" class="text-center text-slate-400 text-sm py-4">
                            No legend entries found
                        </div>
                    </div>

                    <!-- Info message -->
                    <div class="p-3 border-t border-slate-200 bg-slate-50 text-xs text-slate-500">
                        <i class="ph ph-info"></i> Colors are managed via Feature Colors panel
                    </div>
                </div>

                <!-- Feature Color Editor Toggle Button (floating) -->
                <button v-if="extractedFeatures.length > 0"
                        @click="showFeaturePanel = !showFeaturePanel"
                        class="absolute right-0 top-1/2 -translate-y-1/2 bg-blue-600 hover:bg-blue-700 text-white px-2 py-4 rounded-l-lg shadow-lg z-20 transition-all"
                        :class="{ 'translate-x-0': !showFeaturePanel, '-translate-x-80': showFeaturePanel }"
                        :title="showFeaturePanel ? 'Close color panel' : 'Open color panel'">
                    <i class="ph ph-paint-brush text-lg"></i>
                </button>

                <!-- Feature Color Editor Drawer (slides from right) -->
                <div v-if="extractedFeatures.length > 0"
                     class="absolute right-0 top-0 bottom-0 w-80 bg-white border-l border-slate-200 shadow-xl z-10 transition-transform duration-300 flex flex-col"
                     :class="showFeaturePanel ? 'translate-x-0' : 'translate-x-full'">
                    <!-- Header -->
                    <div class="px-4 py-3 border-b border-slate-200 flex items-center justify-between shrink-0 bg-slate-50">
                        <div class="flex items-center gap-2">
                            <i class="ph ph-paint-brush text-blue-600"></i>
                            <span class="font-bold text-slate-700">Feature Colors</span>
                            <span class="text-xs text-slate-400">({{ filteredFeatures.length }})</span>
                        </div>
                        <button @click="showFeaturePanel = false" class="text-slate-400 hover:text-slate-600">
                            <i class="ph ph-x text-lg"></i>
                        </button>
                    </div>

                    <!-- Record Selector (for multi-record files) -->
                    <div v-if="featureRecordIds.length > 1" class="px-4 py-2 border-b border-slate-100 shrink-0">
                        <select v-model="selectedFeatureRecordIdx" class="form-select text-xs w-full">
                            <option v-for="(rid, idx) in featureRecordIds" :key="idx" :value="idx">
                                {{ rid }}
                            </option>
                        </select>
                    </div>

                    <!-- Search -->
                    <div class="px-4 py-2 border-b border-slate-100 shrink-0">
                        <input v-model="featureSearch" placeholder="Search by product, gene, locus_tag..."
                               class="form-input text-xs w-full">
                    </div>

                    <!-- Feature List -->
                    <div class="flex-grow overflow-y-auto">
                        <div v-for="feat in filteredFeatures" :key="feat.id"
                             @click="$event.currentTarget.querySelector('input[type=color]')?.click()"
                             class="flex items-center gap-2 px-3 py-2 border-b border-slate-100 text-xs hover:bg-blue-50 cursor-pointer transition-colors">
                            <span class="w-10 font-mono text-slate-400 shrink-0 text-[10px]">{{ feat.type }}</span>
                            <span class="w-16 font-mono text-slate-500 shrink-0 truncate text-[10px]" :title="`${feat.start}..${feat.end}`">
                                {{ feat.start }}..{{ feat.end }}
                            </span>
                            <span class="flex-grow truncate text-slate-700"
                                  :title="feat.product || feat.gene || feat.locus_tag || feat.note || '(unnamed)'">
                                {{ feat.product || feat.gene || feat.locus_tag || feat.note || '(unnamed)' }}
                            </span>
                            <input type="color"
                                   :value="getFeatureColor(feat)"
                                   @click.stop
                                   @change="setFeatureColor(feat, $event.target.value)"
                                   :disabled="!canEditFeatureColor(feat)"
                                   :title="canEditFeatureColor(feat) ? 'Click to change color' : 'No identifier available (no locus_tag, gene, or product)'"
                                   :class="['w-7 h-5 border rounded shrink-0', canEditFeatureColor(feat) ? 'cursor-pointer' : 'cursor-not-allowed opacity-50']">
                        </div>
                        <div v-if="filteredFeatures.length === 0" class="p-4 text-center text-slate-400 text-xs">
                            No features found
                        </div>
                    </div>

                    <!-- Footer -->
                    <div class="px-4 py-2 border-t border-slate-200 shrink-0 bg-slate-50">
                        <p class="text-[10px] text-slate-400">
                            <i class="ph ph-info"></i> Click a feature or the diagram to change colors.
                        </p>
                    </div>
                </div>
            </div>

            <div v-else class="h-full flex flex-col items-center justify-center text-slate-300 border-4 border-dashed border-slate-200 rounded-3xl p-12 bg-slate-50/30">
                <i class="ph ph-dna text-6xl mb-4 text-slate-200"></i>
                <p class="font-medium text-slate-400">Configure settings and click Generate</p>
            </div>
        </div>
    </main>
</div>

<script type="text/x-template" id="help-tip-template">
    <div class="inline-block ml-1 align-text-bottom">
        <i class="ph ph-question text-slate-400 hover:text-blue-500 cursor-help"
           @mouseenter="show" @mouseleave="hide" ref="trigger"></i>
        <Teleport to="body">
            <div v-if="visible" :style="style" class="fixed z-[9999] px-3 py-2 bg-slate-800 text-white text-xs rounded-md shadow-lg max-w-[250px] pointer-events-none transition-opacity text-left leading-relaxed">
                 {{ text }}
            </div>
        </Teleport>
    </div>
</script>

<script type="text/x-template" id="file-uploader-template">
    <div class="w-full">
        <div class="flex justify-between items-end mb-1">
            <label class="input-label mb-0">{{ label }}</label>
            <button v-if="modelValue" @click.stop="clearFile" class="text-[10px] text-red-500 hover:text-red-700 flex items-center gap-1"><i class="ph ph-trash"></i> Remove</button>
        </div>
        <div class="upload-zone cursor-pointer" :class="{'ready': modelValue, 'py-1 min-h-[36px]': small}" @click="$refs.input.click()">
            <input type="file" ref="input" @change="handleFile" :accept="accept" class="hidden">
            <div v-if="!modelValue" class="flex items-center justify-center gap-2 text-slate-400 group-hover:text-blue-600 transition-colors">
                <i class="ph ph-upload-simple" :class="small ? 'text-base' : 'text-xl'"></i>
                <span :class="small ? 'text-[10px]' : 'text-xs font-bold'">Click to Browse</span>
            </div>
            <div v-else class="text-green-700 font-bold truncate w-full px-2 flex items-center justify-center gap-2" :class="small ? 'text-[10px]' : 'text-xs'">
                <i class="ph ph-check-circle text-lg"></i>
                <span>{{ modelValue.name }}</span>
            </div>
        </div>
    </div>
</script>

<script>
    const { createApp, ref, reactive, onMounted, computed, watch } = Vue;
    const GBDRAW_WHEEL_NAME = "gbdraw-0.8.3-py3-none-any.whl"; 

    // HelpTip & FileUploader Components
    const HelpTip = {
        template: '#help-tip-template',
        props: ['text'],
        setup(props) {
            const visible = ref(false);
            const style = reactive({ top: '0px', left: '0px' });
            const trigger = ref(null);
            const show = () => {
                if (!trigger.value) return;
                const rect = trigger.value.getBoundingClientRect();
                
                // Get viewport width and tooltip max width
                const viewportWidth = window.innerWidth;
                const tooltipMaxWidth = 260; // max-w-250px + extra margin
                const halfWidth = tooltipMaxWidth / 2;
                const gap = 12; // gap between icon and tooltip

                // Centered on the icon
                let left = rect.left + rect.width / 2;
                let top = rect.top - gap;
                let transform = 'translate(-50%, -100%)'; // above the icon

                // Prevent overflow on left/right (keep at least 10px from viewport edges)
                if (left < halfWidth + 10) {
                    left = halfWidth + 10;
                } else if (left > viewportWidth - halfWidth - 10) {
                    left = viewportWidth - halfWidth - 10;
                }

                // Prevent overflow at the top (if too close to top edge, show below)
                // Considering header and browser frame, if y < 60px, show below
                if (rect.top < 60) {
                    top = rect.bottom + gap;
                    transform = 'translate(-50%, 0)'; // transform for below display
                }

                style.top = top + 'px';
                style.left = left + 'px';
                style.transform = transform;
                
                visible.value = true;
            };
            const hide = () => visible.value = false;
            return { visible, style, trigger, show, hide };
        }
    };

    const FileUploader = {
        template: '#file-uploader-template',
        props: ['label', 'accept', 'modelValue', 'small'],
        emits: ['update:modelValue'],
        setup(props, { emit }) {
            const input = ref(null);
            const handleFile = (e) => {
                if(e.target.files[0]) emit('update:modelValue', e.target.files[0]);
                e.target.value = ''; 
            };
            const clearFile = () => emit('update:modelValue', null);
            return { input, handleFile, clearFile };
        }
    };

    // DPI Helper
    const setDpiInPng = async (blob, dpi) => {
        const pixelsPerMeter = Math.round(dpi / 0.0254);
        const buffer = await blob.arrayBuffer();
        const view = new DataView(buffer);
        const uint8 = new Uint8Array(buffer);
        let offset = 8; let physChunk = null; let idatOffset = null;
        while (offset < view.byteLength) {
            const length = view.getUint32(offset);
            const type = String.fromCharCode(uint8[offset+4], uint8[offset+5], uint8[offset+6], uint8[offset+7]);
            if (type === 'pHYs') { physChunk = offset; break; }
            if (type === 'IDAT') { idatOffset = offset; break; }
            offset += 12 + length;
        }
        const ppm = pixelsPerMeter;
        const physData = new Uint8Array(9);
        const dv = new DataView(physData.buffer);
        dv.setUint32(0, ppm); dv.setUint32(4, ppm); physData[8] = 1;
        const crcTable = []; for (let n = 0; n < 256; n++) { let c = n; for (let k = 0; k < 8; k++) c = (c & 1) ? 0xedb88320 ^ (c >>> 1) : c >>> 1; crcTable[n] = c; }
        const crc32 = (buf) => { let crc = 0 ^ (-1); for (let i = 0; i < buf.length; i++) crc = (crc >>> 8) ^ crcTable[(crc ^ buf[i]) & 0xff]; return (crc ^ (-1)) >>> 0; };
        const newChunk = new Uint8Array(21);
        const newDv = new DataView(newChunk.buffer);
        newDv.setUint32(0, 9); newChunk.set([112, 72, 89, 115], 4); newChunk.set(physData, 8);
        const crcInput = new Uint8Array(13); crcInput.set([112, 72, 89, 115], 0); crcInput.set(physData, 4);
        newDv.setUint32(17, crc32(crcInput));
        if (physChunk !== null) {
             const newBuffer = new Uint8Array(buffer.byteLength); newBuffer.set(uint8.slice(0, physChunk), 0); newBuffer.set(newChunk, physChunk); const oldLen = view.getUint32(physChunk); newBuffer.set(uint8.slice(physChunk + 12 + oldLen), physChunk + 21); return new Blob([newBuffer], { type: 'image/png' });
        } else {
            const newBuffer = new Uint8Array(buffer.byteLength + 21); newBuffer.set(uint8.slice(0, idatOffset), 0); newBuffer.set(newChunk, idatOffset); newBuffer.set(uint8.slice(idatOffset), idatOffset + 21); return new Blob([newBuffer], { type: 'image/png' });
        }
    };

    createApp({
        components: { FileUploader, HelpTip },
        setup() {
            // System State
            const pyodideReady = ref(false);
            const processing = ref(false);
            const loadingStatus = ref("Initializing...");
            const errorLog = ref(null);
            
            const results = ref([]);
            const selectedResultIndex = ref(0);
            // Store original pairwise match factors for re-interpolation
            const pairwiseMatchFactors = ref({});  // { pathId: factor }
            const svgContent = computed(() => {
                if (results.value.length > 0) {
                    const rawSvg = results.value[selectedResultIndex.value].content;
                    
                    // Sanitize the SVG output from svgwrite to ensure safety and prevent DOMXSS
                    return DOMPurify.sanitize(rawSvg, {
                        USE_PROFILES: { svg: true },
                        // Only allow main tags used by svgwrite
                        ADD_TAGS: ['use', 'g', 'defs', 'linearGradient', 'radialGradient', 'stop', 'path', 'rect', 'circle', 'line', 'polyline', 'polygon', 'text', 'tspan'],
                        // Allowed attributes list (event handlers are automatically excluded, but can be explicitly forbidden as well)
                        ADD_ATTR: [
                            'xlink:href', 'href', 'id', 'class',
                            'fill', 'fill-opacity', 'stroke', 'stroke-width', 'stroke-opacity', 'stroke-dasharray', 'stroke-linecap', 'stroke-linejoin', 
                            'd', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 
                            'width', 'height', 'transform', 'viewBox', 'preserveAspectRatio',
                            'font-family', 'font-size', 'font-weight', 'text-anchor', 'dominant-baseline', 'writing-mode', 'letter-spacing'
                        ],
                        // Forbid <style> tags (to prevent breaking parent page CSS). Also forbid script-related tags.
                        FORBID_TAGS: ['style', 'script', 'foreignObject', 'iframe', 'embed', 'object', 'animate', 'set', 'animateTransform', 'image'],
                        FORBID_ATTR: ['name', 'onload', 'onclick', 'onmouseover', 'onfocus', 'onerror']
                    });
                }
                return null;
            });

            const zoom = ref(1.0);
            let pyodide = null;

            // App State
            const mode = ref('circular');
            const cInputType = ref('gb');
            const lInputType = ref('gb');
            const files = reactive({ 
                c_gb: null, c_gff: null, c_fasta: null, 
                d_color: null, t_color: null, 
                blacklist: null, whitelist: null, qualifier_priority: null 
            });
            const linearSeqs = reactive([{ gb: null, gff: null, fasta: null, blast: null }]);
            
            // Configuration Forms
            const form = reactive({ 
                prefix: '', species: '', strain: '', 
                track_type: 'tuckin', legend: 'right', scale_style: 'bar', 
                show_labels: false, show_labels_linear: "none",
                separate_strands: true, 
                allow_inner_labels: false, suppress_gc: false, suppress_skew: false, 
                align_center: false, show_gc: false, show_skew: false, normalize_length: false 
            });

            // Extended Advanced Config
            const adv = reactive({
                features: ["CDS","rRNA","tRNA","tmRNA","ncRNA","repeat_region"],
                window_size: null, step_size: null, nt: "GC",
                def_font_size: 18, label_font_size: null,
                
                // Styles
                block_stroke_width: null, block_stroke_color: null,
                line_stroke_width: null, line_stroke_color: null,
                axis_stroke_width: null, axis_stroke_color: null,
                
                // Legend
                legend_box_size: null, legend_font_size: null,

                // Linear Specific
                resolve_overlaps: false,
                feature_height: null, gc_height: null, comparison_height: null,
                min_bitscore: 50, evalue: "1e-2", identity: 0,
                scale_interval: null, scale_font_size: null, scale_stroke_width: null, scale_stroke_color: null,

                // Circular Specific
                outer_label_x_offset: null, outer_label_y_offset: null,
                inner_label_x_offset: null, inner_label_y_offset: null
            });

            // Color & Filter State
            const paletteNames = ref(["default"]);
            const selectedPalette = ref("default");
            const currentColors = ref({});
            const filterMode = ref("None");
            const manualBlacklist = ref("hypothetical, uncharacterized, putative, unknown");
            const manualWhitelist = reactive([]); 
            const manualSpecificRules = reactive([]);
            const newSpecRule = reactive({ feat: "CDS", qual: "product", val: "", color: "#ff0000", cap: "" });
            const downloadDpi = ref(300);

            // Feature Color Editor state
            const extractedFeatures = ref([]);  // Features from last generation
            const featureRecordIds = ref([]);  // Record IDs for multi-record files
            const selectedFeatureRecordIdx = ref(0);  // Currently selected record index
            const showFeaturePanel = ref(false);
            const featureSearch = ref('');
            const featureColorOverrides = reactive({});  // {featureKey: color}
            // SVG Feature Click state
            const svgContainer = ref(null);
            const clickedFeature = ref(null);  // {id, svg_id, label, color, feat}
            const clickedFeaturePos = reactive({ x: 0, y: 0 });

            // Legend Editor state
            const showLegendPanel = ref(false);
            const legendEntries = ref([]);  // [{caption, color, yPos}]
            const newLegendCaption = ref('');
            const newLegendColor = ref('#808080');

            // Legend Drag state
            const legendDragging = ref(false);
            const legendDragStart = reactive({ x: 0, y: 0 });
            const legendOriginalTransform = ref({ x: 0, y: 0 });
            const legendInitialTransform = ref({ x: 0, y: 0 });  // Store SVG's original legend position
            const legendCurrentOffset = reactive({ x: 0, y: 0 });

            // Main Diagram Drag state (tick, labels, axis, definition, records as one group)
            const diagramDragging = ref(false);
            const diagramDragStart = reactive({ x: 0, y: 0 });
            const diagramOffset = reactive({ x: 0, y: 0 });  // Cumulative drag offset
            const diagramElementIds = ref([]);  // IDs of elements that move together
            const diagramElementOriginalTransforms = ref(new Map());  // Store original transforms for each element

            // Canvas size state
            const canvasPadding = reactive({ top: 0, right: 0, bottom: 0, left: 0 });
            const showCanvasControls = ref(false);

            // Track legend position at generation time (for repositioning without regeneration)
            const generatedLegendPosition = ref('right');

            const featureKeys = [
                "assembly_gap", "C_region", "CDS", "centromere", "D-loop", "D_segment",
                "exon", "gap", "gene", "intron", "J_segment", "mat_peptide", "misc_binding",
                "misc_difference", "misc_feature", "misc_RNA", "misc_structure",
                "mobile_element", "modified_base", "mRNA", "ncRNA", "operon", "oriT",
                "precursor_RNA", "primer_bind", "propeptide", "protein_bind", "regulatory",
                "repeat_region", "rep_origin", "rRNA", "sig_peptide", "stem_loop",
                "telomere", "tmRNA", "transit_peptide", "tRNA", "unsure", "V_region",
                "V_segment", "variation", "3'UTR", "5'UTR"
            ];
            
            const newColorFeat = ref("gene");
            const newColorVal = ref("#d3d3d3");
            const addCustomColor = () => { 
                if(!newColorFeat.value) return; 
                currentColors.value = { 
                    ...currentColors.value, 
                    [newColorFeat.value]: newColorVal.value 
                }; 
            };
            const manualPriorityRules = reactive([]);
            const newPriorityRule = reactive({ feat: "CDS", order: "product,gene,locus_tag" });
            
            const addPriorityRule = () => {
                if (!newPriorityRule.order) return;
                // If the same feature exists, overwrite it; otherwise, add it.
                const idx = manualPriorityRules.findIndex(r => r.feat === newPriorityRule.feat);
                if (idx >= 0) {
                    manualPriorityRules[idx].order = newPriorityRule.order;
                } else {
                    manualPriorityRules.push({ feat: newPriorityRule.feat, order: newPriorityRule.order });
                }
            };
        
            const addSpecificRule = () => {
                if(!newSpecRule.val) return;

                // If the regex is too long (>50 chars), warn the user about potential performance impact.
                if (newSpecRule.val.length > 50) {
                    if (!confirm("Regular expression is quite long (>50 chars). This might impact performance. Continue?")) {
                        return;
                    }
                }

                // Simple check for potentially dangerous patterns (warning)
                if (/\(.+[\+\*]\)[\+\*]/.test(newSpecRule.val) || /\(.*\)\+/.test(newSpecRule.val)) {
                    if (!confirm("This regular expression contains patterns that may freeze the browser (ReDoS risk). Are you sure you want to add it?")) {
                        return;
                    }
                }

                try {
                    new RegExp(newSpecRule.val);
                } catch (e) {
                    alert("Invalid Regular Expression: " + e.message);
                    return;
                }

                manualSpecificRules.push({
                    feat: String(newSpecRule.feat || ''),
                    qual: String(newSpecRule.qual || ''),
                    val: String(newSpecRule.val),
                    color: String(newSpecRule.color || '#000000'),
                    cap: String(newSpecRule.cap || '')
                });
                newSpecRule.val = "";
            };
            const newFeatureToAdd = ref("mobile_element");
            const addFeature = () => { if(newFeatureToAdd.value && !adv.features.includes(newFeatureToAdd.value)){ adv.features.push(newFeatureToAdd.value); } };

            // Feature Color Editor functions
            const filteredFeatures = computed(() => {
                // First filter by feature type (only show features that are actually drawn)
                let features = extractedFeatures.value.filter(f =>
                    adv.features.includes(f.type)
                );

                // Filter by selected record (if multiple records exist)
                if (featureRecordIds.value.length > 1) {
                    const selectedIdx = selectedFeatureRecordIdx.value;
                    if (mode.value === 'circular') {
                        // For circular: filter by record_idx within the file
                        features = features.filter(f => f.record_idx === selectedIdx);
                    } else {
                        // For linear: filter by the combined file+record label
                        const selectedLabel = featureRecordIds.value[selectedIdx];
                        features = features.filter(f => f.displayRecordId === selectedLabel);
                    }
                }

                // Then apply search filter
                if (featureSearch.value) {
                    const q = featureSearch.value.toLowerCase();
                    features = features.filter(f =>
                        (f.product || '').toLowerCase().includes(q) ||
                        (f.gene || '').toLowerCase().includes(q) ||
                        (f.locus_tag || '').toLowerCase().includes(q) ||
                        (f.note || '').toLowerCase().includes(q) ||
                        f.type.toLowerCase().includes(q)
                    );
                }
                return features;
            });

            // Helper: parse hex color to RGB
            const hexToRgb = (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 128, g: 128, b: 128 };
            };

            // Helper: RGB to hex
            const rgbToHex = (r, g, b) => {
                return '#' + [r, g, b].map(x => {
                    const hex = Math.round(Math.max(0, Math.min(255, x))).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            };

            // Interpolate between two colors
            const interpolateColor = (color1, color2, factor) => {
                const c1 = hexToRgb(color1);
                const c2 = hexToRgb(color2);
                return rgbToHex(
                    c1.r + (c2.r - c1.r) * factor,
                    c1.g + (c2.g - c1.g) * factor,
                    c1.b + (c2.b - c1.b) * factor
                );
            };

            // Estimate the interpolation factor from a current color given min/max colors
            const estimateColorFactor = (currentColor, minColor, maxColor) => {
                const current = hexToRgb(currentColor);
                const min = hexToRgb(minColor);
                const max = hexToRgb(maxColor);

                // Calculate factor based on color distance
                const totalDist = Math.sqrt(
                    Math.pow(max.r - min.r, 2) + Math.pow(max.g - min.g, 2) + Math.pow(max.b - min.b, 2)
                );
                if (totalDist < 1) return 0.5;

                const currentDist = Math.sqrt(
                    Math.pow(current.r - min.r, 2) + Math.pow(current.g - min.g, 2) + Math.pow(current.b - min.b, 2)
                );
                return Math.max(0, Math.min(1, currentDist / totalDist));
            };

            const getFeatureColor = (feat) => {
                // Use internal ID for tracking (unique per feature)
                const override = featureColorOverrides[feat.id];
                if (override) {
                    return override.color || override;  // Support both {color, caption} and legacy string format
                }
                // Otherwise use the default color for this feature type from the palette
                return currentColors.value[feat.type] || '#cccccc';
            };

            // Helper to check if a feature can be identified for color editing
            // Always true - we can always use location as a unique identifier
            const canEditFeatureColor = (feat) => {
                return true;  // Location is always available
            };

            // Helper to get the best qualifier for a feature
            // Uses hash pseudo-qualifier which is always unique (based on type+position+strand)
            // The svg_id is computed the same way in both Python and JavaScript
            const getFeatureQualifier = (feat) => {
                // Always use hash - it's the most reliable unique identifier
                // svg_id is pre-computed for each feature (e.g., "f1a2b3c4")
                return { qual: 'hash', val: feat.svg_id };
            };

            // Instant preview: update SVG path colors directly without regeneration
            const applyInstantPreview = (feat, color, legendCaption = null) => {
                // Use pre-computed svg_id that matches Python's hash
                const svgId = feat.svg_id;
                if (!svgId) {
                    console.log('No svg_id for feature', feat);
                    return;
                }

                // Update results array (svgContent is computed from results)
                const idx = selectedResultIndex.value;
                if (results.value.length > idx && results.value[idx].content) {
                    try {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(results.value[idx].content, 'image/svg+xml');

                        // Find ALL elements with this ID (for multi-exon features)
                        const elements = doc.querySelectorAll(`#${CSS.escape(svgId)}`);
                        let updated = elements.length > 0;

                        if (updated) {
                            elements.forEach(el => el.setAttribute('fill', color));
                        }

                        // Note: Legend entries are added separately via addLegendEntry() in setFeatureColor()

                        if (updated) {
                            const serializer = new XMLSerializer();
                            const newContent = serializer.serializeToString(doc.documentElement);
                            // Replace the entire object to ensure Vue reactivity
                            results.value[idx] = { ...results.value[idx], content: newContent };
                            console.log(`Instant preview: updated ${elements.length} element(s) for ${svgId} to ${color}`);
                        } else {
                            console.log(`Instant preview: element ${svgId} not found in SVG`);
                        }
                    } catch (e) {
                        console.error('Instant preview error:', e);
                    }
                }
            };

            // Attach click handlers to SVG feature paths
            const attachSvgFeatureHandlers = () => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                // Find all paths with id starting with 'f' (feature hash IDs)
                const featurePaths = svg.querySelectorAll('path[id^="f"], polygon[id^="f"]');

                // Group paths by ID (for multi-exon features)
                const pathsByIdMap = {};
                featurePaths.forEach(path => {
                    const id = path.getAttribute('id');
                    if (!pathsByIdMap[id]) pathsByIdMap[id] = [];
                    pathsByIdMap[id].push(path);
                });

                // Helper to highlight all segments of a feature
                const highlightFeature = (svgId, highlight) => {
                    const paths = pathsByIdMap[svgId] || [];
                    paths.forEach(p => {
                        p.style.opacity = highlight ? '0.7' : '1';
                        p.style.filter = highlight ? 'brightness(1.2)' : 'none';
                    });
                };

                featurePaths.forEach(path => {
                    const svgId = path.getAttribute('id');
                    path.style.cursor = 'pointer';

                    // Hover: highlight ALL segments with same ID
                    path.addEventListener('mouseenter', () => highlightFeature(svgId, true));
                    path.addEventListener('mouseleave', () => highlightFeature(svgId, false));

                    // Click handler
                    path.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // Find matching feature from extractedFeatures
                        const feat = extractedFeatures.value.find(f => f.svg_id === svgId);
                        if (feat) {
                            const currentColor = path.getAttribute('fill') || getFeatureColor(feat);
                            const defaultLabel = feat.product || feat.gene || feat.locus_tag || `${feat.type} at ${feat.start}..${feat.end}`;

                            // Check if there's an existing override with a caption
                            const existingOverride = featureColorOverrides[feat.id];
                            const existingCaption = existingOverride?.caption || '';

                            clickedFeature.value = {
                                id: feat.id,
                                svg_id: svgId,
                                label: defaultLabel,
                                color: currentColor,
                                feat: feat,
                                // Pre-fill with existing caption if available, otherwise empty
                                legendName: existingCaption
                            };
                            // Position popup near click
                            clickedFeaturePos.x = Math.min(e.clientX + 10, window.innerWidth - 280);
                            clickedFeaturePos.y = Math.min(e.clientY + 10, window.innerHeight - 100);
                        } else {
                            console.log(`No feature found for svg_id: ${svgId}`);
                        }
                    });
                });

                console.log(`Attached handlers to ${featurePaths.length} feature paths (${Object.keys(pathsByIdMap).length} unique features)`);
            };

            // Update color from the popup picker
            const updateClickedFeatureColor = (color) => {
                if (!clickedFeature.value) return;
                const feat = clickedFeature.value.feat;
                // Use custom legendName if provided (check for non-empty trimmed string)
                const customName = clickedFeature.value.legendName?.trim();
                const legendName = customName ? customName : clickedFeature.value.label;
                clickedFeature.value.color = color;
                setFeatureColor(feat, color, legendName);
            };

            // Watch for SVG content changes to reattach handlers
            watch(() => svgContent.value, () => {
                // Use nextTick to ensure DOM is updated
                Vue.nextTick(() => {
                    attachSvgFeatureHandlers();
                });
            });

            // Function to apply palette colors to SVG immediately
            const applyPaletteToSvg = () => {
                if (!svgContent.value || !extractedFeatures.value.length) return;
                if (!svgContainer.value) return;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                const colors = currentColors.value;
                const featurePaths = svg.querySelectorAll('path[id^="f"]');
                let updatedCount = 0;

                featurePaths.forEach(path => {
                    const svgId = path.getAttribute('id');
                    const feat = extractedFeatures.value.find(f => f.svg_id === svgId);
                    if (!feat) return;

                    const paletteColor = colors[feat.type];
                    if (!paletteColor) return;

                    // Don't update if feature has a specific color rule
                    const hasSpecificRule = manualSpecificRules.some(r => {
                        const qualInfo = getFeatureQualifier(feat);
                        return qualInfo && r.feat === feat.type && r.qual === qualInfo.qual && r.val === qualInfo.val;
                    });

                    if (!hasSpecificRule && !featureColorOverrides[feat.id]) {
                        const currentFill = path.getAttribute('fill');
                        if (currentFill !== paletteColor) {
                            path.setAttribute('fill', paletteColor);
                            updatedCount++;
                        }
                    }
                });

                // Update GC content track
                const gcContentGroup = svg.getElementById('gc_content');
                if (gcContentGroup && colors.gc_content) {
                    const gcPaths = gcContentGroup.querySelectorAll('path');
                    gcPaths.forEach(path => {
                        path.setAttribute('fill', colors.gc_content);
                        updatedCount++;
                    });
                }

                // Update GC skew track (circular: #skew, linear: #gc_skew)
                const skewGroup = svg.getElementById('skew') || svg.getElementById('gc_skew');
                if (skewGroup) {
                    const skewPaths = skewGroup.querySelectorAll('path');
                    // In circular: first visible path is high (after clipPath), second is low
                    // In linear: similar structure
                    let pathIndex = 0;
                    skewPaths.forEach(path => {
                        const fill = path.getAttribute('fill');
                        // Skip clipPath paths (fill="white") and non-filled paths
                        if (fill && fill !== 'white' && fill !== 'none') {
                            if (pathIndex === 0 && colors.skew_high) {
                                path.setAttribute('fill', colors.skew_high);
                                updatedCount++;
                            } else if (pathIndex === 1 && colors.skew_low) {
                                path.setAttribute('fill', colors.skew_low);
                                updatedCount++;
                            }
                            pathIndex++;
                        }
                    });
                }

                // Update pairwise match tracks (comparison1, comparison2, etc.)
                // These use color interpolation based on identity
                if (colors.pairwise_match_min && colors.pairwise_match_max) {
                    let compIdx = 1;
                    let compGroup = svg.getElementById(`comparison${compIdx}`);
                    while (compGroup) {
                        const matchPaths = compGroup.querySelectorAll('path');
                        matchPaths.forEach((path, pathIdx) => {
                            const pathKey = `comp${compIdx}_path${pathIdx}`;
                            const currentFill = path.getAttribute('fill');
                            if (currentFill) {
                                let factor;
                                // Check if we have a stored factor for this path
                                if (pairwiseMatchFactors.value[pathKey] !== undefined) {
                                    factor = pairwiseMatchFactors.value[pathKey];
                                } else {
                                    // First time - estimate factor from original colors used when diagram was generated
                                    const origMin = window._origPairwiseMin || '#FFE7E7';
                                    const origMax = window._origPairwiseMax || '#FF7272';
                                    factor = estimateColorFactor(currentFill, origMin, origMax);
                                    pairwiseMatchFactors.value[pathKey] = factor;
                                }
                                const newColor = interpolateColor(colors.pairwise_match_min, colors.pairwise_match_max, factor);
                                path.setAttribute('fill', newColor);
                                updatedCount++;
                            }
                        });
                        compIdx++;
                        compGroup = svg.getElementById(`comparison${compIdx}`);
                    }
                }

                // Also update legend colors - try to match by group position since text is converted to paths
                const legendGroup = svg.getElementById('legend');
                if (legendGroup) {
                    // Group paths by transform Y position
                    const pathsByY = {};
                    const allPaths = legendGroup.querySelectorAll('path');
                    allPaths.forEach(p => {
                        const transform = p.getAttribute('transform');
                        if (transform) {
                            const match = transform.match(/translate\(([^,]+),\s*([\d.]+)\)/);
                            if (match) {
                                const x = parseFloat(match[1]);
                                const y = match[2];
                                if (!pathsByY[y]) pathsByY[y] = [];
                                pathsByY[y].push({ path: p, x });
                            }
                        }
                    });

                    // Legend order typically: CDS, GC content, GC skew (+), GC skew (-), etc.
                    // The first path at x=0 for each Y is the color rectangle
                    const legendOrder = ['CDS', 'gc_content', 'skew_high', 'skew_low'];
                    const legendColors = {
                        'CDS': colors.CDS,
                        'gc_content': colors.gc_content,
                        'skew_high': colors.skew_high,
                        'skew_low': colors.skew_low
                    };

                    // Sort Y positions and update color rectangles
                    const yPositions = Object.keys(pathsByY).sort((a, b) => parseFloat(a) - parseFloat(b));
                    yPositions.forEach((y, idx) => {
                        const paths = pathsByY[y];
                        // Find the color rectangle (usually at x=0, has simple d attribute)
                        const colorRect = paths.find(p => p.x === 0 || Math.abs(p.x) < 1);
                        if (colorRect && idx < legendOrder.length) {
                            const colorKey = legendOrder[idx];
                            const newColor = legendColors[colorKey];
                            if (newColor) {
                                colorRect.path.setAttribute('fill', newColor);
                                updatedCount++;
                            }
                        }
                    });

                    // Update pairwise legend gradient
                    const pairwiseLegend = legendGroup.querySelector('#pairwise_legend') || svg.getElementById('pairwise_legend');
                    if (pairwiseLegend && colors.pairwise_match_min && colors.pairwise_match_max) {
                        // Find the linearGradient element
                        const gradient = pairwiseLegend.querySelector('linearGradient');
                        if (gradient) {
                            const stops = gradient.querySelectorAll('stop');
                            if (stops.length >= 2) {
                                // First stop is min color (0%), second is max color (100%)
                                stops[0].setAttribute('stop-color', colors.pairwise_match_min);
                                stops[1].setAttribute('stop-color', colors.pairwise_match_max);
                                updatedCount++;
                            }
                        }
                    }
                }

                if (updatedCount > 0) {
                    const idx = selectedResultIndex.value;
                    if (idx >= 0 && results.value.length > idx) {
                        const serializer = new XMLSerializer();
                        results.value[idx] = { ...results.value[idx], content: serializer.serializeToString(svg) };
                    }
                }
            };

            // Watch for palette color changes
            watch(currentColors, () => {
                applyPaletteToSvg();
            }, { deep: true });

            // Function to apply specific rules to SVG immediately
            const applySpecificRulesToSvg = () => {
                if (!svgContent.value || !extractedFeatures.value.length) return;
                if (!svgContainer.value) return;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                let updatedCount = 0;

                // For each extracted feature, check if it matches any specific rule
                extractedFeatures.value.forEach(feat => {
                    if (!feat.svg_id) return;

                    // Check if there's a matching specific rule
                    let matchingRule = null;
                    for (const rule of manualSpecificRules) {
                        if (rule.feat !== feat.type) continue;

                        let matches = false;
                        if (rule.qual === 'product' && feat.product) {
                            // Support regex matching
                            try {
                                const regex = new RegExp(rule.val, 'i');
                                matches = regex.test(feat.product);
                            } catch {
                                matches = feat.product === rule.val;
                            }
                        } else if (rule.qual === 'gene' && feat.gene) {
                            try {
                                const regex = new RegExp(rule.val, 'i');
                                matches = regex.test(feat.gene);
                            } catch {
                                matches = feat.gene === rule.val;
                            }
                        } else if (rule.qual === 'locus_tag' && feat.locus_tag) {
                            try {
                                const regex = new RegExp(rule.val, 'i');
                                matches = regex.test(feat.locus_tag);
                            } catch {
                                matches = feat.locus_tag === rule.val;
                            }
                        } else if (rule.qual === 'hash' && feat.svg_id === rule.val) {
                            matches = true;
                        }

                        if (matches) {
                            matchingRule = rule;
                            break;
                        }
                    }

                    // Apply color based on matching rule or default palette
                    const elements = svg.querySelectorAll(`#${CSS.escape(feat.svg_id)}`);
                    if (elements.length > 0) {
                        const newColor = matchingRule ? matchingRule.color : (currentColors.value[feat.type] || '#cccccc');
                        elements.forEach(el => {
                            if (el.getAttribute('fill') !== newColor) {
                                el.setAttribute('fill', newColor);
                                updatedCount++;
                            }
                        });
                    }
                });

                if (updatedCount > 0) {
                    const idx = selectedResultIndex.value;
                    if (idx >= 0 && results.value.length > idx) {
                        const serializer = new XMLSerializer();
                        results.value[idx] = { ...results.value[idx], content: serializer.serializeToString(svg) };
                    }
                    console.log(`Applied specific rules: updated ${updatedCount} elements`);
                }
            };

            // Track legend entries added by specific rules
            const addedLegendCaptions = ref(new Set());

            // Watch for specific rules changes - only apply styles and handle removals
            // Legend ADDITIONS are handled by setFeatureColor to avoid race conditions
            watch(() => [...manualSpecificRules], async (newRules, oldRules) => {
                applySpecificRulesToSvg();

                // Get captions from current rules
                const currentCaptions = new Set(newRules.filter(r => r.cap).map(r => r.cap));

                // Find removed captions (were in addedLegendCaptions but not in current rules)
                const removedCaptions = [...addedLegendCaptions.value].filter(cap => !currentCaptions.has(cap));

                // Remove legend entries for removed captions only
                for (const cap of removedCaptions) {
                    removeLegendEntry(cap);
                    addedLegendCaptions.value.delete(cap);
                }

                // DO NOT add legend entries here - that's handled by setFeatureColor
                // to avoid race conditions and duplicate entries
            }, { deep: true });

            // Function to apply style changes (stroke colors/widths) to SVG immediately
            const applyStylesToSvg = () => {
                if (!svgContent.value) return;
                if (!svgContainer.value) return;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                let updatedCount = 0;

                // Update block stroke (feature paths)
                if (adv.block_stroke_color || adv.block_stroke_width !== null) {
                    const featurePaths = svg.querySelectorAll('path[id^="f"]');
                    featurePaths.forEach(path => {
                        if (adv.block_stroke_color) {
                            path.setAttribute('stroke', adv.block_stroke_color);
                            updatedCount++;
                        }
                        if (adv.block_stroke_width !== null) {
                            path.setAttribute('stroke-width', adv.block_stroke_width);
                            updatedCount++;
                        }
                    });
                }

                // Update axis stroke
                const axisGroup = svg.getElementById('Axis');
                if (axisGroup) {
                    const axisElements = axisGroup.querySelectorAll('path, line, circle');
                    axisElements.forEach(el => {
                        if (adv.axis_stroke_color) {
                            el.setAttribute('stroke', adv.axis_stroke_color);
                            updatedCount++;
                        }
                        if (adv.axis_stroke_width !== null) {
                            el.setAttribute('stroke-width', adv.axis_stroke_width);
                            updatedCount++;
                        }
                    });
                }

                // Update tick stroke (same as axis typically)
                const tickGroup = svg.getElementById('tick');
                if (tickGroup) {
                    const tickElements = tickGroup.querySelectorAll('path, line');
                    tickElements.forEach(el => {
                        if (adv.axis_stroke_color) {
                            el.setAttribute('stroke', adv.axis_stroke_color);
                            updatedCount++;
                        }
                        if (adv.axis_stroke_width !== null) {
                            el.setAttribute('stroke-width', adv.axis_stroke_width);
                            updatedCount++;
                        }
                    });
                }

                // Update intron/line strokes (paths without fill or with fill="none")
                if (adv.line_stroke_color || adv.line_stroke_width !== null) {
                    // Find paths that are likely intron lines (no fill or fill=none, have stroke)
                    const allPaths = svg.querySelectorAll('path');
                    allPaths.forEach(path => {
                        const fill = path.getAttribute('fill');
                        const stroke = path.getAttribute('stroke');
                        const id = path.getAttribute('id') || '';
                        // Intron lines typically have no fill and are not feature blocks
                        if ((fill === 'none' || !fill) && stroke && !id.startsWith('f')) {
                            if (adv.line_stroke_color) {
                                path.setAttribute('stroke', adv.line_stroke_color);
                                updatedCount++;
                            }
                            if (adv.line_stroke_width !== null) {
                                path.setAttribute('stroke-width', adv.line_stroke_width);
                                updatedCount++;
                            }
                        }
                    });
                }

                // Update scale bar (linear mode)
                const lengthBarGroup = svg.getElementById('length_bar');
                if (lengthBarGroup) {
                    const scaleElements = lengthBarGroup.querySelectorAll('line, path');
                    scaleElements.forEach(el => {
                        if (adv.scale_stroke_color) {
                            el.setAttribute('stroke', adv.scale_stroke_color);
                            updatedCount++;
                        }
                        if (adv.scale_stroke_width !== null) {
                            el.setAttribute('stroke-width', adv.scale_stroke_width);
                            updatedCount++;
                        }
                    });
                }

                if (updatedCount > 0) {
                    const idx = selectedResultIndex.value;
                    if (idx >= 0 && results.value.length > idx) {
                        const serializer = new XMLSerializer();
                        results.value[idx] = { ...results.value[idx], content: serializer.serializeToString(svg) };
                    }
                    console.log(`Applied styles: updated ${updatedCount} elements`);
                }
            };

            // Watch for style changes
            watch(() => [
                adv.block_stroke_color, adv.block_stroke_width,
                adv.line_stroke_color, adv.line_stroke_width,
                adv.axis_stroke_color, adv.axis_stroke_width,
                adv.scale_stroke_color, adv.scale_stroke_width
            ], () => {
                applyStylesToSvg();
            });

            // Function to toggle track visibility
            const applyTrackVisibility = () => {
                if (!svgContent.value) return;
                if (!svgContainer.value) return;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                let updated = false;

                // GC content track
                const gcContentGroup = svg.getElementById('gc_content');
                if (gcContentGroup) {
                    const shouldHide = mode.value === 'circular' ? form.suppress_gc : !form.show_gc;
                    const currentDisplay = gcContentGroup.getAttribute('display');
                    if (shouldHide && currentDisplay !== 'none') {
                        gcContentGroup.setAttribute('display', 'none');
                        updated = true;
                    } else if (!shouldHide && currentDisplay === 'none') {
                        gcContentGroup.removeAttribute('display');
                        updated = true;
                    }
                }

                // GC skew track (circular: #skew, linear: #gc_skew)
                const skewGroup = svg.getElementById('skew') || svg.getElementById('gc_skew');
                if (skewGroup) {
                    const shouldHide = mode.value === 'circular' ? form.suppress_skew : !form.show_skew;
                    const currentDisplay = skewGroup.getAttribute('display');
                    if (shouldHide && currentDisplay !== 'none') {
                        skewGroup.setAttribute('display', 'none');
                        updated = true;
                    } else if (!shouldHide && currentDisplay === 'none') {
                        skewGroup.removeAttribute('display');
                        updated = true;
                    }
                }

                if (updated) {
                    const idx = selectedResultIndex.value;
                    if (idx >= 0 && results.value.length > idx) {
                        const serializer = new XMLSerializer();
                        results.value[idx] = { ...results.value[idx], content: serializer.serializeToString(svg) };
                    }
                    console.log('Track visibility updated');
                }
            };

            // Watch for track visibility changes
            watch(() => [form.suppress_gc, form.suppress_skew, form.show_gc, form.show_skew], () => {
                applyTrackVisibility();
            });

            // Function to add a legend entry dynamically using Pyodide
            const addLegendEntry = async (caption, color) => {
                if (!svgContainer.value || !pyodideReady.value) return false;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return false;

                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) {
                    console.log('No legend group found');
                    return false;
                }

                // Determine target group: feature_legend (linear) or legend (circular)
                const featureLegendGroup = legendGroup.querySelector('#feature_legend');
                const targetGroup = featureLegendGroup || legendGroup;

                // Check existing legend entries
                const existingTexts = targetGroup.querySelectorAll('text');
                let finalCaption = caption.trim();

                // Check if exact caption exists
                for (const t of existingTexts) {
                    const existingCaption = t.textContent?.trim();
                    if (existingCaption === finalCaption) {
                        // Found exact match - check if color is the same
                        const transform = t.getAttribute('transform');
                        if (transform) {
                            const match = transform.match(/translate\([^,]+,\s*([\d.]+)\)/);
                            if (match) {
                                const y = match[1];
                                // Find the color rect at the same Y
                                const rects = targetGroup.querySelectorAll('path');
                                for (const r of rects) {
                                    const rt = r.getAttribute('transform');
                                    if (rt && rt.includes(`, ${y})`)) {
                                        const existingColor = r.getAttribute('fill');
                                        if (existingColor === color) {
                                            // Same caption, same color - no change needed
                                            return finalCaption;
                                        }
                                        // Same caption, different color - need unique name
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                // Generate unique caption if needed (e.g., "hypothetical protein (1)")
                const baseCaption = finalCaption.replace(/\s*\(\d+\)$/, '');  // Remove existing (N) suffix
                let counter = 1;
                const existingCaptions = new Set();
                existingTexts.forEach(t => existingCaptions.add(t.textContent?.trim()));

                while (existingCaptions.has(finalCaption)) {
                    finalCaption = `${baseCaption} (${counter})`;
                    counter++;
                }

                // Update the caption parameter for the caller
                caption = finalCaption;

                // Detect rect_size from existing legend entries
                let rectSize = 14;  // Default
                const firstColorRect = targetGroup.querySelector('path[fill]:not([fill="none"]):not([fill^="url("])');
                if (firstColorRect) {
                    const d = firstColorRect.getAttribute('d');
                    if (d) {
                        // Parse path to extract rect size: M 0,-7 L 14,-7 L 14,7 L 0,7 z
                        const lMatch = d.match(/L\s+([\d.]+),/);
                        if (lMatch) {
                            rectSize = parseFloat(lMatch[1]);
                        }
                    }
                }

                // Detect font settings from existing text elements
                let fontSize = 14;
                let fontFamily = 'Arial';
                const firstText = targetGroup.querySelector('text');
                if (firstText) {
                    const fs = firstText.getAttribute('font-size');
                    if (fs) fontSize = parseFloat(fs);
                    const ff = firstText.getAttribute('font-family');
                    if (ff) fontFamily = ff;
                }

                const lineMargin = (24 / 14) * rectSize;
                const xMargin = (22 / 14) * rectSize;

                // Find max Y position in feature legend entries only (not background rect)
                let maxY = -lineMargin;  // Start at -lineMargin so first entry is at y=0
                const textElements = targetGroup.querySelectorAll('text');
                textElements.forEach(el => {
                    const transform = el.getAttribute('transform');
                    if (transform) {
                        const match = transform.match(/translate\([^,]+,\s*([\d.-]+)\)/);
                        if (match) {
                            const y = parseFloat(match[1]);
                            if (y > maxY) maxY = y;
                        }
                    }
                });

                // If no text elements found, check for paths with solid fills (entry rects)
                if (textElements.length === 0) {
                    const colorRects = targetGroup.querySelectorAll('path');
                    colorRects.forEach(el => {
                        const fill = el.getAttribute('fill');
                        if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                            const transform = el.getAttribute('transform');
                            if (transform) {
                                const match = transform.match(/translate\([^,]+,\s*([\d.-]+)\)/);
                                if (match) {
                                    const y = parseFloat(match[1]);
                                    if (y > maxY) maxY = y;
                                }
                            }
                        }
                    });
                }

                // Calculate new Y position
                const newY = maxY + lineMargin;

                try {
                    // Call Python to generate legend entry SVG with correct sizing and font settings
                    const escapedCaption = caption.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
                    const escapedFontFamily = fontFamily.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
                    const resultJson = pyodide.runPython(`generate_legend_entry_svg("${escapedCaption}", "${color}", ${newY}, ${rectSize}, ${fontSize}, "${escapedFontFamily}")`);
                    const result = JSON.parse(resultJson);

                    // Parse and insert the SVG elements
                    const parser = new DOMParser();

                    // Insert rect
                    const rectDoc = parser.parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${result.rect}</svg>`, 'image/svg+xml');
                    const rectEl = rectDoc.querySelector('path');
                    if (rectEl) {
                        targetGroup.appendChild(document.importNode(rectEl, true));
                    }

                    // Insert text
                    const textDoc = parser.parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${result.text}</svg>`, 'image/svg+xml');
                    const textEl = textDoc.querySelector('text');
                    if (textEl) {
                        targetGroup.appendChild(document.importNode(textEl, true));
                    }

                    // Update results for reactivity
                    const idx = selectedResultIndex.value;
                    if (idx >= 0 && results.value.length > idx) {
                        const serializer = new XMLSerializer();
                        results.value[idx] = { ...results.value[idx], content: serializer.serializeToString(svg) };
                    }

                    console.log(`Added legend entry: "${finalCaption}" at y=${newY} in ${featureLegendGroup ? 'feature_legend' : 'legend'}`);
                    return finalCaption;  // Return the actual caption used (may have (N) suffix)
                } catch (e) {
                    console.error('Failed to add legend entry:', e);
                    return false;
                }
            };

            // Function to update legend entry color by caption (without removing)
            const updateLegendEntryColorByCaption = (caption, color) => {
                if (!svgContainer.value) return false;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return false;

                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return false;

                // Determine target group: feature_legend (linear) or legend (circular)
                const featureLegendGroup = legendGroup.querySelector('#feature_legend');
                const targetGroup = featureLegendGroup || legendGroup;

                // Helper to parse Y from transform (handles both "translate(x, y)" and "translate(x,y)")
                const getTransformY = (transform) => {
                    if (!transform) return null;
                    const match = transform.match(/translate\(\s*[\d.-]+\s*,\s*([\d.-]+)\s*\)/);
                    return match ? parseFloat(match[1]) : null;
                };

                // Find text element with this caption
                const texts = targetGroup.querySelectorAll('text');
                let updated = false;

                for (const t of texts) {
                    if (t.textContent?.trim() === caption.trim()) {
                        const textY = getTransformY(t.getAttribute('transform'));
                        if (textY !== null) {
                            // Find and update the color rect at the same Y
                            const rects = targetGroup.querySelectorAll('path');
                            for (const r of rects) {
                                const rectY = getTransformY(r.getAttribute('transform'));
                                if (rectY !== null && Math.abs(rectY - textY) < 0.1) {
                                    const fill = r.getAttribute('fill');
                                    if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                                        r.setAttribute('fill', color);
                                        updated = true;
                                        break;
                                    }
                                }
                            }
                        }
                        break;
                    }
                }

                if (updated) {
                    // Save to results
                    const idx = selectedResultIndex.value;
                    if (idx >= 0 && results.value.length > idx) {
                        const serializer = new XMLSerializer();
                        results.value[idx] = { ...results.value[idx], content: serializer.serializeToString(svg) };
                    }
                    console.log(`Updated legend entry color: "${caption}" to ${color}`);
                }

                return updated;
            };

            // Function to check if a legend entry exists with given caption
            const legendEntryExists = (caption) => {
                if (!svgContainer.value) return false;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return false;

                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return false;

                const featureLegendGroup = legendGroup.querySelector('#feature_legend');
                const targetGroup = featureLegendGroup || legendGroup;

                const texts = targetGroup.querySelectorAll('text');
                for (const t of texts) {
                    if (t.textContent?.trim() === caption.trim()) {
                        return true;
                    }
                }
                return false;
            };

            // Helper to parse Y coordinate from transform attribute
            const parseTransformY = (transform) => {
                if (!transform) return null;
                // Match both "translate(x, y)" and "translate(x,y)" formats
                const match = transform.match(/translate\(\s*[\d.-]+\s*,\s*([\d.-]+)\s*\)/);
                return match ? parseFloat(match[1]) : null;
            };

            // Function to remove a legend entry by caption
            const removeLegendEntry = (caption) => {
                if (!svgContainer.value) return false;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return false;

                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return false;

                // Determine target group: feature_legend (linear) or legend (circular)
                const featureLegendGroup = legendGroup.querySelector('#feature_legend');
                const targetGroup = featureLegendGroup || legendGroup;

                // Find text element with this caption
                const texts = targetGroup.querySelectorAll('text');
                let removed = false;

                texts.forEach(t => {
                    if (t.textContent?.trim() === caption.trim()) {
                        const textY = parseTransformY(t.getAttribute('transform'));
                        if (textY !== null) {
                            // Find and remove the color rect at the same Y (within tolerance)
                            const rects = targetGroup.querySelectorAll('path');
                            rects.forEach(r => {
                                const rectY = parseTransformY(r.getAttribute('transform'));
                                // Check if Y coordinates match (within 0.1 tolerance for floating point)
                                if (rectY !== null && Math.abs(rectY - textY) < 0.1) {
                                    // Make sure it's a color rect (has solid fill, not gradient)
                                    const fill = r.getAttribute('fill');
                                    if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                                        r.remove();
                                    }
                                }
                            });
                        }
                        t.remove();
                        removed = true;
                    }
                });

                if (removed) {
                    const idx = selectedResultIndex.value;
                    if (idx >= 0 && results.value.length > idx) {
                        const serializer = new XMLSerializer();
                        results.value[idx] = { ...results.value[idx], content: serializer.serializeToString(svg) };
                    }
                    console.log(`Removed legend entry: "${caption}"`);
                }

                return removed;
            };

            // Extract legend entries from current SVG for the Legend Editor panel
            const extractLegendEntries = () => {
                if (!svgContainer.value) {
                    legendEntries.value = [];
                    return;
                }

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) {
                    legendEntries.value = [];
                    return;
                }

                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) {
                    legendEntries.value = [];
                    return;
                }

                // Determine target group: feature_legend (linear) or legend (circular)
                const featureLegendGroup = legendGroup.querySelector('#feature_legend');
                const targetGroup = featureLegendGroup || legendGroup;

                const entries = [];

                // Find all text elements in legend (these are the captions)
                const textElements = targetGroup.querySelectorAll('text');
                textElements.forEach(textEl => {
                    const caption = textEl.textContent?.trim();
                    if (!caption) return;

                    const transform = textEl.getAttribute('transform');
                    let yPos = 0;
                    if (transform) {
                        const match = transform.match(/translate\([^,]+,\s*([\d.-]+)\)/);
                        if (match) yPos = parseFloat(match[1]);
                    }

                    // Find the color rect at the same Y position
                    let color = '#cccccc';
                    const paths = targetGroup.querySelectorAll('path');
                    paths.forEach(p => {
                        const pt = p.getAttribute('transform');
                        if (pt) {
                            const pMatch = pt.match(/translate\([^,]+,\s*([\d.-]+)\)/);
                            if (pMatch && Math.abs(parseFloat(pMatch[1]) - yPos) < 1) {
                                const fill = p.getAttribute('fill');
                                if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                                    color = fill;
                                }
                            }
                        }
                    });

                    entries.push({ caption, color, yPos });
                });

                // Sort by Y position
                entries.sort((a, b) => a.yPos - b.yPos);
                legendEntries.value = entries;
            };

            // Update legend entry color
            const updateLegendEntryColor = (idx, newColor) => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                const entry = legendEntries.value[idx];
                if (!entry) return;

                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return;

                // Determine target group: feature_legend (linear) or legend (circular)
                const featureLegendGroup = legendGroup.querySelector('#feature_legend');
                const targetGroup = featureLegendGroup || legendGroup;

                // Find and update the color rect at this Y position
                const paths = targetGroup.querySelectorAll('path');
                paths.forEach(p => {
                    const pt = p.getAttribute('transform');
                    if (pt) {
                        const pMatch = pt.match(/translate\([^,]+,\s*([\d.-]+)\)/);
                        if (pMatch && Math.abs(parseFloat(pMatch[1]) - entry.yPos) < 1) {
                            const fill = p.getAttribute('fill');
                            if (fill && fill !== 'none' && !fill.startsWith('url(')) {
                                p.setAttribute('fill', newColor);
                            }
                        }
                    }
                });

                // Update local state
                legendEntries.value[idx].color = newColor;

                // Save to results
                const resultIdx = selectedResultIndex.value;
                if (resultIdx >= 0 && results.value.length > resultIdx) {
                    const serializer = new XMLSerializer();
                    results.value[resultIdx] = { ...results.value[resultIdx], content: serializer.serializeToString(svg) };
                }
            };

            // Update legend entry caption
            const updateLegendEntryCaption = (idx, newCaption) => {
                if (!svgContainer.value || !newCaption.trim()) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                const entry = legendEntries.value[idx];
                if (!entry) return;

                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return;

                // Determine target group: feature_legend (linear) or legend (circular)
                const featureLegendGroup = legendGroup.querySelector('#feature_legend');
                const targetGroup = featureLegendGroup || legendGroup;

                // Find and update the text element at this Y position
                const texts = targetGroup.querySelectorAll('text');
                texts.forEach(t => {
                    const tt = t.getAttribute('transform');
                    if (tt) {
                        const tMatch = tt.match(/translate\([^,]+,\s*([\d.-]+)\)/);
                        if (tMatch && Math.abs(parseFloat(tMatch[1]) - entry.yPos) < 1) {
                            t.textContent = newCaption;
                        }
                    }
                });

                // Update local state
                legendEntries.value[idx].caption = newCaption;

                // Save to results
                const resultIdx = selectedResultIndex.value;
                if (resultIdx >= 0 && results.value.length > resultIdx) {
                    const serializer = new XMLSerializer();
                    results.value[resultIdx] = { ...results.value[resultIdx], content: serializer.serializeToString(svg) };
                }
            };

            // Delete legend entry by index
            const deleteLegendEntry = (idx) => {
                const entry = legendEntries.value[idx];
                if (!entry) return;

                removeLegendEntry(entry.caption);
                extractLegendEntries();  // Refresh the list
            };

            // Move legend entry up (swap with previous)
            const moveLegendEntryUp = (idx) => {
                if (idx <= 0) return;
                swapLegendEntries(idx, idx - 1);
            };

            // Move legend entry down (swap with next)
            const moveLegendEntryDown = (idx) => {
                if (idx >= legendEntries.value.length - 1) return;
                swapLegendEntries(idx, idx + 1);
            };

            // Swap two legend entries by exchanging their Y positions in the SVG
            const swapLegendEntries = (idx1, idx2) => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return;

                // Determine target group: feature_legend (linear) or legend (circular)
                const featureLegendGroup = legendGroup.querySelector('#feature_legend');
                const targetGroup = featureLegendGroup || legendGroup;

                const entry1 = legendEntries.value[idx1];
                const entry2 = legendEntries.value[idx2];
                if (!entry1 || !entry2) return;

                const y1 = entry1.yPos;
                const y2 = entry2.yPos;

                // Find and update elements at y1 position
                const allElements = targetGroup.querySelectorAll('path, text');
                allElements.forEach(el => {
                    const transform = el.getAttribute('transform');
                    if (!transform) return;

                    const match = transform.match(/translate\(([^,]+),\s*([\d.-]+)\)/);
                    if (!match) return;

                    const x = match[1];
                    const y = parseFloat(match[2]);

                    // Check if this element belongs to entry1 or entry2
                    if (Math.abs(y - y1) < 1) {
                        // This element belongs to entry1, move to y2
                        el.setAttribute('transform', `translate(${x}, ${y2})`);
                    } else if (Math.abs(y - y2) < 1) {
                        // This element belongs to entry2, move to y1
                        el.setAttribute('transform', `translate(${x}, ${y1})`);
                    }
                });

                // Update local state (swap yPos values)
                legendEntries.value[idx1].yPos = y2;
                legendEntries.value[idx2].yPos = y1;

                // Swap entries in array to reflect visual order
                const temp = { ...legendEntries.value[idx1] };
                legendEntries.value[idx1] = { ...legendEntries.value[idx2], yPos: y1 };
                legendEntries.value[idx2] = { ...temp, yPos: y2 };

                // Save to results
                const resultIdx = selectedResultIndex.value;
                if (resultIdx >= 0 && results.value.length > resultIdx) {
                    const serializer = new XMLSerializer();
                    results.value[resultIdx] = { ...results.value[resultIdx], content: serializer.serializeToString(svg) };
                }

                // Re-extract to ensure correct ordering
                extractLegendEntries();
            };

            // Add new legend entry from the UI
            const addNewLegendEntry = async () => {
                if (!newLegendCaption.value.trim()) return;

                const added = await addLegendEntry(newLegendCaption.value.trim(), newLegendColor.value);
                if (added) {
                    newLegendCaption.value = '';
                    newLegendColor.value = '#808080';
                    // Refresh after a short delay to allow DOM update
                    setTimeout(() => extractLegendEntries(), 100);
                }
            };

            // Legend drag functions
            const parseTransform = (transformStr) => {
                if (!transformStr) return { x: 0, y: 0 };
                const match = transformStr.match(/translate\(\s*([-\d.]+)\s*,?\s*([-\d.]+)?\s*\)/);
                if (match) {
                    return { x: parseFloat(match[1]) || 0, y: parseFloat(match[2]) || 0 };
                }
                return { x: 0, y: 0 };
            };

            const startLegendDrag = (e) => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;
                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return;

                // Prevent default to avoid text selection
                e.preventDefault();

                legendDragging.value = true;
                legendDragStart.x = e.clientX;
                legendDragStart.y = e.clientY;

                // Parse current transform
                const currentTransform = parseTransform(legendGroup.getAttribute('transform'));
                legendOriginalTransform.value = { ...currentTransform };

                // Add visual feedback
                legendGroup.style.cursor = 'grabbing';
                legendGroup.style.opacity = '0.8';

                // Add document-level event listeners
                document.addEventListener('mousemove', onLegendDrag);
                document.addEventListener('mouseup', endLegendDrag);
            };

            const onLegendDrag = (e) => {
                if (!legendDragging.value) return;
                if (!svgContainer.value) return;

                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;
                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return;

                // Calculate delta, accounting for zoom level
                const deltaX = (e.clientX - legendDragStart.x) / zoom.value;
                const deltaY = (e.clientY - legendDragStart.y) / zoom.value;

                // Apply new transform
                const newX = legendOriginalTransform.value.x + deltaX;
                const newY = legendOriginalTransform.value.y + deltaY;
                legendGroup.setAttribute('transform', `translate(${newX}, ${newY})`);

                // Store current offset
                legendCurrentOffset.x = newX;
                legendCurrentOffset.y = newY;
            };

            const endLegendDrag = () => {
                if (!legendDragging.value) return;

                legendDragging.value = false;

                // Remove document-level event listeners
                document.removeEventListener('mousemove', onLegendDrag);
                document.removeEventListener('mouseup', endLegendDrag);

                // Reset visual feedback
                if (svgContainer.value) {
                    const svg = svgContainer.value.querySelector('svg');
                    if (svg) {
                        const legendGroup = svg.getElementById('legend');
                        if (legendGroup) {
                            legendGroup.style.cursor = 'grab';
                            legendGroup.style.opacity = '1';
                        }
                    }
                }
            };

            const resetLegendPosition = () => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;
                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return;

                // Reset to original position (restore initial transform)
                const initial = legendInitialTransform.value;
                if (initial.x !== 0 || initial.y !== 0) {
                    legendGroup.setAttribute('transform', `translate(${initial.x}, ${initial.y})`);
                } else {
                    legendGroup.removeAttribute('transform');
                }
                legendCurrentOffset.x = 0;
                legendCurrentOffset.y = 0;
            };

            const setupLegendDrag = () => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;
                const legendGroup = svg.getElementById('legend');
                if (!legendGroup) return;

                // Store the legend's initial transform from the SVG
                const initialTransform = parseTransform(legendGroup.getAttribute('transform'));
                legendInitialTransform.value = { ...initialTransform };

                // Reset offset tracking
                legendCurrentOffset.x = 0;
                legendCurrentOffset.y = 0;

                // Set cursor style
                legendGroup.style.cursor = 'grab';

                // Remove existing listener to avoid duplicates
                legendGroup.removeEventListener('mousedown', startLegendDrag);
                // Add mousedown listener
                legendGroup.addEventListener('mousedown', startLegendDrag);
            };

            // Main diagram drag functions (moves tick, labels, axis, definition, records as one group)
            const startDiagramDrag = (e) => {
                // Don't start if clicking on legend or feature elements
                if (e.target.closest('#legend') ||
                    e.target.closest('path[data-feature-id]') ||
                    e.target.closest('rect[data-feature-id]')) {
                    return;
                }
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                // Check if clicking inside a diagram element
                const clickedGroup = e.target.closest('g[id]');
                if (!clickedGroup) return;

                const clickedId = clickedGroup.id;
                // Only start drag if clicking on a main diagram element (not legend)
                if (clickedId === 'legend' || clickedId === 'feature_legend' || clickedId === 'pairwise_legend') {
                    return;
                }

                e.preventDefault();
                diagramDragging.value = true;
                diagramDragStart.x = e.clientX;
                diagramDragStart.y = e.clientY;

                // Visual feedback on all diagram elements
                diagramElements.value.forEach(el => {
                    el.style.opacity = '0.8';
                });

                document.addEventListener('mousemove', onDiagramDrag);
                document.addEventListener('mouseup', endDiagramDrag);
            };

            const onDiagramDrag = (e) => {
                if (!diagramDragging.value) return;

                // Calculate delta, accounting for zoom level
                const deltaX = (e.clientX - diagramDragStart.x) / zoom.value;
                const deltaY = (e.clientY - diagramDragStart.y) / zoom.value;

                // Apply transform to all diagram elements, preserving their original positions
                diagramElements.value.forEach(el => {
                    const original = diagramElementOriginalTransforms.value.get(el) || { x: 0, y: 0 };
                    const newX = original.x + diagramOffset.x + deltaX;
                    const newY = original.y + diagramOffset.y + deltaY;
                    el.setAttribute('transform', `translate(${newX}, ${newY})`);
                });
            };

            const endDiagramDrag = () => {
                if (!diagramDragging.value) return;

                // Update stored offset
                const deltaX = (event.clientX - diagramDragStart.x) / zoom.value;
                const deltaY = (event.clientY - diagramDragStart.y) / zoom.value;
                diagramOffset.x += deltaX;
                diagramOffset.y += deltaY;

                diagramDragging.value = false;
                document.removeEventListener('mousemove', onDiagramDrag);
                document.removeEventListener('mouseup', endDiagramDrag);

                // Reset visual feedback
                diagramElements.value.forEach(el => {
                    el.style.opacity = '1';
                });
            };

            const resetDiagramPosition = () => {
                // Reset offset
                diagramOffset.x = 0;
                diagramOffset.y = 0;

                // Restore original transforms for all diagram elements
                diagramElements.value.forEach(el => {
                    const original = diagramElementOriginalTransforms.value.get(el);
                    if (original && (original.x !== 0 || original.y !== 0)) {
                        el.setAttribute('transform', `translate(${original.x}, ${original.y})`);
                    } else {
                        el.removeAttribute('transform');
                    }
                });
            };

            const resetAllPositions = () => {
                resetDiagramPosition();
                resetLegendPosition();
            };

            // Reposition elements when legend position dropdown changes
            const repositionForLegendChange = (newPosition, oldPosition) => {
                if (!svgContainer.value || !svgContent.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                const legendGroup = svg.getElementById('legend');
                const isLinear = mode.value === 'linear';

                // Get SVG dimensions
                let viewBox = svg.getAttribute('viewBox');
                if (!viewBox) return;
                const parts = viewBox.split(/\s+/).map(parseFloat);
                if (parts.length !== 4) return;
                let [vbX, vbY, vbW, vbH] = parts;

                // Get legend dimensions (approximate from legend group bounds)
                let legendWidth = 120;  // Default estimate
                let legendHeight = 150; // Default estimate
                if (legendGroup) {
                    const bbox = legendGroup.getBBox();
                    legendWidth = bbox.width || legendWidth;
                    legendHeight = bbox.height || legendHeight;
                }

                // Calculate legend position based on position setting (different for linear vs circular)
                const calcLegendPos = (pos) => {
                    if (isLinear) {
                        // Linear diagram positions
                        const padding = 20;
                        switch (pos) {
                            case 'right':
                                return { x: vbW - legendWidth - padding, y: (vbH - legendHeight) / 2 };
                            case 'left':
                                return { x: padding, y: (vbH - legendHeight) / 2 };
                            case 'top':
                                return { x: (vbW - legendWidth) / 2, y: padding };
                            case 'bottom':
                                return { x: (vbW - legendWidth) / 2, y: vbH - legendHeight - padding };
                            case 'none':
                                return null;
                            default:
                                return { x: vbW - legendWidth - padding, y: (vbH - legendHeight) / 2 };
                        }
                    } else {
                        // Circular diagram positions
                        switch (pos) {
                            case 'right':
                                return { x: vbW - legendWidth - 10, y: (vbH - legendHeight) / 2 };
                            case 'left':
                                return { x: 10, y: (vbH - legendHeight) / 2 };
                            case 'upper_left':
                                return { x: 0.025 * vbW, y: 0.05 * vbH };
                            case 'upper_right':
                                return { x: 0.85 * vbW, y: 0.05 * vbH };
                            case 'lower_left':
                                return { x: 0.025 * vbW, y: 0.78 * vbH };
                            case 'lower_right':
                                return { x: 0.875 * vbW, y: 0.75 * vbH };
                            case 'none':
                                return null;
                            default:
                                return { x: vbW - legendWidth - 10, y: (vbH - legendHeight) / 2 };
                        }
                    }
                };

                // Calculate diagram offset based on legend position
                const calcDiagramOffset = (pos) => {
                    if (isLinear) {
                        // Linear: legend position affects diagram offset
                        const verticalPadding = legendHeight + 40; // legend height + spacing
                        switch (pos) {
                            case 'left':
                                return { x: legendWidth + 20, y: 0 };
                            case 'right':
                                return { x: 0, y: 0 };
                            case 'top':
                                return { x: 0, y: verticalPadding };
                            case 'bottom':
                                return { x: 0, y: 0 };
                            default:
                                return { x: 0, y: 0 };
                        }
                    } else {
                        // Circular: only left/right affects diagram
                        switch (pos) {
                            case 'left':
                                return { x: legendWidth * 0.5, y: 0 };
                            case 'right':
                                return { x: -legendWidth * 0.5, y: 0 };
                            default:
                                return { x: 0, y: 0 };
                        }
                    }
                };

                const oldLegendPos = calcLegendPos(oldPosition);
                const newLegendPos = calcLegendPos(newPosition);
                const oldDiagramOffset = calcDiagramOffset(oldPosition);
                const newDiagramOffset = calcDiagramOffset(newPosition);

                // Determine layout direction
                const isHorizontalLayout = (pos) => pos === 'top' || pos === 'bottom';
                const isVerticalLayout = (pos) => pos === 'left' || pos === 'right';
                const oldIsHorizontal = isHorizontalLayout(oldPosition);
                const newIsHorizontal = isHorizontalLayout(newPosition);
                const layoutChanged = isLinear && (oldIsHorizontal !== newIsHorizontal) && newPosition !== 'none';

                // Handle legend visibility and position
                if (legendGroup) {
                    if (newPosition === 'none') {
                        legendGroup.style.display = 'none';
                    } else {
                        legendGroup.style.display = '';

                        // Rearrange legend entries if layout direction changed (horizontal <-> vertical)
                        if (layoutChanged) {
                            const featureLegendGroup = legendGroup.querySelector('#feature_legend');
                            const pairwiseLegendGroup = legendGroup.querySelector('#pairwise_legend');

                            const entrySpacing = 24; // line_height = (24/14) * rect_size, rect_size ~= 14
                            const textXOffset = 22;  // text_x_offset = (22/14) * rect_size
                            const rectSize = 14;

                            // Store legend bounds before rearrangement for viewBox calculation
                            const oldLegendBbox = legendGroup.getBBox();
                            const oldLegendTransform = parseTransform(legendGroup.getAttribute('transform'));

                            // Process feature_legend_group
                            if (featureLegendGroup) {
                                // Remove group-level transform first
                                featureLegendGroup.removeAttribute('transform');

                                // NOTE: All legend elements are <path> - both color rectangles AND text
                                // (generate_text_path creates path elements, not text elements)
                                // Rectangle paths are at X offset ~0, text paths are at X offset ~22
                                const allPaths = featureLegendGroup.querySelectorAll('path');

                                // Collect all path data
                                const pathData = [];
                                allPaths.forEach(p => {
                                    const t = parseTransform(p.getAttribute('transform'));
                                    pathData.push({ el: p, x: t.x, y: t.y });
                                });

                                // Build entry list: each entry is {rect, text}
                                const entries = [];

                                if (oldIsHorizontal) {
                                    // Horizontal layout: entries arranged by X
                                    // Sort by X position
                                    pathData.sort((a, b) => a.x - b.x);

                                    // Pair consecutive elements (rect, text, rect, text, ...)
                                    for (let i = 0; i < pathData.length; i += 2) {
                                        const rect = pathData[i];
                                        const text = pathData[i + 1] || null;
                                        entries.push({ rect, text });
                                    }
                                } else {
                                    // Vertical layout: entries arranged by Y
                                    // Group by Y position, then separate rect (X~0) from text (X~22)
                                    const byY = new Map();
                                    pathData.forEach(p => {
                                        const yKey = Math.round(p.y);
                                        if (!byY.has(yKey)) byY.set(yKey, []);
                                        byY.get(yKey).push(p);
                                    });

                                    // Sort Y positions and build entries
                                    const yPositions = [...byY.keys()].sort((a, b) => a - b);
                                    yPositions.forEach(y => {
                                        const elements = byY.get(y);
                                        // Sort by X - first is rect (X~0), second is text (X~22)
                                        elements.sort((a, b) => a.x - b.x);
                                        const rect = elements[0] || null;
                                        const text = elements[1] || null;
                                        entries.push({ rect, text });
                                    });
                                }

                                // Calculate text widths BEFORE moving anything
                                // (getBBox is unreliable after transform changes)
                                const entryWidths = entries.map(entry => {
                                    if (entry.text) {
                                        const bbox = entry.text.el.getBBox();
                                        return rectSize + textXOffset + bbox.width + textXOffset;
                                    }
                                    return rectSize + textXOffset * 2;
                                });

                                // Now rearrange entries to new layout
                                let featureLegendWidth = 0;
                                let featureLegendHeight = 0;

                                if (newIsHorizontal) {
                                    // Vertical â†’ Horizontal: Stack entries side by side
                                    let currentX = 0;
                                    const baseY = rectSize / 2;

                                    entries.forEach((entry, idx) => {
                                        if (entry.rect) {
                                            entry.rect.el.setAttribute('transform', `translate(${currentX}, ${baseY})`);
                                        }
                                        if (entry.text) {
                                            entry.text.el.setAttribute('transform', `translate(${currentX + textXOffset}, ${baseY})`);
                                        }
                                        currentX += entryWidths[idx];
                                    });
                                    featureLegendWidth = currentX;
                                    featureLegendHeight = entrySpacing;
                                } else {
                                    // Horizontal â†’ Vertical: Stack entries top to bottom
                                    let currentY = rectSize / 2;

                                    entries.forEach((entry, idx) => {
                                        if (entry.rect) {
                                            entry.rect.el.setAttribute('transform', `translate(0, ${currentY})`);
                                        }
                                        if (entry.text) {
                                            entry.text.el.setAttribute('transform', `translate(${textXOffset}, ${currentY})`);
                                        }
                                        currentY += entrySpacing;
                                    });
                                    featureLegendHeight = currentY;
                                    featureLegendWidth = Math.max(...entryWidths);
                                }

                                // Handle pairwise_legend_group positioning
                                if (pairwiseLegendGroup) {
                                    // Clear any existing transform first
                                    pairwiseLegendGroup.removeAttribute('transform');

                                    // Get actual bounding boxes for proper alignment
                                    const featureBbox = featureLegendGroup.getBBox();
                                    const pairwiseBbox = pairwiseLegendGroup.getBBox();

                                    if (newIsHorizontal) {
                                        // Place pairwise legend to the right of feature legend
                                        // Both should be centered on the same Y baseline
                                        // Feature legend center Y = featureBbox.y + featureBbox.height/2
                                        // Pairwise legend should be vertically centered with feature legend
                                        const featureCenterY = featureBbox.y + featureBbox.height / 2;
                                        const pairwiseCenterY = pairwiseBbox.y + pairwiseBbox.height / 2;
                                        const pairwiseY = featureCenterY - pairwiseCenterY;

                                        // X position: right of feature legend with spacing
                                        const pairwiseX = featureBbox.x + featureBbox.width + textXOffset;

                                        pairwiseLegendGroup.setAttribute('transform', `translate(${pairwiseX}, ${pairwiseY})`);
                                    } else {
                                        // Place pairwise legend below feature legend
                                        // Center horizontally relative to each other
                                        const featureBbox = featureLegendGroup.getBBox();
                                        const pairwiseBbox = pairwiseLegendGroup.getBBox();

                                        // Y position: below feature legend with spacing
                                        const pairwiseY = featureBbox.y + featureBbox.height + entrySpacing / 2;

                                        // X position: center if pairwise is wider, otherwise align left
                                        let pairwiseX = 0;
                                        if (pairwiseBbox.width > featureBbox.width) {
                                            // Center feature legend relative to pairwise
                                            const featureXOffset = (pairwiseBbox.width - featureBbox.width) / 2;
                                            entries.forEach(entry => {
                                                if (entry.rect) {
                                                    const t = parseTransform(entry.rect.el.getAttribute('transform'));
                                                    entry.rect.el.setAttribute('transform', `translate(${t.x + featureXOffset}, ${t.y})`);
                                                }
                                                if (entry.text) {
                                                    const t = parseTransform(entry.text.el.getAttribute('transform'));
                                                    entry.text.el.setAttribute('transform', `translate(${t.x + featureXOffset}, ${t.y})`);
                                                }
                                            });
                                        } else {
                                            // Center pairwise legend relative to feature
                                            pairwiseX = (featureBbox.width - pairwiseBbox.width) / 2;
                                        }
                                        pairwiseLegendGroup.setAttribute('transform', `translate(${pairwiseX}, ${pairwiseY})`);
                                    }
                                }
                            }

                            // Update legend dimensions after rearrangement
                            const newLegendBbox = legendGroup.getBBox();
                            legendWidth = newLegendBbox.width || legendWidth;
                            legendHeight = newLegendBbox.height || legendHeight;

                            // Calculate viewBox change based on layout direction change
                            // Vertical layout (left/right): legend adds to WIDTH
                            // Horizontal layout (top/bottom): legend adds to HEIGHT
                            const layoutPadding = 40; // Space between legend and content

                            if (newIsHorizontal) {
                                // Converting from vertical to horizontal
                                // - Remove legend width from canvas width
                                // - Add legend height to canvas height
                                const widthReduction = oldLegendBbox.width + layoutPadding;
                                const heightAddition = newLegendBbox.height + layoutPadding;

                                vbW = vbW - widthReduction;
                                vbH = vbH + heightAddition;
                            } else {
                                // Converting from horizontal to vertical
                                // - Add legend width to canvas width
                                // - Remove legend height from canvas height
                                const widthAddition = newLegendBbox.width + layoutPadding;
                                const heightReduction = oldLegendBbox.height + layoutPadding;

                                vbW = vbW + widthAddition;
                                vbH = vbH - heightReduction;
                            }

                            // Ensure minimum dimensions
                            vbW = Math.max(vbW, 400);
                            vbH = Math.max(vbH, 200);

                            svg.setAttribute('viewBox', `${vbX} ${vbY} ${vbW} ${vbH}`);
                        }

                        if (newLegendPos || layoutChanged) {
                            // Calculate position with updated legend dimensions
                            const padding = 20;
                            let finalX, finalY;

                            if (isLinear) {
                                // Linear: position based on top/bottom/left/right
                                switch (newPosition) {
                                    case 'top':
                                        finalX = (vbW - legendWidth) / 2;
                                        finalY = padding;
                                        break;
                                    case 'bottom':
                                        finalX = (vbW - legendWidth) / 2;
                                        finalY = vbH - legendHeight - padding;
                                        break;
                                    case 'left':
                                        finalX = padding;
                                        finalY = (vbH - legendHeight) / 2;
                                        break;
                                    case 'right':
                                    default:
                                        finalX = vbW - legendWidth - padding;
                                        finalY = (vbH - legendHeight) / 2;
                                        break;
                                }
                            } else {
                                // Circular: use calcLegendPos which handles all circular positions
                                // (right, left, upper_left, upper_right, lower_left, lower_right)
                                if (newLegendPos) {
                                    finalX = newLegendPos.x;
                                    finalY = newLegendPos.y;
                                } else {
                                    // Fallback
                                    finalX = vbW - legendWidth - padding;
                                    finalY = (vbH - legendHeight) / 2;
                                }
                            }

                            legendGroup.setAttribute('transform', `translate(${finalX}, ${finalY})`);

                            // Update initial transform for reset
                            legendInitialTransform.value = { x: finalX, y: finalY };
                            legendCurrentOffset.x = 0;
                            legendCurrentOffset.y = 0;
                        }
                    }
                }

                // Determine if diagram elements should move
                const shouldMoveDiagram = isLinear
                    ? (oldPosition !== newPosition && newPosition !== 'none')  // Linear: move for any valid transition
                    : ((oldPosition === 'left' || oldPosition === 'right') &&
                       (newPosition === 'left' || newPosition === 'right'));   // Circular: only left/right

                if (shouldMoveDiagram && diagramElements.value.length > 0) {
                    const diagramDeltaX = newDiagramOffset.x - oldDiagramOffset.x;
                    const diagramDeltaY = newDiagramOffset.y - oldDiagramOffset.y;

                    if (diagramDeltaX !== 0 || diagramDeltaY !== 0) {
                        const newOriginalTransforms = new Map();

                        diagramElements.value.forEach(el => {
                            const original = diagramElementOriginalTransforms.value.get(el) || { x: 0, y: 0 };
                            const newX = original.x + diagramDeltaX;
                            const newY = original.y + diagramDeltaY;

                            el.setAttribute('transform', `translate(${newX}, ${newY})`);
                            newOriginalTransforms.set(el, { x: newX, y: newY });
                        });

                        // Update original transforms for reset
                        diagramElementOriginalTransforms.value = newOriginalTransforms;
                        diagramOffset.x = 0;
                        diagramOffset.y = 0;
                    }
                }

                // Update tracked generated position
                generatedLegendPosition.value = newPosition;

                console.log(`Legend repositioned (${isLinear ? 'linear' : 'circular'}): ${oldPosition} -> ${newPosition}`);
            };

            // Discover and setup draggable diagram elements
            // Store actual DOM elements since IDs can be duplicated (record and definition share same ID)
            const diagramElements = ref([]);

            const setupDiagramDrag = () => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                // Reset offset
                diagramOffset.x = 0;
                diagramOffset.y = 0;

                // Known main diagram element IDs
                const knownIds = ['tick', 'labels', 'Axis', 'gc_content', 'skew', 'gc_skew', 'length_bar'];
                const foundElements = [];
                const foundIds = [];

                // Add known IDs that exist
                knownIds.forEach(id => {
                    const el = svg.getElementById(id);
                    if (el) {
                        foundElements.push(el);
                        foundIds.push(id);
                    }
                });

                // Find ALL groups (including those with duplicate IDs like record and definition)
                const allGroups = svg.querySelectorAll('g[id]');
                allGroups.forEach(group => {
                    const id = group.id;
                    if (!id) return;

                    // Skip legend groups
                    if (id === 'legend' || id === 'feature_legend' || id === 'pairwise_legend') return;

                    // Skip if this exact element is already added
                    if (foundElements.includes(group)) return;

                    // Check for record/definition-like IDs (accession numbers, etc.)
                    const isAccession = id.match(/^[A-Z]{2}_?\d+/) ||  // NC_012920, AP027078
                                       id.match(/^[A-Z]+\d+\.\d+$/);   // AP027078.1
                    const isKnown = knownIds.includes(id);
                    const isDynamic = id.startsWith('record_') ||
                                     id.startsWith('definition_') ||
                                     id.startsWith('seq_') ||
                                     id.startsWith('track_') ||
                                     id.startsWith('match_') ||
                                     id.startsWith('comparison');  // pairwise match groups

                    if (isAccession || isKnown || isDynamic) {
                        foundElements.push(group);
                        if (!foundIds.includes(id)) {
                            foundIds.push(id);
                        }
                    }
                });

                diagramElements.value = foundElements;
                diagramElementIds.value = foundIds;

                // Store original transforms for each element
                const originalTransforms = new Map();
                foundElements.forEach(el => {
                    const transform = parseTransform(el.getAttribute('transform'));
                    originalTransforms.set(el, transform);
                });
                diagramElementOriginalTransforms.value = originalTransforms;

                // Set cursor on all diagram elements
                foundElements.forEach(el => {
                    el.style.cursor = 'grab';
                });

                // Add mousedown listener to SVG for diagram dragging
                svg.removeEventListener('mousedown', startDiagramDrag);
                svg.addEventListener('mousedown', startDiagramDrag);
            };

            // Canvas size functions
            const applyCanvasPadding = () => {
                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                // Get original viewBox or create one from width/height
                let viewBox = svg.getAttribute('viewBox');
                if (!viewBox) {
                    const width = parseFloat(svg.getAttribute('width')) || 800;
                    const height = parseFloat(svg.getAttribute('height')) || 600;
                    viewBox = `0 0 ${width} ${height}`;
                }

                const parts = viewBox.split(/\s+/).map(parseFloat);
                if (parts.length !== 4) return;

                // Store original viewBox if not already stored
                if (!svg.dataset.originalViewBox) {
                    svg.dataset.originalViewBox = viewBox;
                }

                const [origX, origY, origW, origH] = svg.dataset.originalViewBox.split(/\s+/).map(parseFloat);

                // Calculate new viewBox with padding
                const newX = origX - canvasPadding.left;
                const newY = origY - canvasPadding.top;
                const newW = origW + canvasPadding.left + canvasPadding.right;
                const newH = origH + canvasPadding.top + canvasPadding.bottom;

                svg.setAttribute('viewBox', `${newX} ${newY} ${newW} ${newH}`);

                // Update width/height to maintain aspect ratio
                const origWidth = parseFloat(svg.dataset.originalWidth || svg.getAttribute('width')) || origW;
                const origHeight = parseFloat(svg.dataset.originalHeight || svg.getAttribute('height')) || origH;
                if (!svg.dataset.originalWidth) {
                    svg.dataset.originalWidth = origWidth;
                    svg.dataset.originalHeight = origHeight;
                }

                const scaleX = newW / origW;
                const scaleY = newH / origH;
                svg.setAttribute('width', origWidth * scaleX);
                svg.setAttribute('height', origHeight * scaleY);
            };

            const resetCanvasPadding = () => {
                canvasPadding.top = 0;
                canvasPadding.right = 0;
                canvasPadding.bottom = 0;
                canvasPadding.left = 0;

                if (!svgContainer.value) return;
                const svg = svgContainer.value.querySelector('svg');
                if (!svg) return;

                // Restore original viewBox
                if (svg.dataset.originalViewBox) {
                    svg.setAttribute('viewBox', svg.dataset.originalViewBox);
                }
                if (svg.dataset.originalWidth) {
                    svg.setAttribute('width', svg.dataset.originalWidth);
                    svg.setAttribute('height', svg.dataset.originalHeight);
                }
            };

            // Watch canvas padding changes
            watch(canvasPadding, () => {
                applyCanvasPadding();
            }, { deep: true });

            // Watch for legend position changes to reposition elements without regeneration
            watch(() => form.legend, (newPos, oldPos) => {
                // Only reposition if:
                // 1. SVG exists
                // 2. oldPos is defined (not initial setup)
                // 3. Position actually changed
                // 4. The generated position is already set (diagram was generated)
                // 5. newPos is different from the generated position (actual user change)
                if (svgContent.value &&
                    oldPos !== undefined &&
                    newPos !== oldPos &&
                    generatedLegendPosition.value &&
                    newPos !== generatedLegendPosition.value) {
                    Vue.nextTick(() => {
                        repositionForLegendChange(newPos, generatedLegendPosition.value);
                    });
                }
            });

            // Watch for SVG changes to refresh legend entries and setup drag
            watch(svgContent, () => {
                Vue.nextTick(() => {
                    extractLegendEntries();
                    setupLegendDrag();
                    setupDiagramDrag();
                    // Reset canvas padding for new SVG
                    canvasPadding.top = 0;
                    canvasPadding.right = 0;
                    canvasPadding.bottom = 0;
                    canvasPadding.left = 0;
                });
            });

            // Close popup when clicking outside
            const closeFeaturePopup = (e) => {
                if (!e.target.closest('.fixed.z-50')) {
                    if (clickedFeature.value) clickedFeature.value = null;
                }
            };

            onMounted(() => {
                document.addEventListener('click', closeFeaturePopup);
            });

            const setFeatureColor = async (feat, color, customCaption = null) => {
                // Use the best available qualifier for TSV generation
                const qualInfo = getFeatureQualifier(feat);
                if (!qualInfo) {
                    console.warn(`Cannot identify feature: ${feat.type} at ${feat.start}..${feat.end} (no locus_tag, gene, or product)`);
                    return;
                }
                const { qual, val } = qualInfo;

                // Use internal ID for UI tracking (unique across all features)
                const featureKey = feat.id;

                // Default caption if not provided
                const caption = customCaption || feat.product || feat.gene || feat.locus_tag || `${feat.type} at ${feat.start}..${feat.end}`;

                // Track override for UI display (store both color and caption)
                const oldOverride = featureColorOverrides[featureKey];
                const oldCaption = oldOverride?.caption;
                featureColorOverrides[featureKey] = { color, caption };

                // Apply instant preview (update SVG feature color directly)
                applyInstantPreview(feat, color, caption);

                // Handle legend entry FIRST, before adding rule to prevent watch race condition
                await Vue.nextTick();
                let actualCaption = caption;
                if (pyodideReady.value && caption) {
                    // Logic based on THIS FEATURE's existing legend entry (tracked by oldCaption):
                    // - oldCaption exists â†’ this feature already has a legend entry
                    // - oldCaption is undefined â†’ this feature doesn't have a legend entry yet

                    if (oldCaption) {
                        // This feature already has a legend entry
                        if (oldCaption === caption) {
                            // Same caption - just update the color of THIS feature's entry
                            updateLegendEntryColorByCaption(oldCaption, color);
                        } else {
                            // Caption changed - remove old entry, add new one
                            removeLegendEntry(oldCaption);
                            actualCaption = await addLegendEntry(caption, color);
                            if (actualCaption && typeof actualCaption === 'string') {
                                addedLegendCaptions.value.add(actualCaption);
                            }
                        }
                    } else {
                        // This feature doesn't have a legend entry yet - add new one
                        actualCaption = await addLegendEntry(caption, color);
                        if (actualCaption && typeof actualCaption === 'string') {
                            addedLegendCaptions.value.add(actualCaption);
                        }
                    }

                    // Update tracked caption if it changed (may have (N) suffix)
                    if (actualCaption && typeof actualCaption === 'string' && actualCaption !== caption) {
                        featureColorOverrides[featureKey] = { color, caption: actualCaption };
                    }
                    extractLegendEntries();  // Refresh legend editor
                }

                // NOW add/update the rule with the correct caption (possibly numbered)
                const finalCaption = (actualCaption && typeof actualCaption === 'string') ? actualCaption : caption;
                const existingIdx = manualSpecificRules.findIndex(r =>
                    r.feat === feat.type && r.qual === qual && r.val === val
                );

                if (existingIdx >= 0) {
                    // Update existing rule with final caption
                    manualSpecificRules[existingIdx].color = color;
                    manualSpecificRules[existingIdx].cap = finalCaption;
                } else {
                    // Add new rule with final caption
                    manualSpecificRules.push({
                        feat: feat.type,
                        qual: qual,
                        val: val,
                        color: color,
                        cap: finalCaption
                    });
                }
            };

            // Clear feature list when switching modes
            watch(() => mode.value, () => {
                extractedFeatures.value = [];
                featureRecordIds.value = [];
                selectedFeatureRecordIdx.value = 0;
                Object.keys(featureColorOverrides).forEach(k => delete featureColorOverrides[k]);
                showFeaturePanel.value = false;
            });

            watch(() => files.d_color, async (newFile) => {
                if (!newFile) return;
                try {
                    const text = await newFile.text();
                    const lines = text.split(/\r?\n/);
                    let count = 0;
                    
                    for (const line of lines) {
                        // Skip comments, empty lines, and section headers
                        if (!line.trim() || line.trim().startsWith('#') || line.trim().startsWith('[')) continue;
                        
                        const parts = line.split('\t');
                        if (parts.length >= 2) {
                            const key = parts[0].trim();
                            const color = parts[1].trim();
                            
                            // Apply if it's a color code (#...) or color name (red, blue, etc.)
                            if (key && (color.startsWith('#') || /^[a-z]+$/i.test(color))) {
                                currentColors.value[key] = color;
                                count++;
                            }
                        }
                    }
                    console.log(`Loaded ${count} colors from file.`);
                } catch (e) {
                    console.error("Failed to load color file:", e);
                    alert("Failed to load color file. Please check the TSV format.");
                }
            });
            watch(() => files.t_color, async (newFile) => {
                if (!newFile) return;
                try {
                    const text = await newFile.text();
                    const lines = text.split(/\r?\n/);
                    let count = 0;
                    
                    for (const line of lines) {
                        // Skip comments and empty lines
                        if (!line.trim() || line.trim().startsWith('#')) continue;
                        
                        const parts = line.split('\t');
                        // TSV format: Feature, Qualifier, Regex, Color, [Caption]
                        if (parts.length >= 4) {
                            manualSpecificRules.push({
                                feat: parts[0].trim(),
                                qual: parts[1].trim(),
                                val: parts[2].trim(),
                                color: parts[3].trim(),
                                cap: parts[4] ? parts[4].trim() : "" 
                            });
                            count++;
                        }
                    }
                    console.log(`Loaded ${count} rules from file.`);
                } catch (e) {
                    console.error("Failed to load rules file:", e);
                    alert("Failed to load rules file. Please check the TSV format.");
                }
            });
            watch(() => files.qualifier_priority, async (newFile) => {
                if (!newFile) return;
                try {
                    const text = await newFile.text();
                    const lines = text.split(/\r?\n/);
                    let count = 0;
                    
                    for (const line of lines) {
                        if (!line.trim() || line.trim().startsWith('#')) continue;
                        const parts = line.split('\t');
                        // TSV format: Feature<TAB>Qualifier1,Qualifier2,Qualifier3
                        if (parts.length >= 2) {
                            const feat = parts[0].trim();
                            const order = parts[1].trim();
                            
                            // If the same feature exists, overwrite it; otherwise, add it.
                            const idx = manualPriorityRules.findIndex(r => r.feat === feat);
                            if (idx >= 0) {
                                manualPriorityRules[idx].order = order;
                            } else {
                                manualPriorityRules.push({ feat, order });
                            }
                            count++;
                        }
                    }
                    console.log(`Loaded ${count} priority rules.`);
                } catch (e) {
                    console.error("Failed to load priority file:", e);
                    alert("Failed to load priority file.");
                }
            });
            watch(() => files.whitelist, async (newFile) => {
                if (!newFile) return;
                try {
                    const text = await newFile.text();
                    const lines = text.split(/\r?\n/);
                    let count = 0;
                    
                    for (const line of lines) {
                        if (!line.trim() || line.trim().startsWith('#')) continue;
                        const parts = line.split('\t');
                        if (parts.length >= 3) {
                            manualWhitelist.push({
                                feat: parts[0].trim(),
                                qual: parts[1].trim(),
                                key: parts[2].trim()
                            });
                            count++;
                        }
                    }
                    console.log(`Loaded ${count} whitelist rules.`);
                } catch (e) {
                    console.error("Failed to load whitelist file:", e);
                    alert("Failed to load whitelist file.");
                }
            });

            watch(() => files.blacklist, async (newFile) => {
                if (!newFile) return;
                try {
                    const text = await newFile.text();
                    // Load newline or comma-separated text and append to the textarea
                    const words = text.split(/[\r\n,]+/).map(w => w.trim()).filter(w => w);
                    
                    if (words.length > 0) {
                        const existing = manualBlacklist.value ? manualBlacklist.value.trim() : "";
                        // If there is existing text, add a comma before appending
                        const separator = existing && !existing.endsWith(',') ? ", " : "";
                        manualBlacklist.value = existing + separator + words.join(", ");
                        
                        console.log(`Loaded ${words.length} blacklist words.`);
                    }
                } catch (e) {
                    console.error("Failed to load blacklist file:", e);
                    alert("Failed to load blacklist file.");
                }
            });
            onMounted(async () => {
                try {
                    pyodide = await loadPyodide();
                    loadingStatus.value = "Installing dependencies...";
                    await pyodide.loadPackage("micropip");
                    const micropip = pyodide.pyimport("micropip");
                    await micropip.install(["biopython","svgwrite", "pandas", "fonttools", "bcbio-gff"]);
                    loadingStatus.value = "Installing gbdraw...";
                    await micropip.install(GBDRAW_WHEEL_NAME);
                    await pyodide.runPythonAsync(`
                        import warnings
                        warnings.simplefilter('ignore', SyntaxWarning)
                        import tomllib
                        from importlib import resources
                        import json
                        import traceback
                        import glob
                        import os
                        from gbdraw.circular import circular_main
                        from gbdraw.linear import linear_main
                        def get_palettes_json():
                            try:
                                with resources.files("gbdraw.data").joinpath("color_palettes.toml").open("rb") as fh:
                                    return json.dumps(tomllib.load(fh))
                            except: return "{}"

                        def run_gbdraw_wrapper(mode, args):

                            for f in glob.glob("*.svg"):
                                try: os.remove(f)
                                except: pass

                            full_args = args + ["-f", "svg"]
                            try:
                                if mode == 'circular': circular_main(full_args)
                                else: linear_main(full_args)
                            except SystemExit as e:
                                if e.code != 0: return json.dumps({"error": f"SystemExit: {e}"})
                            except Exception:
                                return json.dumps({"error": traceback.format_exc()})

                            files = glob.glob("*.svg")
                            if not files: return json.dumps({"error": "No output files generated."})
                            results = []
                            for fname in sorted(files):
                                with open(fname, "r") as f:
                                    results.append({"name": fname, "content": f.read()})
                            return json.dumps(results)

                        def generate_legend_entry_svg(caption, color, y_offset, rect_size=14, font_size=14, font_family="Arial"):
                            """Generate SVG elements for a single legend entry"""
                            from svgwrite.path import Path
                            from svgwrite.text import Text
                            import io

                            # Create color rectangle path
                            half = rect_size / 2
                            rect_d = f"M 0,{-half} L {rect_size},{-half} L {rect_size},{half} L 0,{half} z"
                            rect_svg = f'<path d="{rect_d}" fill="{color}" stroke="none" transform="translate(0, {y_offset})"/>'

                            # Create text element
                            x_margin = (22 / 14) * rect_size
                            text_svg = f'<text font-size="{font_size}" font-family="{font_family}" dominant-baseline="central" text-anchor="start" transform="translate({x_margin}, {y_offset})">{caption}</text>'

                            return json.dumps({"rect": rect_svg, "text": text_svg})

                        def extract_features_from_genbank(gb_path):
                            """Extract feature info from GenBank file for UI display"""
                            import hashlib
                            from Bio import SeqIO
                            features = []
                            record_ids = []
                            idx = 0
                            try:
                                for rec_idx, record in enumerate(SeqIO.parse(gb_path, "genbank")):
                                    record_id = record.id or f"Record_{rec_idx}"
                                    record_ids.append(record_id)
                                    for feat in record.features:
                                        if feat.type in ['CDS', 'tRNA', 'rRNA', 'ncRNA', 'misc_RNA', 'tmRNA',
                                                         'repeat_region', 'misc_feature', 'mobile_element',
                                                         'regulatory', 'gene', 'mRNA', 'exon', 'intron']:
                                            # Overall coordinates for display
                                            start = int(feat.location.start)
                                            end = int(feat.location.end)
                                            strand_raw = feat.location.strand

                                            # For svg_id hash, use FIRST part's coordinates (matches Python drawer)
                                            # CompoundLocation has .parts, SimpleLocation doesn't
                                            if hasattr(feat.location, 'parts') and feat.location.parts:
                                                first_part = feat.location.parts[0]
                                                hash_start = int(first_part.start)
                                                hash_end = int(first_part.end)
                                                hash_strand = first_part.strand
                                            else:
                                                hash_start = start
                                                hash_end = end
                                                hash_strand = strand_raw

                                            # Compute same hash as SVG rendering uses (must match Python drawer)
                                            key = f"{feat.type}:{hash_start}:{hash_end}:{hash_strand}"
                                            svg_id = "f" + hashlib.md5(key.encode()).hexdigest()[:8]
                                            features.append({
                                                "id": f"f{idx}",  # Unique internal ID for UI tracking
                                                "svg_id": svg_id,  # Matches SVG path id attribute
                                                "record_id": record_id,  # For multi-record filtering
                                                "record_idx": rec_idx,
                                                "type": feat.type,
                                                "start": start,
                                                "end": end,
                                                "strand": "+" if strand_raw == 1 else "-",
                                                "locus_tag": feat.qualifiers.get("locus_tag", [""])[0],
                                                "gene": feat.qualifiers.get("gene", [""])[0],
                                                "product": feat.qualifiers.get("product", [""])[0],
                                                "note": feat.qualifiers.get("note", [""])[0][:50] if feat.qualifiers.get("note") else "",
                                            })
                                            idx += 1
                            except Exception as e:
                                return json.dumps({"error": str(e)})
                            return json.dumps({"features": features, "record_ids": record_ids})
                    `);
                    const paletteJson = pyodide.runPython("get_palettes_json()");
                    const allPalettes = JSON.parse(paletteJson);
                    paletteNames.value = Object.keys(allPalettes).filter(k => k !== 'title').sort();
                    currentColors.value = allPalettes['default'] || {};
                    pyodideReady.value = true;
                } catch (e) {
                    loadingStatus.value = "Startup Error: " + e.message;
                    console.error(e);
                }
            });

            const updatePalette = () => {
                if(!pyodide) return;
                const paletteJson = pyodide.runPython("get_palettes_json()");
                const all = JSON.parse(paletteJson);
                currentColors.value =  { ...(all[selectedPalette.value] || {}) };
            };
            const resetColors = () => updatePalette();
            const writeToFS = async (fileObj, path) => {
                if(!fileObj) return false;
                const buffer = await fileObj.arrayBuffer();
                pyodide.FS.writeFile(path, new Uint8Array(buffer));
                return true;
            };

            const runAnalysis = async () => {
                if (!pyodideReady.value) return;
                processing.value = true;
                results.value = [];
                selectedResultIndex.value = 0;
                errorLog.value = null;
                zoom.value = 1.0;
                // Clear stored pairwise match factors for re-calculation
                pairwiseMatchFactors.value = {};
                // Clear tracked legend entries (will be regenerated)
                addedLegendCaptions.value = new Set();
                // Clear feature color overrides (custom legend entries from previous records)
                Object.keys(featureColorOverrides).forEach(k => delete featureColorOverrides[k]);
                legendEntries.value = [];
                // Store current palette's pairwise colors as reference for interpolation
                window._origPairwiseMin = currentColors.value.pairwise_match_min || '#FFE7E7';
                window._origPairwiseMax = currentColors.value.pairwise_match_max || '#FF7272';

                try {
                    let args = [];
                    
                    if(form.prefix && form.prefix.trim() !== "") args.push("-o", form.prefix.trim());
                    if(form.species) args.push("--species", form.species);
                    if(form.strain) args.push("--strain", form.strain);
                    if(form.separate_strands) args.push("--separate_strands");
                    
                    if(adv.features.length) args.push("-k", adv.features.join(","));
                    if(adv.window_size) args.push("--window", adv.window_size);
                    if(adv.step_size) args.push("--step", adv.step_size);
                    if(adv.nt && adv.nt !== "GC") args.push("--nt", adv.nt);

                    if(adv.def_font_size) args.push("--definition_font_size", adv.def_font_size);
                    if(adv.label_font_size) args.push("--label_font_size", adv.label_font_size);
                    
                    // Styles
                    if(adv.block_stroke_width !== null) args.push("--block_stroke_width", adv.block_stroke_width);
                    if(adv.block_stroke_color) args.push("--block_stroke_color", adv.block_stroke_color);
                    if(adv.line_stroke_width !== null) args.push("--line_stroke_width", adv.line_stroke_width);
                    if(adv.line_stroke_color) args.push("--line_stroke_color", adv.line_stroke_color);
                    if(adv.axis_stroke_width !== null) args.push("--axis_stroke_width", adv.axis_stroke_width);
                    if(adv.axis_stroke_color) args.push("--axis_stroke_color", adv.axis_stroke_color);
                    
                    // Legend Params
                    if(adv.legend_box_size) args.push("--legend_box_size", adv.legend_box_size);
                    if(adv.legend_font_size) args.push("--legend_font_size", adv.legend_font_size);

                    // Colors
                    let dContent = "";
                    for(const [k,v] of Object.entries(currentColors.value)) dContent += `${k}\t${v}\n`;
                    pyodide.FS.writeFile("/combined_d.tsv", dContent);
                    args.push("-d", "/combined_d.tsv");

                    let tContent = "";
                    // if (files.t_color) { tContent = await files.t_color.text(); if(!tContent.endsWith('\n')) tContent += '\n'; }
                    manualSpecificRules.forEach(r => { tContent += `${r.feat}\t${r.qual}\t${r.val}\t${r.color}\t${r.cap}\n`; });
                    if(tContent.trim() !== "") { pyodide.FS.writeFile("/combined_t.tsv", tContent); args.push("-t", "/combined_t.tsv"); }

                    // Filtering
                    if (filterMode.value === 'Blacklist') {
                        // Even if there is a file (files.blacklist), ignore it and use the manualBlacklist taken in by Watch as correct
                        if (manualBlacklist.value) { 
                            args.push("--label_blacklist", manualBlacklist.value.replace(/\n/g, ",")); 
                        }
                    } else if (filterMode.value === 'Whitelist') {
                        // Even if there is a file (files.whitelist), ignore it and use the manualWhitelist taken in by Watch as correct
                        if (manualWhitelist.length > 0) {
                            let wlContent = "";
                            manualWhitelist.forEach(r => { if(r.feat && r.qual) wlContent += `${r.feat}\t${r.qual}\t${r.key}\n` });
                            pyodide.FS.writeFile("/manual_wl.tsv", wlContent);
                            args.push("--label_whitelist", "/manual_wl.tsv");
                        }
                    }
                    // Priority File
                    let pContent = "";
                    manualPriorityRules.forEach(r => {
                        pContent += `${r.feat}\t${r.order}\n`;
                    });
                    
                    if (pContent.trim() !== "") {
                        pyodide.FS.writeFile("/priority.tsv", pContent);
                        args.push("--qualifier_priority", "/priority.tsv");
                    }

                    if (mode.value === 'circular') {
                        args.push("--track_type", form.track_type, "-l", form.legend);
                        if(form.show_labels) args.push("--show_labels");
                        if(form.allow_inner_labels) args.push("--allow_inner_labels");
                        if(form.suppress_gc) args.push("--suppress_gc");
                        if(form.suppress_skew) args.push("--suppress_skew");
                        
                        // Circular Offsets
                        if(adv.outer_label_x_offset) args.push("--outer_label_x_radius_offset", adv.outer_label_x_offset);
                        if(adv.outer_label_y_offset) args.push("--outer_label_y_radius_offset", adv.outer_label_y_offset);
                        if(adv.inner_label_x_offset) args.push("--inner_label_x_radius_offset", adv.inner_label_x_offset);
                        if(adv.inner_label_y_offset) args.push("--inner_label_y_radius_offset", adv.inner_label_y_offset);
                        if(adv.scale_interval) args.push("--scale_interval", adv.scale_interval);

                        if (cInputType.value === 'gb') {
                            if(!files.c_gb) throw new Error("Please upload a GenBank file.");
                            await writeToFS(files.c_gb, "/input.gb"); args.push("--gbk", "/input.gb");
                        } else {
                            if(!files.c_gff || !files.c_fasta) throw new Error("GFF3 and FASTA are required.");
                            await writeToFS(files.c_gff, "/input.gff"); await writeToFS(files.c_fasta, "/input.fasta");
                            args.push("--gff", "/input.gff", "--fasta", "/input.fasta");
                        }

                    } else { 
                        args.push("--scale_style", form.scale_style);
                        if(form.align_center) args.push("--align_center");
                        if(form.show_gc) args.push("--show_gc");
                        if(form.show_skew) args.push("--show_skew");
                        if(form.normalize_length) args.push("--normalize_length");
                        if(form.legend !== 'right') args.push("-l", form.legend);
                        args.push("--bitscore", adv.min_bitscore, "--evalue", adv.evalue, "--identity", adv.identity);
                        
                        // Linear Labels
                        if(form.show_labels_linear !== 'none') {
                            args.push("--show_labels");
                            if(form.show_labels_linear === 'first') args.push("first");
                        }
                        // Linear Specifics
                        if(adv.resolve_overlaps) args.push("--resolve_overlaps");
                        if(adv.feature_height) args.push("--feature_height", adv.feature_height);
                        if(adv.gc_height) args.push("--gc_height", adv.gc_height);
                        if(adv.comparison_height) args.push("--comparison_height", adv.comparison_height);
                        
                        // Linear Scale Settings
                        if(adv.scale_interval) args.push("--scale_interval", adv.scale_interval);
                        if(adv.scale_font_size) args.push("--scale_font_size", adv.scale_font_size);
                        if(adv.scale_stroke_width) args.push("--scale_stroke_width", adv.scale_stroke_width);
                        if(adv.scale_stroke_color) args.push("--scale_stroke_color", adv.scale_stroke_color);

                        let inputArgs = [], blastArgs = [];
                        for(let i=0; i<linearSeqs.length; i++) {
                            const seq = linearSeqs[i];
                            if (lInputType.value === 'gb') {
                                if(!seq.gb) throw new Error(`Sequence #${i+1}: Missing GenBank file.`);
                                await writeToFS(seq.gb, `/seq_${i}.gb`); inputArgs.push(`/seq_${i}.gb`);
                            } else {
                                if(!seq.gff || !seq.fasta) throw new Error(`Sequence #${i+1}: GFF3 and FASTA are required.`);
                                await writeToFS(seq.gff, `/seq_${i}.gff`); await writeToFS(seq.fasta, `/seq_${i}.fasta`);
                            }
                            if(i < linearSeqs.length - 1 && seq.blast) {
                                await writeToFS(seq.blast, `/blast_${i}.txt`); blastArgs.push(`/blast_${i}.txt`);
                            }
                        }
                        if(lInputType.value === 'gb') args.push("--gbk", ...inputArgs);
                        else {
                             let gffs = [], fastas = [];
                             for(let i=0; i<linearSeqs.length; i++) { gffs.push(`/seq_${i}.gff`); fastas.push(`/seq_${i}.fasta`); }
                             args.push("--gff", ...gffs, "--fasta", ...fastas);
                        }
                        if(blastArgs.length) args.push("-b", ...blastArgs);
                    }

                    console.log("CMD:", args.join(" "));
                    const jsonResult = pyodide.globals.get("run_gbdraw_wrapper")(mode.value, pyodide.toPy(args.map(String)));
                    const res = JSON.parse(jsonResult);
                    if(res.error) throw new Error(res.error);
                    results.value = res;

                    // Store legend position used at generation time
                    generatedLegendPosition.value = form.legend;

                    // Extract features for color editor (only for GenBank input)
                    extractedFeatures.value = [];

                    // Helper to rebuild featureColorOverrides from manualSpecificRules
                    const rebuildColorOverrides = (features) => {
                        // Clear existing overrides
                        Object.keys(featureColorOverrides).forEach(k => delete featureColorOverrides[k]);

                        // For each feature, check if there's a matching rule
                        for (const feat of features) {
                            // Look for a matching rule in manualSpecificRules
                            for (const rule of manualSpecificRules) {
                                if (rule.feat !== feat.type) continue;

                                let matches = false;
                                // Hash qualifier - highest priority, most reliable
                                if (rule.qual === 'hash' && feat.svg_id) {
                                    try {
                                        const regex = new RegExp(rule.val, 'i');
                                        matches = regex.test(feat.svg_id);
                                    } catch (e) {
                                        matches = feat.svg_id === rule.val;
                                    }
                                } else if (rule.qual === 'locus_tag' && feat.locus_tag) {
                                    try {
                                        const regex = new RegExp(rule.val, 'i');
                                        matches = regex.test(feat.locus_tag);
                                    } catch (e) {
                                        matches = feat.locus_tag === rule.val;
                                    }
                                } else if (rule.qual === 'gene' && feat.gene) {
                                    try {
                                        const regex = new RegExp(rule.val, 'i');
                                        matches = regex.test(feat.gene);
                                    } catch (e) {
                                        matches = feat.gene.toLowerCase().includes(rule.val.toLowerCase());
                                    }
                                } else if (rule.qual === 'product' && feat.product) {
                                    try {
                                        const regex = new RegExp(rule.val, 'i');
                                        matches = regex.test(feat.product);
                                    } catch (e) {
                                        matches = feat.product.toLowerCase().includes(rule.val.toLowerCase());
                                    }
                                }

                                if (matches) {
                                    // Use internal ID as key, store {color, caption} object
                                    featureColorOverrides[feat.id] = { color: rule.color, caption: rule.cap };
                                    break; // First match wins
                                }
                            }
                        }
                    };

                    if (mode.value === 'circular' && cInputType.value === 'gb') {
                        try {
                            const featJson = pyodide.globals.get("extract_features_from_genbank")("/input.gb");
                            const featData = JSON.parse(featJson);
                            if (!featData.error && featData.features) {
                                extractedFeatures.value = featData.features;
                                featureRecordIds.value = featData.record_ids || [];
                                selectedFeatureRecordIdx.value = 0;
                                rebuildColorOverrides(featData.features);
                                console.log(`Extracted ${featData.features.length} features from ${featData.record_ids.length} record(s) for color editor.`);
                            }
                        } catch (e) {
                            console.log("Could not extract features:", e);
                        }
                    } else if (mode.value === 'linear' && lInputType.value === 'gb' && linearSeqs.length > 0) {
                        // Extract features from ALL GenBank files in linear mode
                        try {
                            let allFeatures = [];
                            let allRecordLabels = [];
                            for (let i = 0; i < linearSeqs.length; i++) {
                                const featJson = pyodide.globals.get("extract_features_from_genbank")(`/seq_${i}.gb`);
                                const featData = JSON.parse(featJson);
                                if (!featData.error && featData.features) {
                                    // Add file index to each feature and create unique record labels
                                    featData.features.forEach(f => {
                                        f.fileIdx = i;  // File index
                                        f.displayRecordId = `File ${i + 1}: ${f.record_id}`;
                                        // Make id unique across files by prefixing with file index
                                        f.id = `file${i}_${f.id}`;
                                    });
                                    allFeatures = allFeatures.concat(featData.features);
                                    // Add record labels with file prefix
                                    featData.record_ids.forEach((rid, ridx) => {
                                        allRecordLabels.push({ label: `File ${i + 1}: ${rid}`, fileIdx: i, recordIdx: ridx });
                                    });
                                }
                            }
                            extractedFeatures.value = allFeatures;
                            featureRecordIds.value = allRecordLabels.map(r => r.label);
                            selectedFeatureRecordIdx.value = 0;
                            rebuildColorOverrides(allFeatures);
                            console.log(`Extracted ${allFeatures.length} features from ${linearSeqs.length} file(s) for color editor.`);
                        } catch (e) {
                            console.log("Could not extract features:", e);
                        }
                    }

                } catch (e) {
                    errorLog.value = e.message;
                } finally {
                    processing.value = false;
                }
            };

            const downloadSVG = () => {
            if(!svgContent.value) return;
            const blob = new Blob([svgContent.value], {type: "image/svg+xml"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = results.value[selectedResultIndex.value].name;
            a.click();
            URL.revokeObjectURL(url);
            };

            const downloadPNG = () => {
                if(!svgContent.value) return;
                const svgEl = document.createElement('div');
                svgEl.innerHTML = svgContent.value;
                const svg = svgEl.querySelector('svg');
                if(!svg) return;
                let w = parseFloat(svg.getAttribute('width')); let h = parseFloat(svg.getAttribute('height'));
                if (!w || !h) { const parts = svg.getAttribute('viewBox').split(' '); w = parseFloat(parts[2]); h = parseFloat(parts[3]); }
                const canvas = document.createElement("canvas");
                const dpi = parseInt(downloadDpi.value); const scale = dpi / 96; 
                canvas.width = w * scale; canvas.height = h * scale;
                const ctx = canvas.getContext("2d");
                const img = new Image();
                const svgData = new XMLSerializer().serializeToString(svg);
                const blob = new Blob([svgData], {type: "image/svg+xml;charset=utf-8"});
                const url = URL.createObjectURL(blob);
                img.onload = () => {
                    ctx.fillStyle = "white"; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    canvas.toBlob(async (blob) => {
                         const fixedBlob = await setDpiInPng(blob, dpi);
                         const downloadUrl = URL.createObjectURL(fixedBlob);
                         const link = document.createElement('a');
                         let fname = results.value[selectedResultIndex.value].name;
                         fname = fname.replace(/\.svg$/i, ".png");
                         link.download = fname; link.href = downloadUrl; link.click();
                         URL.revokeObjectURL(downloadUrl); URL.revokeObjectURL(url);
                    }, "image/png");
                };
                img.src = url;
            };

            // ---- New PDF Download Function ----
            const downloadPDF = async () => {
                if(!svgContent.value) return;

                // 1. Create temporary SVG element to read dimensions
                const svgEl = document.createElement('div');
                svgEl.innerHTML = svgContent.value;
                const svg = svgEl.querySelector('svg');
                if(!svg) return;

                // 2. Determine Width/Height (Use attributes or viewBox)
                let w = parseFloat(svg.getAttribute('width'));
                let h = parseFloat(svg.getAttribute('height'));
                if (!w || !h) { 
                    const parts = svg.getAttribute('viewBox').split(' '); 
                    w = parseFloat(parts[2]); 
                    h = parseFloat(parts[3]); 
                }

                // 3. Initialize jsPDF (Use 'pt' as unit for vector fidelity)
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    orientation: w > h ? 'l' : 'p',
                    unit: 'pt',
                    format: [w, h]
                });

                // 4. Convert SVG to PDF
                await doc.svg(svg, {
                    x: 0,
                    y: 0,
                    width: w,
                    height: h
                });

                // 5. Save File
                let fname = results.value[selectedResultIndex.value].name;
                fname = fname.replace(/\.svg$/i, ".pdf");
                doc.save(fname);
            };

            // ---- Config I/O Functions ----
            const exportConfig = () => {
                const configData = {
                    form: form,
                    adv: adv,
                    colors: currentColors.value,
                    palette: selectedPalette.value,
                    rules: manualSpecificRules,
                    filterMode: filterMode.value,
                    whitelist: manualWhitelist,
                    blacklistText: manualBlacklist.value
                };
                const blob = new Blob([JSON.stringify(configData, null, 2)], {type: "application/json"});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = "gbdraw_config.json";
                a.click();
                URL.revokeObjectURL(url);
            };
            const safeDeepMerge = (target, source) => {
                if (!source || typeof source !== 'object') return;

                Object.keys(source).forEach(key => {
                    // 1. Prevent prototype pollution
                    if (['__proto__', 'constructor', 'prototype'].includes(key)) return;
                    
                    // 2. Ignore keys not present in target (whitelisting effect)
                    if (!Object.prototype.hasOwnProperty.call(target, key)) return;

                    const targetValue = target[key];
                    const sourceValue = source[key];

                    // 3. Recursive merge for objects
                    if (targetValue && typeof targetValue === 'object' && !Array.isArray(targetValue) &&
                        sourceValue && typeof sourceValue === 'object' && !Array.isArray(sourceValue)) {
                        safeDeepMerge(targetValue, sourceValue);
                    }
                    // 4. For arrays, intentionally overwrite (replacing lists of settings is natural)
                    else if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {
                        target[key].splice(0, target[key].length, ...sourceValue);
                    }
                    // 5. Update value only if types match or initial value is null
                    else if (typeof targetValue === typeof sourceValue || targetValue === null) {
                        target[key] = sourceValue;
                    }
                });
            };
            const importConfig = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                if (file.size > 10 * 1024 * 1024) {
                    alert("Config file is too large.");
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result, (key, value) => {
                            if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
                                return undefined;
                            }
                            return value;
                        });
                        
                        if (data.form) safeDeepMerge(form, data.form);
                        if (data.adv) safeDeepMerge(adv, data.adv);
                        if (data.colors) currentColors.value = data.colors; 
                        if (data.palette) selectedPalette.value = data.palette;
                        
                        if (data.rules && Array.isArray(data.rules)) {
                            manualSpecificRules.length = 0;
                            data.rules.forEach(r => {
                                manualSpecificRules.push({
                                    feat: String(r.feat || ''),
                                    qual: String(r.qual || ''),
                                    val: String(r.val || ''),
                                    color: String(r.color || '#000000'),
                                    cap: String(r.cap || '')
                                });
                            });
                        }
                        if (data.filterMode) filterMode.value = data.filterMode;
                        if (data.whitelist && Array.isArray(data.whitelist)) {
                            manualWhitelist.length = 0;
                            data.whitelist.forEach(w => {
                            manualWhitelist.push({
                                feat: String(w.feat || ''),
                                qual: String(w.qual || ''),
                                key: String(w.key || '')
                            });
                        });
                    }
                        if (data.blacklistText) manualBlacklist.value = String(data.blacklistText);
                        
                        alert("Configuration loaded successfully!");
                    } catch (err) {
                        console.error(err);
                        alert("Failed to load config: Invalid JSON structure.");
                    }
                };
                reader.readAsText(file);
                e.target.value = ''; 
            };

            return {
                pyodideReady, processing, loadingStatus, errorLog, results, selectedResultIndex, svgContent, zoom,
                mode, cInputType, lInputType, files, linearSeqs, form, adv,
                paletteNames, selectedPalette, currentColors, updatePalette, resetColors,
                filterMode, manualBlacklist, manualWhitelist, featureKeys, newColorFeat, newColorVal, addCustomColor,
                newFeatureToAdd, addFeature, manualSpecificRules, newSpecRule, addSpecificRule,
                // Feature Color Editor
                extractedFeatures, featureRecordIds, selectedFeatureRecordIdx,
                showFeaturePanel, featureSearch, filteredFeatures,
                featureColorOverrides, getFeatureColor, setFeatureColor, canEditFeatureColor,
                // SVG Feature Click
                svgContainer, clickedFeature, clickedFeaturePos, updateClickedFeatureColor,
                // Legend Editor
                showLegendPanel, legendEntries, newLegendCaption, newLegendColor,
                updateLegendEntryColor, updateLegendEntryCaption, deleteLegendEntry, addNewLegendEntry,
                moveLegendEntryUp, moveLegendEntryDown, resetLegendPosition,
                // Diagram Drag & Canvas
                resetAllPositions, canvasPadding, showCanvasControls, resetCanvasPadding,
                downloadDpi, runAnalysis, downloadSVG, downloadPNG, downloadPDF,
                exportConfig, importConfig, manualPriorityRules, newPriorityRule, addPriorityRule
            };
        }
    }).mount('#app');
</script>
</body>
</html>